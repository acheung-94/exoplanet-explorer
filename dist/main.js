/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scripts_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scripts/view */ \"./src/scripts/view.js\");\n/* harmony import */ var _scripts_starChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/starChart */ \"./src/scripts/starChart.js\");\n/* harmony import */ var _scripts_planetChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/planetChart */ \"./src/scripts/planetChart.js\");\n/* harmony import */ var _scripts_stellarObj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/stellarObj */ \"./src/scripts/stellarObj.js\");\n/* harmony import */ var audiomotion_analyzer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! audiomotion-analyzer */ \"./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js\");\nconsole.log(`hello!`);\n\n//import * as PlanetChart from \"./scripts/planetChart\";\n\n\n\n\n\n// SECTION : RESOURCE QUERIES\nfunction getStarSystemData() {\n  let proxiedURL = `https://cors-proxy-xphi.onrender.com/?url=` + generateURL();\n  return fetch(proxiedURL).then(res => {\n    if (res.ok) {\n      return res.json();\n    }\n  }).then(data => {\n    if (data.length) {\n      // ie if length is not zero\n      console.log(`data.length > 0 .. returning now`);\n      console.log(groupByHostName(data));\n      return groupByHostName(data);\n    } else {\n      // if data.lenght is zero (falsy)\n      console.log(`came up empty, trying again`);\n      return getStarSystemData();\n      //recursively call itself until data.length > 0\n    }\n  }).then(sortedData => {\n    if (sortedData) {\n      starSystemQueue = starSystemQueue.concat(sortedData);\n      console.log(starSystemQueue);\n    }\n  }).catch(err => console.error(err));\n}\nfunction getMusic() {\n  // last item, connect to soundcloud API\n}\n\n// SECTION : HELPERS\nfunction randomRARange() {\n  let ra1 = Math.floor(Math.random() * 360);\n  let ra2 = ra1 + 5;\n  if (ra2 >= 360) ra2 = 360;\n  return `ra between ${ra1} and ${ra2}`;\n}\nfunction generateURL() {\n  const url = `https://exoplanetarchive.ipac.caltech.edu/TAP/sync?query=`;\n  let dec = `between 0 and 180`;\n  let raRange = `${randomRARange()}`;\n  let plColumns = `pl_name,pl_rade,pl_bmasse,pl_dens,pl_eqt,pl_orbper,pl_orbsmax,disc_year,disc_facility,discoverymethod,`;\n  let stColumns = `hostname,st_spectype,st_teff,st_mass,st_rad,st_met,st_metratio,st_lum,rastr,decstr,sy_dist`;\n  let query = `select ${plColumns}${stColumns} from pscomppars where sy_snum = 1 and sy_pnum >= 2 and ${raRange} and dec ${dec}`;\n  //i think there might be another character encoding issue\n  query = query.split(\" \").join(\"+\");\n  let result = encodeURIComponent(`${url}${query}&format=json`);\n  return result;\n}\nfunction groupByHostName(data) {\n  let hostNames = []; // unique host systems\n  let allSystems = [];\n  if (data.length) {\n    // in the future this shouldn't be necessary. this will only be called if data.length > 0\n    data.forEach(record => {\n      if (record.hostname && !hostNames.includes(record.hostname)) {\n        hostNames.push(record.hostname);\n      }\n    });\n    hostNames.forEach(name => {\n      let system = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].hostname === name) {\n          system.push(data[i]);\n        }\n      }\n      allSystems.push(system);\n    });\n  }\n  return allSystems;\n}\nfunction getMousePos(canvas, event) {\n  let pos = {};\n  let rect = canvas.getBoundingClientRect();\n  pos.x = event.clientX - rect.left;\n  pos.y = event.clientY - rect.top;\n  return pos;\n}\nfunction getDistance(mouse, object) {\n  let a = (mouse.x - object.x) ** 2;\n  let b = (mouse.y - object.y) ** 2;\n  return Math.sqrt(a + b);\n}\nfunction startAnimation() {\n  refreshKey = setInterval(() => currentView.animate(), 20);\n}\n// SECTION : VARIABLES \nlet starSystemQueue = [];\nlet refreshKey;\nlet currentView;\nlet animating = false;\nconst renderContainer = document.querySelector('.canvas-container');\nlet canvas = document.querySelector('.background'); // i think I want two canvases... one for background and one for animation... that sounds like a good idea.\nlet container = canvas.parentNode.getBoundingClientRect();\ncanvas.height = container.height;\ncanvas.width = container.width;\nlet ctx = canvas.getContext('2d');\nctx.fillStyle = \"black\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\nconst audioEl = document.querySelector(\".audio\");\nconst audioMotion = new audiomotion_analyzer__WEBPACK_IMPORTED_MODULE_4__[\"default\"](document.querySelector(\".audio-container\"), {\n  source: audioEl,\n  height: 100,\n  width: 250,\n  // you can set other options below - check the docs!\n  mode: 3,\n  barSpace: .6,\n  ledBars: true\n});\n\n// SECTION : EVENT LISTENERS\nconst explore = document.querySelector(\".explore\");\nexplore.addEventListener(\"click\", function () {\n  clearInterval(refreshKey);\n  let starSystem = starSystemQueue.shift();\n  _scripts_starChart__WEBPACK_IMPORTED_MODULE_1__.populateStarChart(starSystem);\n  currentView = new _scripts_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"](starSystem, canvas);\n  refreshKey = setInterval(() => currentView.animate(), 20);\n  animating = true;\n  pause.innerText = \"Pause Animation\";\n  if (starSystemQueue.length < 2) {\n    getStarSystemData(); //hit the api and refresh the queue in the background. \n  }\n});\nconst pause = document.querySelector(\".pause\");\npause.addEventListener(\"click\", () => {\n  if (animating) {\n    clearInterval(refreshKey);\n    animating = false;\n    pause.innerText = \"Resume animation\";\n  } else {\n    startAnimation();\n    animating = true;\n    pause.innerText = \"Pause animation\";\n  }\n});\ncanvas.addEventListener(\"mousemove\", event => {\n  let mousePos = getMousePos(canvas, event);\n  currentView.hostStar.planets.forEach(planet => {\n    let distance = getDistance(mousePos, planet.pos);\n    if (distance <= planet.radius + 10) {\n      console.log(planet);\n      planet.highlighted = true;\n    } else {\n      planet.highlighted = false;\n    }\n  });\n});\n\n//click on planet\ncanvas.addEventListener(\"click\", event => {\n  let mousePos = getMousePos(canvas, event);\n  currentView.hostStar.planets.forEach(planet => {\n    let distance = getDistance(mousePos, planet.pos);\n    if (distance <= planet.radius + 5) {\n      // added a 5 px radius buffer for the baby planets\n      console.log(currentView.starSystem);\n      _scripts_planetChart__WEBPACK_IMPORTED_MODULE_2__.renderPlanetChart(planet, currentView.starSystem);\n    }\n  });\n});\n\n//click on star\ncanvas.addEventListener(\"click\", event => {\n  let mousePos = getMousePos(canvas, event);\n  let distance = getDistance(mousePos, currentView.hostStar.pos);\n  if (distance <= currentView.hostStar.radius) {\n    _scripts_starChart__WEBPACK_IMPORTED_MODULE_1__.renderStarChart();\n  }\n});\n\n//close planet card\nconst closePCard = document.querySelector(\".close-pcard\");\nclosePCard.addEventListener(\"click\", event => {\n  console.log(closePCard);\n  _scripts_planetChart__WEBPACK_IMPORTED_MODULE_2__.closePlanetChart();\n});\n//close star card\nconst closeSCard = document.querySelector(\".close-scard\");\ncloseSCard.addEventListener(\"click\", event => {\n  _scripts_starChart__WEBPACK_IMPORTED_MODULE_1__.closeStarChart();\n});\nconst audioPlay = document.querySelector(\".play-audio\");\naudioPlay.addEventListener(\"click\", () => {\n  audioEl.play();\n});\nconst audioPause = document.querySelector(\".pause-audio\");\naudioPause.addEventListener(\"click\", () => {\n  audioEl.pause();\n});\nconst vUp = document.querySelector(\".vol-up\");\nvUp.addEventListener(\"click\", () => {\n  if (audioEl.volume <= 1.0) {\n    audioEl.volume += 0.1;\n  }\n});\nconst vDown = document.querySelector(\".vol-down\");\nvDown.addEventListener(\"click\", () => {\n  audioEl.volume -= 0.1;\n});\n\n// SECTION : PAGE INITIALIZATION FUNCTIONS\ngetStarSystemData();\n\n// SECTION : IGNORE\n// canvas.addEventListener(\"mousemove\", function pauseAnimation(event) {\n//     //let boundary = currentView.hostStar.radius\n//     //let planetRadii = getPlanetRadii(currentView.hostStar.planets)\n//     //let starPos = currentView.hostStar.pos\n//     //let planetPositions = getPlanetPositions(currentView.hostStar.planets)\n//     let mousePos = getMousePos(canvas, event)\n//     currentView.hostStar.planets.forEach( (planet) => {\n//         console.log(planet)\n//         let distance = getDistance(mousePos, planet.pos)\n//         if (distance <= planet.radius && animating === true){\n//             animating = false\n//             clearInterval(refreshKey)\n//         }\n//         if (distance > planet.radius && animating === false){\n//             startAnimation()\n//             animating = true\n//             console.log(`uh oh`)\n//         }\n//     })\n//     // ok. so it keeps restarting the animation because there's always\n//     // going to be one planet where the else clause is true, thus restarting\n//     // the animation...\n//     // sigh. maybe i have to just create a click to pause...\n// })//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0VBQ3JDUCxPQUFPLENBQUM0QixJQUFJLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUM7QUFDRixNQUFNQyxVQUFVLEdBQUd2QyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxjQUFjLENBQUM7QUFDekRzQyxVQUFVLENBQUN0QixnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsTUFBSztFQUN0Q1AsT0FBTyxDQUFDWSxLQUFLLENBQUMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFDRixNQUFNa0IsR0FBRyxHQUFHeEMsUUFBUSxDQUFDQyxhQUFhLENBQUMsU0FBUyxDQUFDO0FBQzdDdUMsR0FBRyxDQUFDdkIsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQUk7RUFDOUIsSUFBR1AsT0FBTyxDQUFDK0IsTUFBTSxJQUFJLEdBQUcsRUFBRTtJQUN0Qi9CLE9BQU8sQ0FBQytCLE1BQU0sSUFBSSxHQUFHO0VBQ3pCO0FBQ0osQ0FBQyxDQUFDO0FBQ0YsTUFBTUMsS0FBSyxHQUFHMUMsUUFBUSxDQUFDQyxhQUFhLENBQUMsV0FBVyxDQUFDO0FBQ2pEeUMsS0FBSyxDQUFDekIsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQUk7RUFDaENQLE9BQU8sQ0FBQytCLE1BQU0sSUFBSSxHQUFHO0FBQ3pCLENBQUMsQ0FBQzs7QUFFRjtBQUNBOUcsaUJBQWlCLENBQUMsQ0FBQzs7QUFJbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZyhgaGVsbG8hYClcblxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vc2NyaXB0cy92aWV3XCI7XG4vL2ltcG9ydCAqIGFzIFBsYW5ldENoYXJ0IGZyb20gXCIuL3NjcmlwdHMvcGxhbmV0Q2hhcnRcIjtcbmltcG9ydCAqIGFzIFN0YXJDaGFydCBmcm9tIFwiLi9zY3JpcHRzL3N0YXJDaGFydFwiXG5pbXBvcnQgKiBhcyBQbGFuZXRDaGFydCBmcm9tIFwiLi9zY3JpcHRzL3BsYW5ldENoYXJ0XCJcbmltcG9ydCBTdGFyIGZyb20gXCIuL3NjcmlwdHMvc3RlbGxhck9ialwiO1xuaW1wb3J0IEF1ZGlvTW90aW9uQW5hbHl6ZXIgZnJvbSAnYXVkaW9tb3Rpb24tYW5hbHl6ZXInO1xuXG4vLyBTRUNUSU9OIDogUkVTT1VSQ0UgUVVFUklFU1xuZnVuY3Rpb24gZ2V0U3RhclN5c3RlbURhdGEoKXtcbiAgICBsZXQgcHJveGllZFVSTCA9IGBodHRwczovL2NvcnMtcHJveHkteHBoaS5vbnJlbmRlci5jb20vP3VybD1gKyBnZW5lcmF0ZVVSTCgpXG4gICAgcmV0dXJuIGZldGNoKHByb3hpZWRVUkwpXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMub2spe1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHsgLy8gaWUgaWYgbGVuZ3RoIGlzIG5vdCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGRhdGEubGVuZ3RoID4gMCAuLiByZXR1cm5pbmcgbm93YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncm91cEJ5SG9zdE5hbWUoZGF0YSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwQnlIb3N0TmFtZShkYXRhKVxuICAgICAgICAgICAgfWVsc2V7IC8vIGlmIGRhdGEubGVuZ2h0IGlzIHplcm8gKGZhbHN5KVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjYW1lIHVwIGVtcHR5LCB0cnlpbmcgYWdhaW5gKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdGFyU3lzdGVtRGF0YSgpXG4gICAgICAgICAgICAgICAgLy9yZWN1cnNpdmVseSBjYWxsIGl0c2VsZiB1bnRpbCBkYXRhLmxlbmd0aCA+IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbiggKHNvcnRlZERhdGEpPT57XG4gICAgICAgICAgICBpZiAoc29ydGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIHN0YXJTeXN0ZW1RdWV1ZSA9IHN0YXJTeXN0ZW1RdWV1ZS5jb25jYXQoc29ydGVkRGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGFyU3lzdGVtUXVldWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT4gY29uc29sZS5lcnJvcihlcnIpKVxufVxuXG5mdW5jdGlvbiBnZXRNdXNpYyAoKSB7XG4gICAgLy8gbGFzdCBpdGVtLCBjb25uZWN0IHRvIHNvdW5kY2xvdWQgQVBJXG59XG5cblxuXG4vLyBTRUNUSU9OIDogSEVMUEVSU1xuZnVuY3Rpb24gcmFuZG9tUkFSYW5nZSgpIHtcbiAgICBsZXQgcmExID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzYwKVxuICAgIGxldCByYTIgPSByYTEgKyA1XG4gICAgaWYgKHJhMiA+PSAzNjApIHJhMiA9IDM2MDtcbiAgICByZXR1cm4gYHJhIGJldHdlZW4gJHtyYTF9IGFuZCAke3JhMn1gXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVJMKCl7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vZXhvcGxhbmV0YXJjaGl2ZS5pcGFjLmNhbHRlY2guZWR1L1RBUC9zeW5jP3F1ZXJ5PWBcbiAgICBsZXQgZGVjID0gYGJldHdlZW4gMCBhbmQgMTgwYFxuICAgIGxldCByYVJhbmdlID0gYCR7cmFuZG9tUkFSYW5nZSgpfWBcbiAgICBsZXQgcGxDb2x1bW5zID0gYHBsX25hbWUscGxfcmFkZSxwbF9ibWFzc2UscGxfZGVucyxwbF9lcXQscGxfb3JicGVyLHBsX29yYnNtYXgsZGlzY195ZWFyLGRpc2NfZmFjaWxpdHksZGlzY292ZXJ5bWV0aG9kLGBcbiAgICBsZXQgc3RDb2x1bW5zID0gYGhvc3RuYW1lLHN0X3NwZWN0eXBlLHN0X3RlZmYsc3RfbWFzcyxzdF9yYWQsc3RfbWV0LHN0X21ldHJhdGlvLHN0X2x1bSxyYXN0cixkZWNzdHIsc3lfZGlzdGBcbiAgICBsZXQgcXVlcnkgPSBgc2VsZWN0ICR7cGxDb2x1bW5zfSR7c3RDb2x1bW5zfSBmcm9tIHBzY29tcHBhcnMgd2hlcmUgc3lfc251bSA9IDEgYW5kIHN5X3BudW0gPj0gMiBhbmQgJHtyYVJhbmdlfSBhbmQgZGVjICR7ZGVjfWBcbiAgICAvL2kgdGhpbmsgdGhlcmUgbWlnaHQgYmUgYW5vdGhlciBjaGFyYWN0ZXIgZW5jb2RpbmcgaXNzdWVcbiAgICBxdWVyeSA9IHF1ZXJ5LnNwbGl0KFwiIFwiKS5qb2luKFwiK1wiKVxuICAgIGxldCByZXN1bHQgPSBlbmNvZGVVUklDb21wb25lbnQoYCR7dXJsfSR7cXVlcnl9JmZvcm1hdD1qc29uYClcblxuICAgIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeUhvc3ROYW1lKGRhdGEpe1xuICAgIGxldCBob3N0TmFtZXMgPSBbXSAvLyB1bmlxdWUgaG9zdCBzeXN0ZW1zXG4gICAgbGV0IGFsbFN5c3RlbXMgPSBbXVxuICAgIGlmIChkYXRhLmxlbmd0aCl7IC8vIGluIHRoZSBmdXR1cmUgdGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LiB0aGlzIHdpbGwgb25seSBiZSBjYWxsZWQgaWYgZGF0YS5sZW5ndGggPiAwXG4gICAgICAgIGRhdGEuZm9yRWFjaCggKHJlY29yZCkgPT57XG4gICAgICAgIGlmIChyZWNvcmQuaG9zdG5hbWUgJiYgIWhvc3ROYW1lcy5pbmNsdWRlcyhyZWNvcmQuaG9zdG5hbWUpKXtcbiAgICAgICAgICAgIGhvc3ROYW1lcy5wdXNoKHJlY29yZC5ob3N0bmFtZSlcbiAgICAgICAgfVxuICAgIH0pXG4gICAgaG9zdE5hbWVzLmZvckVhY2goKG5hbWUpPT57XG4gICAgICAgIGxldCBzeXN0ZW0gPSBbXVxuICAgICAgICBmb3IobGV0IGk9MDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRhdGFbaV0uaG9zdG5hbWUgPT09IG5hbWUpe1xuICAgICAgICAgICAgICAgIHN5c3RlbS5wdXNoKGRhdGFbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWxsU3lzdGVtcy5wdXNoKHN5c3RlbSlcbiAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBhbGxTeXN0ZW1zXG59XG5cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpe1xuICAgIGxldCBwb3MgPSB7fTtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBwb3MueCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgcG9zLnkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgcmV0dXJuIHBvc1xufVxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShtb3VzZSwgb2JqZWN0KXtcbiAgICBsZXQgYSA9IChtb3VzZS54IC0gb2JqZWN0LngpKioyXG4gICAgbGV0IGIgPSAobW91c2UueSAtIG9iamVjdC55KSoqMlxuICAgIHJldHVybiBNYXRoLnNxcnQoYStiKVxufVxuXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbigpe1xuICAgIHJlZnJlc2hLZXkgPSBzZXRJbnRlcnZhbCgoKT0+IGN1cnJlbnRWaWV3LmFuaW1hdGUoKSwgMjApXG59XG4vLyBTRUNUSU9OIDogVkFSSUFCTEVTIFxubGV0IHN0YXJTeXN0ZW1RdWV1ZSA9IFtdXG5sZXQgcmVmcmVzaEtleTtcbmxldCBjdXJyZW50VmlldztcbmxldCBhbmltYXRpbmcgPSBmYWxzZVxuXG5jb25zdCByZW5kZXJDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpXG5sZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKSAvLyBpIHRoaW5rIEkgd2FudCB0d28gY2FudmFzZXMuLi4gb25lIGZvciBiYWNrZ3JvdW5kIGFuZCBvbmUgZm9yIGFuaW1hdGlvbi4uLiB0aGF0IHNvdW5kcyBsaWtlIGEgZ29vZCBpZGVhLlxubGV0IGNvbnRhaW5lciA9IGNhbnZhcy5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuY2FudmFzLmhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHRcbmNhbnZhcy53aWR0aCA9IGNvbnRhaW5lci53aWR0aFxubGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiXG5jdHguZmlsbFJlY3QoMCwwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5jb25zdCBhdWRpb0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5hdWRpb1wiKVxuY29uc3QgYXVkaW9Nb3Rpb24gPSBuZXcgQXVkaW9Nb3Rpb25BbmFseXplcihcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmF1ZGlvLWNvbnRhaW5lclwiKSxcbiAgICB7XG4gICAgICBzb3VyY2U6IGF1ZGlvRWwsXG4gICAgICBoZWlnaHQ6IDEwMCxcbiAgICAgIHdpZHRoOiAyNTAsXG4gICAgICAvLyB5b3UgY2FuIHNldCBvdGhlciBvcHRpb25zIGJlbG93IC0gY2hlY2sgdGhlIGRvY3MhXG4gICAgICBtb2RlOiAzLFxuICAgICAgYmFyU3BhY2U6IC42LFxuICAgICAgbGVkQmFyczogdHJ1ZSxcbiAgICB9XG4gICk7XG5cbi8vIFNFQ1RJT04gOiBFVkVOVCBMSVNURU5FUlNcbmNvbnN0IGV4cGxvcmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmV4cGxvcmVcIilcbmV4cGxvcmUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG5cbiAgICBjbGVhckludGVydmFsKHJlZnJlc2hLZXkpXG4gICAgbGV0IHN0YXJTeXN0ZW0gPSBzdGFyU3lzdGVtUXVldWUuc2hpZnQoKVxuICAgIFN0YXJDaGFydC5wb3B1bGF0ZVN0YXJDaGFydChzdGFyU3lzdGVtKVxuICAgIGN1cnJlbnRWaWV3ID0gbmV3IFZpZXcoc3RhclN5c3RlbSwgY2FudmFzKVxuICAgIHJlZnJlc2hLZXkgPSBzZXRJbnRlcnZhbCgoKSA9PiBjdXJyZW50Vmlldy5hbmltYXRlKCksIDIwKVxuICAgIGFuaW1hdGluZyA9IHRydWVcbiAgICBwYXVzZS5pbm5lclRleHQgPSBcIlBhdXNlIEFuaW1hdGlvblwiXG4gICAgaWYgKHN0YXJTeXN0ZW1RdWV1ZS5sZW5ndGggPCAyKXtcbiAgICAgICAgZ2V0U3RhclN5c3RlbURhdGEoKSAvL2hpdCB0aGUgYXBpIGFuZCByZWZyZXNoIHRoZSBxdWV1ZSBpbiB0aGUgYmFja2dyb3VuZC4gXG4gICAgfVxuICAgIFxufSlcblxuY29uc3QgcGF1c2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnBhdXNlXCIpXG5wYXVzZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCk9PntcbiAgICBpZiAoYW5pbWF0aW5nKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVmcmVzaEtleSlcbiAgICAgICAgYW5pbWF0aW5nID0gZmFsc2VcbiAgICAgICAgcGF1c2UuaW5uZXJUZXh0ID0gXCJSZXN1bWUgYW5pbWF0aW9uXCJcbiAgICB9ZWxzZXtcbiAgICAgICAgc3RhcnRBbmltYXRpb24oKVxuICAgICAgICBhbmltYXRpbmcgPSB0cnVlXG4gICAgICAgIHBhdXNlLmlubmVyVGV4dCA9IFwiUGF1c2UgYW5pbWF0aW9uXCJcbiAgICB9XG59KVxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgKGV2ZW50KT0+e1xuXG4gICAgbGV0IG1vdXNlUG9zID0gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudClcbiAgICBjdXJyZW50Vmlldy5ob3N0U3Rhci5wbGFuZXRzLmZvckVhY2ggKCAocGxhbmV0KSA9PiB7XG4gICAgICAgIGxldCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKG1vdXNlUG9zLCBwbGFuZXQucG9zKVxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gKHBsYW5ldC5yYWRpdXMgKyAxMCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHBsYW5ldClcbiAgICAgICAgICAgIHBsYW5ldC5oaWdobGlnaHRlZCA9IHRydWVcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBwbGFuZXQuaGlnaGxpZ2h0ZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfSlcbn0pXG5cbi8vY2xpY2sgb24gcGxhbmV0XG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldmVudCk9PntcbiAgICBsZXQgbW91c2VQb3MgPSBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KVxuICAgIGN1cnJlbnRWaWV3Lmhvc3RTdGFyLnBsYW5ldHMuZm9yRWFjaCgocGxhbmV0KSA9PiB7XG4gICAgICAgIGxldCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKG1vdXNlUG9zLCBwbGFuZXQucG9zKVxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gKHBsYW5ldC5yYWRpdXMgKyA1KSkgeyAvLyBhZGRlZCBhIDUgcHggcmFkaXVzIGJ1ZmZlciBmb3IgdGhlIGJhYnkgcGxhbmV0c1xuICAgICAgICAgICAgY29uc29sZS5sb2coY3VycmVudFZpZXcuc3RhclN5c3RlbSlcbiAgICAgICAgICAgIFBsYW5ldENoYXJ0LnJlbmRlclBsYW5ldENoYXJ0KHBsYW5ldCwgY3VycmVudFZpZXcuc3RhclN5c3RlbSlcbiAgICAgICAgfVxuICAgIH0pXG59KVxuXG4vL2NsaWNrIG9uIHN0YXJcbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgbGV0IG1vdXNlUG9zID0gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudClcbiAgICBsZXQgZGlzdGFuY2UgPSBnZXREaXN0YW5jZShtb3VzZVBvcywgY3VycmVudFZpZXcuaG9zdFN0YXIucG9zKVxuICAgIGlmIChkaXN0YW5jZSA8PSBjdXJyZW50Vmlldy5ob3N0U3Rhci5yYWRpdXMpe1xuICAgICAgICBTdGFyQ2hhcnQucmVuZGVyU3RhckNoYXJ0KClcbiAgICB9XG59KVxuXG4vL2Nsb3NlIHBsYW5ldCBjYXJkXG5jb25zdCBjbG9zZVBDYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jbG9zZS1wY2FyZFwiKVxuY2xvc2VQQ2FyZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KT0+e1xuICAgIGNvbnNvbGUubG9nKGNsb3NlUENhcmQpXG4gICAgUGxhbmV0Q2hhcnQuY2xvc2VQbGFuZXRDaGFydCgpXG59KVxuLy9jbG9zZSBzdGFyIGNhcmRcbmNvbnN0IGNsb3NlU0NhcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNsb3NlLXNjYXJkXCIpXG5jbG9zZVNDYXJkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICBTdGFyQ2hhcnQuY2xvc2VTdGFyQ2hhcnQoKVxufSlcblxuY29uc3QgYXVkaW9QbGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wbGF5LWF1ZGlvXCIpXG5hdWRpb1BsYXkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpPT4ge1xuICAgIGF1ZGlvRWwucGxheSgpXG59KVxuY29uc3QgYXVkaW9QYXVzZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGF1c2UtYXVkaW9cIilcbmF1ZGlvUGF1c2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpPT4ge1xuICAgIGF1ZGlvRWwucGF1c2UoKVxufSlcbmNvbnN0IHZVcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudm9sLXVwXCIpXG52VXAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpPT57XG4gICAgaWYoYXVkaW9FbC52b2x1bWUgPD0gMS4wKSB7XG4gICAgICAgIGF1ZGlvRWwudm9sdW1lICs9IDAuMTtcbiAgICB9XG59KVxuY29uc3QgdkRvd24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnZvbC1kb3duXCIpXG52RG93bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCk9PntcbiAgICBhdWRpb0VsLnZvbHVtZSAtPSAwLjE7XG59KVxuXG4vLyBTRUNUSU9OIDogUEFHRSBJTklUSUFMSVpBVElPTiBGVU5DVElPTlNcbmdldFN0YXJTeXN0ZW1EYXRhKClcblxuXG5cbi8vIFNFQ1RJT04gOiBJR05PUkVcbi8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIHBhdXNlQW5pbWF0aW9uKGV2ZW50KSB7XG4vLyAgICAgLy9sZXQgYm91bmRhcnkgPSBjdXJyZW50Vmlldy5ob3N0U3Rhci5yYWRpdXNcbi8vICAgICAvL2xldCBwbGFuZXRSYWRpaSA9IGdldFBsYW5ldFJhZGlpKGN1cnJlbnRWaWV3Lmhvc3RTdGFyLnBsYW5ldHMpXG4vLyAgICAgLy9sZXQgc3RhclBvcyA9IGN1cnJlbnRWaWV3Lmhvc3RTdGFyLnBvc1xuLy8gICAgIC8vbGV0IHBsYW5ldFBvc2l0aW9ucyA9IGdldFBsYW5ldFBvc2l0aW9ucyhjdXJyZW50Vmlldy5ob3N0U3Rhci5wbGFuZXRzKVxuLy8gICAgIGxldCBtb3VzZVBvcyA9IGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpXG4vLyAgICAgY3VycmVudFZpZXcuaG9zdFN0YXIucGxhbmV0cy5mb3JFYWNoKCAocGxhbmV0KSA9PiB7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKHBsYW5ldClcbi8vICAgICAgICAgbGV0IGRpc3RhbmNlID0gZ2V0RGlzdGFuY2UobW91c2VQb3MsIHBsYW5ldC5wb3MpXG4vLyAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBwbGFuZXQucmFkaXVzICYmIGFuaW1hdGluZyA9PT0gdHJ1ZSl7XG4vLyAgICAgICAgICAgICBhbmltYXRpbmcgPSBmYWxzZVxuLy8gICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWZyZXNoS2V5KVxuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGlmIChkaXN0YW5jZSA+IHBsYW5ldC5yYWRpdXMgJiYgYW5pbWF0aW5nID09PSBmYWxzZSl7XG4vLyAgICAgICAgICAgICBzdGFydEFuaW1hdGlvbigpXG4vLyAgICAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlXG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdWggb2hgKVxuLy8gICAgICAgICB9XG4vLyAgICAgfSlcbi8vICAgICAvLyBvay4gc28gaXQga2VlcHMgcmVzdGFydGluZyB0aGUgYW5pbWF0aW9uIGJlY2F1c2UgdGhlcmUncyBhbHdheXNcbi8vICAgICAvLyBnb2luZyB0byBiZSBvbmUgcGxhbmV0IHdoZXJlIHRoZSBlbHNlIGNsYXVzZSBpcyB0cnVlLCB0aHVzIHJlc3RhcnRpbmdcbi8vICAgICAvLyB0aGUgYW5pbWF0aW9uLi4uXG4vLyAgICAgLy8gc2lnaC4gbWF5YmUgaSBoYXZlIHRvIGp1c3QgY3JlYXRlIGEgY2xpY2sgdG8gcGF1c2UuLi5cbi8vIH0pXG5cbiJdLCJuYW1lcyI6WyJjb25zb2xlIiwibG9nIiwiVmlldyIsIlN0YXJDaGFydCIsIlBsYW5ldENoYXJ0IiwiU3RhciIsIkF1ZGlvTW90aW9uQW5hbHl6ZXIiLCJnZXRTdGFyU3lzdGVtRGF0YSIsInByb3hpZWRVUkwiLCJnZW5lcmF0ZVVSTCIsImZldGNoIiwidGhlbiIsInJlcyIsIm9rIiwianNvbiIsImRhdGEiLCJsZW5ndGgiLCJncm91cEJ5SG9zdE5hbWUiLCJzb3J0ZWREYXRhIiwic3RhclN5c3RlbVF1ZXVlIiwiY29uY2F0IiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsImdldE11c2ljIiwicmFuZG9tUkFSYW5nZSIsInJhMSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJhMiIsInVybCIsImRlYyIsInJhUmFuZ2UiLCJwbENvbHVtbnMiLCJzdENvbHVtbnMiLCJxdWVyeSIsInNwbGl0Iiwiam9pbiIsInJlc3VsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImhvc3ROYW1lcyIsImFsbFN5c3RlbXMiLCJmb3JFYWNoIiwicmVjb3JkIiwiaG9zdG5hbWUiLCJpbmNsdWRlcyIsInB1c2giLCJuYW1lIiwic3lzdGVtIiwiaSIsImdldE1vdXNlUG9zIiwiY2FudmFzIiwiZXZlbnQiLCJwb3MiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJsZWZ0IiwieSIsImNsaWVudFkiLCJ0b3AiLCJnZXREaXN0YW5jZSIsIm1vdXNlIiwib2JqZWN0IiwiYSIsImIiLCJzcXJ0Iiwic3RhcnRBbmltYXRpb24iLCJyZWZyZXNoS2V5Iiwic2V0SW50ZXJ2YWwiLCJjdXJyZW50VmlldyIsImFuaW1hdGUiLCJhbmltYXRpbmciLCJyZW5kZXJDb250YWluZXIiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjb250YWluZXIiLCJwYXJlbnROb2RlIiwiaGVpZ2h0Iiwid2lkdGgiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJhdWRpb0VsIiwiYXVkaW9Nb3Rpb24iLCJzb3VyY2UiLCJtb2RlIiwiYmFyU3BhY2UiLCJsZWRCYXJzIiwiZXhwbG9yZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjbGVhckludGVydmFsIiwic3RhclN5c3RlbSIsInNoaWZ0IiwicG9wdWxhdGVTdGFyQ2hhcnQiLCJwYXVzZSIsImlubmVyVGV4dCIsIm1vdXNlUG9zIiwiaG9zdFN0YXIiLCJwbGFuZXRzIiwicGxhbmV0IiwiZGlzdGFuY2UiLCJyYWRpdXMiLCJoaWdobGlnaHRlZCIsInJlbmRlclBsYW5ldENoYXJ0IiwicmVuZGVyU3RhckNoYXJ0IiwiY2xvc2VQQ2FyZCIsImNsb3NlUGxhbmV0Q2hhcnQiLCJjbG9zZVNDYXJkIiwiY2xvc2VTdGFyQ2hhcnQiLCJhdWRpb1BsYXkiLCJwbGF5IiwiYXVkaW9QYXVzZSIsInZVcCIsInZvbHVtZSIsInZEb3duIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/planetChart.js":
/*!************************************!*\
  !*** ./src/scripts/planetChart.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closePlanetChart: function() { return /* binding */ closePlanetChart; },\n/* harmony export */   populatePlanetChart: function() { return /* binding */ populatePlanetChart; },\n/* harmony export */   renderPlanetChart: function() { return /* binding */ renderPlanetChart; }\n/* harmony export */ });\nfunction populatePlanetChart(planet) {\n  //planet is a data object\n  //console.log(currentPlanetData)\n  let name = document.querySelector(\".pname\");\n  name.innerText = planet.pl_name;\n  let radius = document.querySelector(\".pradius\");\n  radius.innerText = `${planet.pl_rade * 6370} km`;\n  let mass = document.querySelector(\".pmass\");\n  mass.innerText = `${planet.pl_bmasse} x Earth mass`;\n  let density = document.querySelector(\".pdensity\");\n  density.innerText = `${planet.pl_dens} g/cm^3`;\n  let temp = document.querySelector(\".ptemp\");\n  temp.innerText = `${planet.pl_eqt || `unknown`} K`;\n  let orbper = document.querySelector(\".porb-per\");\n  orbper.innerText = `${planet.pl_orbper} days`;\n  let discYr = document.querySelector(\".pdisc-year\");\n  discYr.innerText = planet.disc_year;\n  let facility = document.querySelector(\".pdisc-facility\");\n  facility.innerText = planet.disc_facility;\n  let det = document.querySelector(\".pdisc-method\");\n  det.innerText = planet.discoverymethod;\n}\nfunction renderPlanetChart(planet, starSystem) {\n  let planetCard = document.querySelector(\".planet-card\");\n  let currentPlanetData;\n  starSystem.forEach(entry => {\n    if (planet.name === entry.pl_name) currentPlanetData = entry;\n  });\n  populatePlanetChart(currentPlanetData);\n  planetCard.style.visibility = \"visible\";\n}\nfunction closePlanetChart() {\n  let planetCard = document.querySelector(\".planet-card\"); // a way to dry this all up? :/ may not be able to since i'm exporting these functions\n  planetCard.style.visibility = \"hidden\";\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9wbGFuZXRDaGFydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTyxTQUFTQSxtQkFBbUJBLENBQUNDLE1BQU0sRUFBRTtFQUN4QztFQUNBO0VBQ0EsSUFBSUMsSUFBSSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxRQUFRLENBQUM7RUFDM0NGLElBQUksQ0FBQ0csU0FBUyxHQUFHSixNQUFNLENBQUNLLE9BQU87RUFFL0IsSUFBSUMsTUFBTSxHQUFHSixRQUFRLENBQUNDLGFBQWEsQ0FBQyxVQUFVLENBQUM7RUFDL0NHLE1BQU0sQ0FBQ0YsU0FBUyxHQUFJLEdBQUVKLE1BQU0sQ0FBQ08sT0FBTyxHQUFHLElBQUssS0FBSTtFQUVoRCxJQUFJQyxJQUFJLEdBQUdOLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLFFBQVEsQ0FBQztFQUMzQ0ssSUFBSSxDQUFDSixTQUFTLEdBQUksR0FBRUosTUFBTSxDQUFDUyxTQUFVLGVBQWM7RUFFbkQsSUFBSUMsT0FBTyxHQUFHUixRQUFRLENBQUNDLGFBQWEsQ0FBQyxXQUFXLENBQUM7RUFDakRPLE9BQU8sQ0FBQ04sU0FBUyxHQUFJLEdBQUVKLE1BQU0sQ0FBQ1csT0FBUSxTQUFRO0VBRTlDLElBQUlDLElBQUksR0FBR1YsUUFBUSxDQUFDQyxhQUFhLENBQUMsUUFBUSxDQUFDO0VBQzNDUyxJQUFJLENBQUNSLFNBQVMsR0FBSSxHQUFFSixNQUFNLENBQUNhLE1BQU0sSUFBSyxTQUFTLElBQUc7RUFFbEQsSUFBSUMsTUFBTSxHQUFHWixRQUFRLENBQUNDLGFBQWEsQ0FBQyxXQUFXLENBQUM7RUFDaERXLE1BQU0sQ0FBQ1YsU0FBUyxHQUFJLEdBQUVKLE1BQU0sQ0FBQ2UsU0FBVSxPQUFNO0VBRTdDLElBQUlDLE1BQU0sR0FBR2QsUUFBUSxDQUFDQyxhQUFhLENBQUMsYUFBYSxDQUFDO0VBQ2xEYSxNQUFNLENBQUNaLFNBQVMsR0FBR0osTUFBTSxDQUFDaUIsU0FBUztFQUVuQyxJQUFJQyxRQUFRLEdBQUdoQixRQUFRLENBQUNDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztFQUN4RGUsUUFBUSxDQUFDZCxTQUFTLEdBQUdKLE1BQU0sQ0FBQ21CLGFBQWE7RUFFekMsSUFBSUMsR0FBRyxHQUFHbEIsUUFBUSxDQUFDQyxhQUFhLENBQUMsZUFBZSxDQUFDO0VBQ2pEaUIsR0FBRyxDQUFDaEIsU0FBUyxHQUFHSixNQUFNLENBQUNxQixlQUFlO0FBQzFDO0FBRU8sU0FBU0MsaUJBQWlCQSxDQUFDdEIsTUFBTSxFQUFFdUIsVUFBVSxFQUFFO0VBQ2xELElBQUlDLFVBQVUsR0FBR3RCLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLGNBQWMsQ0FBQztFQUN2RCxJQUFJc0IsaUJBQWlCO0VBQ3JCRixVQUFVLENBQUNHLE9BQU8sQ0FBRUMsS0FBSyxJQUFLO0lBQzFCLElBQUkzQixNQUFNLENBQUNDLElBQUksS0FBSzBCLEtBQUssQ0FBQ3RCLE9BQU8sRUFBRW9CLGlCQUFpQixHQUFHRSxLQUFLO0VBQ2hFLENBQUMsQ0FBQztFQUNGNUIsbUJBQW1CLENBQUMwQixpQkFBaUIsQ0FBQztFQUN0Q0QsVUFBVSxDQUFDSSxLQUFLLENBQUNDLFVBQVUsR0FBRyxTQUFTO0FBQzNDO0FBRU8sU0FBU0MsZ0JBQWdCQSxDQUFBLEVBQUc7RUFDL0IsSUFBSU4sVUFBVSxHQUFHdEIsUUFBUSxDQUFDQyxhQUFhLENBQUMsY0FBYyxDQUFDLEVBQUM7RUFDeERxQixVQUFVLENBQUNJLEtBQUssQ0FBQ0MsVUFBVSxHQUFHLFFBQVE7QUFFMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvc2NyaXB0cy9wbGFuZXRDaGFydC5qcz85NDI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVBsYW5ldENoYXJ0KHBsYW5ldCkge1xuICAgIC8vcGxhbmV0IGlzIGEgZGF0YSBvYmplY3RcbiAgICAvL2NvbnNvbGUubG9nKGN1cnJlbnRQbGFuZXREYXRhKVxuICAgIGxldCBuYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wbmFtZVwiKVxuICAgIG5hbWUuaW5uZXJUZXh0ID0gcGxhbmV0LnBsX25hbWVcblxuICAgIGxldCByYWRpdXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnByYWRpdXNcIilcbiAgICByYWRpdXMuaW5uZXJUZXh0ID0gYCR7cGxhbmV0LnBsX3JhZGUgKiA2MzcwfSBrbWBcblxuICAgIGxldCBtYXNzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wbWFzc1wiKVxuICAgIG1hc3MuaW5uZXJUZXh0ID0gYCR7cGxhbmV0LnBsX2JtYXNzZX0geCBFYXJ0aCBtYXNzYFxuXG4gICAgbGV0IGRlbnNpdHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnBkZW5zaXR5XCIpXG4gICAgZGVuc2l0eS5pbm5lclRleHQgPSBgJHtwbGFuZXQucGxfZGVuc30gZy9jbV4zYFxuXG4gICAgbGV0IHRlbXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnB0ZW1wXCIpXG4gICAgdGVtcC5pbm5lclRleHQgPSBgJHtwbGFuZXQucGxfZXF0IHx8IGB1bmtub3duYH0gS2BcblxuICAgIGxldCBvcmJwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnBvcmItcGVyXCIpXG4gICAgb3JicGVyLmlubmVyVGV4dCA9IGAke3BsYW5ldC5wbF9vcmJwZXJ9IGRheXNgXG5cbiAgICBsZXQgZGlzY1lyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wZGlzYy15ZWFyXCIpXG4gICAgZGlzY1lyLmlubmVyVGV4dCA9IHBsYW5ldC5kaXNjX3llYXJcblxuICAgIGxldCBmYWNpbGl0eSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGRpc2MtZmFjaWxpdHlcIilcbiAgICBmYWNpbGl0eS5pbm5lclRleHQgPSBwbGFuZXQuZGlzY19mYWNpbGl0eVxuXG4gICAgbGV0IGRldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGRpc2MtbWV0aG9kXCIpXG4gICAgZGV0LmlubmVyVGV4dCA9IHBsYW5ldC5kaXNjb3ZlcnltZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclBsYW5ldENoYXJ0KHBsYW5ldCwgc3RhclN5c3RlbSkge1xuICAgIGxldCBwbGFuZXRDYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wbGFuZXQtY2FyZFwiKVxuICAgIGxldCBjdXJyZW50UGxhbmV0RGF0YTtcbiAgICBzdGFyU3lzdGVtLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmIChwbGFuZXQubmFtZSA9PT0gZW50cnkucGxfbmFtZSkgY3VycmVudFBsYW5ldERhdGEgPSBlbnRyeTtcbiAgICB9KVxuICAgIHBvcHVsYXRlUGxhbmV0Q2hhcnQoY3VycmVudFBsYW5ldERhdGEpO1xuICAgIHBsYW5ldENhcmQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VQbGFuZXRDaGFydCgpIHtcbiAgICBsZXQgcGxhbmV0Q2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGxhbmV0LWNhcmRcIikgLy8gYSB3YXkgdG8gZHJ5IHRoaXMgYWxsIHVwPyA6LyBtYXkgbm90IGJlIGFibGUgdG8gc2luY2UgaSdtIGV4cG9ydGluZyB0aGVzZSBmdW5jdGlvbnNcbiAgICBwbGFuZXRDYXJkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXG59XG5cbiJdLCJuYW1lcyI6WyJwb3B1bGF0ZVBsYW5ldENoYXJ0IiwicGxhbmV0IiwibmFtZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImlubmVyVGV4dCIsInBsX25hbWUiLCJyYWRpdXMiLCJwbF9yYWRlIiwibWFzcyIsInBsX2JtYXNzZSIsImRlbnNpdHkiLCJwbF9kZW5zIiwidGVtcCIsInBsX2VxdCIsIm9yYnBlciIsInBsX29yYnBlciIsImRpc2NZciIsImRpc2NfeWVhciIsImZhY2lsaXR5IiwiZGlzY19mYWNpbGl0eSIsImRldCIsImRpc2NvdmVyeW1ldGhvZCIsInJlbmRlclBsYW5ldENoYXJ0Iiwic3RhclN5c3RlbSIsInBsYW5ldENhcmQiLCJjdXJyZW50UGxhbmV0RGF0YSIsImZvckVhY2giLCJlbnRyeSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImNsb3NlUGxhbmV0Q2hhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scripts/planetChart.js\n");

/***/ }),

/***/ "./src/scripts/planetaryObj.js":
/*!*************************************!*\
  !*** ./src/scripts/planetaryObj.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nclass Planet {\n  constructor(planetData, hostStar) {\n    this.hostStar = hostStar;\n    this.name = planetData[\"pl_name\"];\n    this.radius = this.scaleRadius(planetData[\"pl_rade\"], hostStar);\n    this.distance = this.scaleDistance(planetData[\"pl_orbsmax\"], hostStar);\n    this.angle = Math.random() * (Math.PI * 2); // random starting angle in radians.\n    this.color = \"pink\"; // planetData[\"pl_insol\"]\n    this.vel = this.angularVelocity(planetData[\"pl_orbper\"]); // radians per frame\n    this.pos = {\n      \"x\": hostStar.pos.x + this.distance * Math.cos(this.angle),\n      \"y\": hostStar.pos.y + this.distance * Math.sin(this.angle)\n    };\n    this.highlighted = false;\n    //console.log(this.name, this.vel) // for adjustment\n  }\n\n  // scaleColor(temp){\n  //     if (temp > 180 && temp < 280){\n  //         return \n  //     }\n  // }\n\n  scaleRadius(radius, hostStar) {\n    if (radius > 10) {\n      let conversion = hostStar.radius * 0.01;\n      let scaled = radius * conversion;\n      return scaled;\n    } else {\n      return radius;\n    }\n  }\n  scaleDistance(semiMajorAxis, hostStar) {\n    // if smax is null... give it a default value pls.\n    semiMajorAxis ??= 10;\n    return hostStar.radius + semiMajorAxis * 20;\n    // if (semiMajorAxis <= 5){\n    //     //console.log(semiMajorAxis)\n    //     let adjusted = hostStar.radius + 25 + ((semiMajorAxis/10) * 50)\n    //     //console.log(adjusted)\n    //     return adjusted\n    // }else if (semiMajorAxis > 5 && semiMajorAxis < 100) {\n    //     return hostStar.radius + 50 + ((semiMajorAxis / 100) * 50)\n\n    // }else if (semiMajorAxis >= 100 && semiMajorAxis <= 500) {\n    //     return hostStar.radius + 75 + (semiMajorAxis / 10)\n\n    // }else if (semiMajorAxis > 500){ // big distance = 150~200px rad\n    //     return (((semiMajorAxis / 1000 )+ 0.3) * 200) // ok this is just some made up stuff here but uh... tis the best i can do right now. \n    // }\n  }\n  angularVelocity(orbPer) {\n    let velocity = Math.PI * 2 / (orbPer * 50); // equates to radians per frame, ie the amount the planet must move per frame.\n    if (velocity < 0.01) {\n      velocity = (Math.random() * (1.0 - 0.5) + 0.5) * 0.01;\n    } else if (velocity > 0.1) {\n      velocity = (Math.random() * (1.0 - 0.5) + 0.5) * 0.1;\n    }\n    return velocity;\n  }\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    if (this.highlighted) {\n      let radConversion = Math.PI / 180;\n      let degStart = 10;\n      let degEnd = 80;\n      for (let i = 0; i < 4; i++) {\n        ctx.beginPath();\n        ctx.arc(this.pos.x, this.pos.y, this.radius + 10, degStart * radConversion, degEnd * radConversion);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"white\";\n        ctx.stroke();\n        degStart += 90;\n        degEnd += 90;\n      }\n    }\n  }\n  move() {\n    this.angle += this.vel; // add this many radians to the current angle.\n    this.pos.x = this.hostStar.pos.x + this.distance * Math.cos(this.angle);\n    this.pos.y = this.hostStar.pos.y + this.distance * Math.sin(this.angle);\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Planet);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ2QsUUFBUSxDQUFDYSxHQUFHLENBQUNDLENBQUMsR0FBSSxJQUFJLENBQUNWLFFBQVEsR0FBR0csSUFBSSxDQUFDUSxHQUFHLENBQUMsSUFBSSxDQUFDVCxLQUFLLENBQUU7SUFDekUsSUFBSSxDQUFDTyxHQUFHLENBQUNHLENBQUMsR0FBRyxJQUFJLENBQUNoQixRQUFRLENBQUNhLEdBQUcsQ0FBQ0csQ0FBQyxHQUFJLElBQUksQ0FBQ1osUUFBUSxHQUFHRyxJQUFJLENBQUNVLEdBQUcsQ0FBQyxJQUFJLENBQUNYLEtBQUssQ0FBRTtFQUU3RTtBQUVKO0FBRUEsK0RBQWVULE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvc2NyaXB0cy9wbGFuZXRhcnlPYmouanM/Mjk0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNsYXNzIFBsYW5ldCB7XG4gICAgY29uc3RydWN0b3IgKHBsYW5ldERhdGEsIGhvc3RTdGFyKXtcbiAgICAgICAgdGhpcy5ob3N0U3RhciA9IGhvc3RTdGFyXG4gICAgICAgIHRoaXMubmFtZSA9IHBsYW5ldERhdGFbXCJwbF9uYW1lXCJdXG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5zY2FsZVJhZGl1cyhwbGFuZXREYXRhW1wicGxfcmFkZVwiXSwgaG9zdFN0YXIpXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnNjYWxlRGlzdGFuY2UocGxhbmV0RGF0YVtcInBsX29yYnNtYXhcIl0sIGhvc3RTdGFyKVxuICAgICAgICB0aGlzLmFuZ2xlID0gKE1hdGgucmFuZG9tKCkgKiAoTWF0aC5QSSoyKSkgLy8gcmFuZG9tIHN0YXJ0aW5nIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICAgIHRoaXMuY29sb3IgPSBcInBpbmtcIiAvLyBwbGFuZXREYXRhW1wicGxfaW5zb2xcIl1cbiAgICAgICAgdGhpcy52ZWwgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eShwbGFuZXREYXRhW1wicGxfb3JicGVyXCJdKSAvLyByYWRpYW5zIHBlciBmcmFtZVxuICAgICAgICB0aGlzLnBvcyA9IHsgXCJ4XCIgOiBob3N0U3Rhci5wb3MueCArICh0aGlzLmRpc3RhbmNlICogTWF0aC5jb3ModGhpcy5hbmdsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgXCJ5XCIgOiBob3N0U3Rhci5wb3MueSArICh0aGlzLmRpc3RhbmNlICogTWF0aC5zaW4odGhpcy5hbmdsZSkpfVxuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5uYW1lLCB0aGlzLnZlbCkgLy8gZm9yIGFkanVzdG1lbnRcbiAgICB9XG5cbiAgICAvLyBzY2FsZUNvbG9yKHRlbXApe1xuICAgIC8vICAgICBpZiAodGVtcCA+IDE4MCAmJiB0ZW1wIDwgMjgwKXtcbiAgICAvLyAgICAgICAgIHJldHVybiBcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIHNjYWxlUmFkaXVzKHJhZGl1cywgaG9zdFN0YXIpIHtcblxuICAgICAgICBpZiAocmFkaXVzID4gMTApe1xuICAgICAgICAgICAgbGV0IGNvbnZlcnNpb24gPSBob3N0U3Rhci5yYWRpdXMgKiAwLjAxXG4gICAgICAgICAgICBsZXQgc2NhbGVkID0gcmFkaXVzICogY29udmVyc2lvblxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlZFxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmFkaXVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzY2FsZURpc3RhbmNlKHNlbWlNYWpvckF4aXMsIGhvc3RTdGFyKSB7Ly8gaWYgc21heCBpcyBudWxsLi4uIGdpdmUgaXQgYSBkZWZhdWx0IHZhbHVlIHBscy5cbiAgICAgICAgc2VtaU1ham9yQXhpcyA/Pz0gMTBcblxuICAgICAgICByZXR1cm4gaG9zdFN0YXIucmFkaXVzICsgKHNlbWlNYWpvckF4aXMgKiAyMClcbiAgICAgICAgLy8gaWYgKHNlbWlNYWpvckF4aXMgPD0gNSl7XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKHNlbWlNYWpvckF4aXMpXG4gICAgICAgIC8vICAgICBsZXQgYWRqdXN0ZWQgPSBob3N0U3Rhci5yYWRpdXMgKyAyNSArICgoc2VtaU1ham9yQXhpcy8xMCkgKiA1MClcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coYWRqdXN0ZWQpXG4gICAgICAgIC8vICAgICByZXR1cm4gYWRqdXN0ZWRcbiAgICAgICAgLy8gfWVsc2UgaWYgKHNlbWlNYWpvckF4aXMgPiA1ICYmIHNlbWlNYWpvckF4aXMgPCAxMDApIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBob3N0U3Rhci5yYWRpdXMgKyA1MCArICgoc2VtaU1ham9yQXhpcyAvIDEwMCkgKiA1MClcblxuICAgICAgICAvLyB9ZWxzZSBpZiAoc2VtaU1ham9yQXhpcyA+PSAxMDAgJiYgc2VtaU1ham9yQXhpcyA8PSA1MDApIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBob3N0U3Rhci5yYWRpdXMgKyA3NSArIChzZW1pTWFqb3JBeGlzIC8gMTApXG5cbiAgICAgICAgLy8gfWVsc2UgaWYgKHNlbWlNYWpvckF4aXMgPiA1MDApeyAvLyBiaWcgZGlzdGFuY2UgPSAxNTB+MjAwcHggcmFkXG4gICAgICAgIC8vICAgICByZXR1cm4gKCgoc2VtaU1ham9yQXhpcyAvIDEwMDAgKSsgMC4zKSAqIDIwMCkgLy8gb2sgdGhpcyBpcyBqdXN0IHNvbWUgbWFkZSB1cCBzdHVmZiBoZXJlIGJ1dCB1aC4uLiB0aXMgdGhlIGJlc3QgaSBjYW4gZG8gcmlnaHQgbm93LiBcbiAgICAgICAgLy8gfVxuICAgIH1cblxuXG4gICAgYW5ndWxhclZlbG9jaXR5IChvcmJQZXIpe1xuICAgICAgICBsZXQgdmVsb2NpdHkgPSAoKE1hdGguUEkgKiAyKSAvIChvcmJQZXIgKiA1MCkpIC8vIGVxdWF0ZXMgdG8gcmFkaWFucyBwZXIgZnJhbWUsIGllIHRoZSBhbW91bnQgdGhlIHBsYW5ldCBtdXN0IG1vdmUgcGVyIGZyYW1lLlxuICAgICAgICBpZiAodmVsb2NpdHkgPCAwLjAxKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IChNYXRoLnJhbmRvbSgpICogKDEuMCAtIDAuNSkgKyAwLjUpICogMC4wMVxuICAgICAgICB9ZWxzZSBpZiAodmVsb2NpdHkgPiAwLjEpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gKE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gMC41KSArIDAuNSkgKiAwLjFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVsb2NpdHkgXG4gICAgfVxuXG4gICAgZHJhdyhjdHgpe1xuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LmFyYyh0aGlzLnBvcy54LCB0aGlzLnBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGN0eC5maWxsKCkgXG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKXtcbiAgICAgICAgICAgIGxldCByYWRDb252ZXJzaW9uID0gTWF0aC5QSSAvIDE4MFxuICAgICAgICAgICAgbGV0IGRlZ1N0YXJ0ID0gMTBcbiAgICAgICAgICAgIGxldCBkZWdFbmQgPSA4MFxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh0aGlzLnBvcy54LCB0aGlzLnBvcy55LCB0aGlzLnJhZGl1cyArIDEwLCBkZWdTdGFydCpyYWRDb252ZXJzaW9uLCBkZWdFbmQqcmFkQ29udmVyc2lvbilcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMlxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKSAgXG5cbiAgICAgICAgICAgICAgICBkZWdTdGFydCArPSA5MFxuICAgICAgICAgICAgICAgIGRlZ0VuZCArPSA5MFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gXG5cbiAgICB9XG5cbiAgICBtb3ZlKCl7ICAgIFxuICAgICAgICB0aGlzLmFuZ2xlICs9IHRoaXMudmVsIC8vIGFkZCB0aGlzIG1hbnkgcmFkaWFucyB0byB0aGUgY3VycmVudCBhbmdsZS5cbiAgICAgICAgdGhpcy5wb3MueCA9IHRoaXMuaG9zdFN0YXIucG9zLnggKyAodGhpcy5kaXN0YW5jZSAqIE1hdGguY29zKHRoaXMuYW5nbGUpKVxuICAgICAgICB0aGlzLnBvcy55ID0gdGhpcy5ob3N0U3Rhci5wb3MueSArICh0aGlzLmRpc3RhbmNlICogTWF0aC5zaW4odGhpcy5hbmdsZSkpXG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxhbmV0OyJdLCJuYW1lcyI6WyJQbGFuZXQiLCJjb25zdHJ1Y3RvciIsInBsYW5ldERhdGEiLCJob3N0U3RhciIsIm5hbWUiLCJyYWRpdXMiLCJzY2FsZVJhZGl1cyIsImRpc3RhbmNlIiwic2NhbGVEaXN0YW5jZSIsImFuZ2xlIiwiTWF0aCIsInJhbmRvbSIsIlBJIiwiY29sb3IiLCJ2ZWwiLCJhbmd1bGFyVmVsb2NpdHkiLCJwb3MiLCJ4IiwiY29zIiwieSIsInNpbiIsImhpZ2hsaWdodGVkIiwiY29udmVyc2lvbiIsInNjYWxlZCIsInNlbWlNYWpvckF4aXMiLCJvcmJQZXIiLCJ2ZWxvY2l0eSIsImRyYXciLCJjdHgiLCJiZWdpblBhdGgiLCJhcmMiLCJmaWxsU3R5bGUiLCJmaWxsIiwicmFkQ29udmVyc2lvbiIsImRlZ1N0YXJ0IiwiZGVnRW5kIiwiaSIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwic3Ryb2tlIiwibW92ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/planetaryObj.js\n");

/***/ }),

/***/ "./src/scripts/starChart.js":
/*!**********************************!*\
  !*** ./src/scripts/starChart.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeStarChart: function() { return /* binding */ closeStarChart; },\n/* harmony export */   populateStarChart: function() { return /* binding */ populateStarChart; },\n/* harmony export */   renderStarChart: function() { return /* binding */ renderStarChart; }\n/* harmony export */ });\n/* harmony import */ var _stellarObj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stellarObj */ \"./src/scripts/stellarObj.js\");\n\nfunction populateStarChart(starSystem) {\n  let star = starSystem[0];\n  //how should i go about this....? programatically create field names? it would be weird to iterate through and put like 17 different conditions... \n  // i could also just manually create field names in the html, then grab each name and append the data values to it. \n  let name = document.querySelector(\".host-star\");\n  name.innerText = star.hostname;\n  let spectype = document.querySelector(\".spectype\");\n  //alright get ready for some crazy stuff...\n  if (star.st_spectype) {\n    spectype.innerText = star.st_spectype;\n  } else {\n    // if data is not provided for spectral type, create a dummy star and obtain its general class.\n    let dummy = new _stellarObj__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, starSystem);\n    spectype.innerText = dummy.class;\n  }\n  let temp = document.querySelector(\".stemp\");\n  temp.innerText = `${star.st_teff} K`;\n  let mass = document.querySelector(\".smass\");\n  mass.innerText = `${star.st_mass} x solar mass`;\n  let radius = document.querySelector(\".sradius\");\n  radius.innerText = `${star.st_rad} x solar radius`;\n  let metallicity = document.querySelector(\".metallicity\");\n  metallicity.innerText = `${star.st_met} ${star.st_metratio}`;\n  let luminosity = document.querySelector(\".luminosity\");\n  luminosity.innerText = `${star.st_lum} x solar luminosity\n`;\n  let pos = document.querySelector(\".coordinates\");\n  pos.innerText = `RA: ${star.rastr}, DEC: ${star.decstr}`;\n  let distance = document.querySelector(\".distance\");\n  distance.innerText = `${star.sy_dist} parsecs`;\n}\nfunction renderStarChart() {\n  let starCard = document.querySelector(\".star-card\");\n  //populateStarChart(star);\n  starCard.style.visibility = \"visible\";\n}\nfunction closeStarChart() {\n  let starCard = document.querySelector(\".star-card\"); // a way to dry this all up? :/ may not be able to since i'm exporting these functions\n  starCard.style.visibility = \"hidden\";\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9zdGFyQ2hhcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUV4QixTQUFTQyxpQkFBaUJBLENBQUNDLFVBQVUsRUFBRTtFQUMxQyxJQUFJQyxJQUFJLEdBQUdELFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFDeEI7RUFDQTtFQUNBLElBQUlFLElBQUksR0FBR0MsUUFBUSxDQUFDQyxhQUFhLENBQUMsWUFBWSxDQUFDO0VBQy9DRixJQUFJLENBQUNHLFNBQVMsR0FBR0osSUFBSSxDQUFDSyxRQUFRO0VBRTlCLElBQUlDLFFBQVEsR0FBR0osUUFBUSxDQUFDQyxhQUFhLENBQUMsV0FBVyxDQUFDO0VBQ2xEO0VBQ0EsSUFBSUgsSUFBSSxDQUFDTyxXQUFXLEVBQUM7SUFDakJELFFBQVEsQ0FBQ0YsU0FBUyxHQUFHSixJQUFJLENBQUNPLFdBQVc7RUFDekMsQ0FBQyxNQUFLO0lBQUU7SUFDSixJQUFJQyxLQUFLLEdBQUcsSUFBSVgsbURBQUksQ0FBQyxDQUFDLEVBQUVFLFVBQVUsQ0FBQztJQUNuQ08sUUFBUSxDQUFDRixTQUFTLEdBQUdJLEtBQUssQ0FBQ0MsS0FBSztFQUNwQztFQUVBLElBQUlDLElBQUksR0FBR1IsUUFBUSxDQUFDQyxhQUFhLENBQUMsUUFBUSxDQUFDO0VBQzNDTyxJQUFJLENBQUNOLFNBQVMsR0FBSSxHQUFFSixJQUFJLENBQUNXLE9BQVEsSUFBRztFQUVwQyxJQUFJQyxJQUFJLEdBQUdWLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLFFBQVEsQ0FBQztFQUMzQ1MsSUFBSSxDQUFDUixTQUFTLEdBQUksR0FBRUosSUFBSSxDQUFDYSxPQUFRLGVBQWM7RUFFL0MsSUFBSUMsTUFBTSxHQUFHWixRQUFRLENBQUNDLGFBQWEsQ0FBQyxVQUFVLENBQUM7RUFDL0NXLE1BQU0sQ0FBQ1YsU0FBUyxHQUFJLEdBQUVKLElBQUksQ0FBQ2UsTUFBTyxpQkFBZ0I7RUFFbEQsSUFBSUMsV0FBVyxHQUFHZCxRQUFRLENBQUNDLGFBQWEsQ0FBQyxjQUFjLENBQUM7RUFDeERhLFdBQVcsQ0FBQ1osU0FBUyxHQUFJLEdBQUVKLElBQUksQ0FBQ2lCLE1BQU8sSUFBR2pCLElBQUksQ0FBQ2tCLFdBQVksRUFBQztFQUU1RCxJQUFJQyxVQUFVLEdBQUdqQixRQUFRLENBQUNDLGFBQWEsQ0FBQyxhQUFhLENBQUM7RUFDdERnQixVQUFVLENBQUNmLFNBQVMsR0FBSSxHQUFFSixJQUFJLENBQUNvQixNQUFPO0FBQzFDLENBQUM7RUFDRyxJQUFJQyxHQUFHLEdBQUduQixRQUFRLENBQUNDLGFBQWEsQ0FBQyxjQUFjLENBQUM7RUFDaERrQixHQUFHLENBQUNqQixTQUFTLEdBQUksT0FBTUosSUFBSSxDQUFDc0IsS0FBTSxVQUFTdEIsSUFBSSxDQUFDdUIsTUFBTyxFQUFDO0VBRXhELElBQUlDLFFBQVEsR0FBR3RCLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLFdBQVcsQ0FBQztFQUNsRHFCLFFBQVEsQ0FBQ3BCLFNBQVMsR0FBSSxHQUFFSixJQUFJLENBQUN5QixPQUFRLFVBQVM7QUFDbEQ7QUFFTyxTQUFTQyxlQUFlQSxDQUFBLEVBQUc7RUFDOUIsSUFBSUMsUUFBUSxHQUFHekIsUUFBUSxDQUFDQyxhQUFhLENBQUMsWUFBWSxDQUFDO0VBQ25EO0VBQ0F3QixRQUFRLENBQUNDLEtBQUssQ0FBQ0MsVUFBVSxHQUFHLFNBQVM7QUFDekM7QUFFTyxTQUFTQyxjQUFjQSxDQUFBLEVBQUc7RUFDN0IsSUFBSUgsUUFBUSxHQUFHekIsUUFBUSxDQUFDQyxhQUFhLENBQUMsWUFBWSxDQUFDLEVBQUM7RUFDcER3QixRQUFRLENBQUNDLEtBQUssQ0FBQ0MsVUFBVSxHQUFHLFFBQVE7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvc2NyaXB0cy9zdGFyQ2hhcnQuanM/OGY4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RhciBmcm9tIFwiLi9zdGVsbGFyT2JqXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlU3RhckNoYXJ0KHN0YXJTeXN0ZW0pIHtcbiAgICBsZXQgc3RhciA9IHN0YXJTeXN0ZW1bMF1cbiAgICAvL2hvdyBzaG91bGQgaSBnbyBhYm91dCB0aGlzLi4uLj8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBmaWVsZCBuYW1lcz8gaXQgd291bGQgYmUgd2VpcmQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFuZCBwdXQgbGlrZSAxNyBkaWZmZXJlbnQgY29uZGl0aW9ucy4uLiBcbiAgICAvLyBpIGNvdWxkIGFsc28ganVzdCBtYW51YWxseSBjcmVhdGUgZmllbGQgbmFtZXMgaW4gdGhlIGh0bWwsIHRoZW4gZ3JhYiBlYWNoIG5hbWUgYW5kIGFwcGVuZCB0aGUgZGF0YSB2YWx1ZXMgdG8gaXQuIFxuICAgIGxldCBuYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5ob3N0LXN0YXJcIilcbiAgICBuYW1lLmlubmVyVGV4dCA9IHN0YXIuaG9zdG5hbWVcblxuICAgIGxldCBzcGVjdHlwZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc3BlY3R5cGVcIilcbiAgICAvL2FscmlnaHQgZ2V0IHJlYWR5IGZvciBzb21lIGNyYXp5IHN0dWZmLi4uXG4gICAgaWYgKHN0YXIuc3Rfc3BlY3R5cGUpe1xuICAgICAgICBzcGVjdHlwZS5pbm5lclRleHQgPSBzdGFyLnN0X3NwZWN0eXBlXG4gICAgfWVsc2UgeyAvLyBpZiBkYXRhIGlzIG5vdCBwcm92aWRlZCBmb3Igc3BlY3RyYWwgdHlwZSwgY3JlYXRlIGEgZHVtbXkgc3RhciBhbmQgb2J0YWluIGl0cyBnZW5lcmFsIGNsYXNzLlxuICAgICAgICBsZXQgZHVtbXkgPSBuZXcgU3RhcigwLCBzdGFyU3lzdGVtKVxuICAgICAgICBzcGVjdHlwZS5pbm5lclRleHQgPSBkdW1teS5jbGFzc1xuICAgIH1cblxuICAgIGxldCB0ZW1wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zdGVtcFwiKVxuICAgIHRlbXAuaW5uZXJUZXh0ID0gYCR7c3Rhci5zdF90ZWZmfSBLYFxuXG4gICAgbGV0IG1hc3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNtYXNzXCIpXG4gICAgbWFzcy5pbm5lclRleHQgPSBgJHtzdGFyLnN0X21hc3N9IHggc29sYXIgbWFzc2BcblxuICAgIGxldCByYWRpdXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNyYWRpdXNcIilcbiAgICByYWRpdXMuaW5uZXJUZXh0ID0gYCR7c3Rhci5zdF9yYWR9IHggc29sYXIgcmFkaXVzYFxuXG4gICAgbGV0IG1ldGFsbGljaXR5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tZXRhbGxpY2l0eVwiKVxuICAgIG1ldGFsbGljaXR5LmlubmVyVGV4dCA9IGAke3N0YXIuc3RfbWV0fSAke3N0YXIuc3RfbWV0cmF0aW99YFxuXG4gICAgbGV0IGx1bWlub3NpdHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmx1bWlub3NpdHlcIilcbiAgICBsdW1pbm9zaXR5LmlubmVyVGV4dCA9IGAke3N0YXIuc3RfbHVtfSB4IHNvbGFyIGx1bWlub3NpdHlcbmBcbiAgICBsZXQgcG9zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jb29yZGluYXRlc1wiKVxuICAgIHBvcy5pbm5lclRleHQgPSBgUkE6ICR7c3Rhci5yYXN0cn0sIERFQzogJHtzdGFyLmRlY3N0cn1gXG5cbiAgICBsZXQgZGlzdGFuY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRpc3RhbmNlXCIpXG4gICAgZGlzdGFuY2UuaW5uZXJUZXh0ID0gYCR7c3Rhci5zeV9kaXN0fSBwYXJzZWNzYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3RhckNoYXJ0KCkge1xuICAgIGxldCBzdGFyQ2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc3Rhci1jYXJkXCIpXG4gICAgLy9wb3B1bGF0ZVN0YXJDaGFydChzdGFyKTtcbiAgICBzdGFyQ2FyZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVN0YXJDaGFydCgpIHtcbiAgICBsZXQgc3RhckNhcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnN0YXItY2FyZFwiKSAvLyBhIHdheSB0byBkcnkgdGhpcyBhbGwgdXA/IDovIG1heSBub3QgYmUgYWJsZSB0byBzaW5jZSBpJ20gZXhwb3J0aW5nIHRoZXNlIGZ1bmN0aW9uc1xuICAgIHN0YXJDYXJkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xufVxuXG4iXSwibmFtZXMiOlsiU3RhciIsInBvcHVsYXRlU3RhckNoYXJ0Iiwic3RhclN5c3RlbSIsInN0YXIiLCJuYW1lIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaW5uZXJUZXh0IiwiaG9zdG5hbWUiLCJzcGVjdHlwZSIsInN0X3NwZWN0eXBlIiwiZHVtbXkiLCJjbGFzcyIsInRlbXAiLCJzdF90ZWZmIiwibWFzcyIsInN0X21hc3MiLCJyYWRpdXMiLCJzdF9yYWQiLCJtZXRhbGxpY2l0eSIsInN0X21ldCIsInN0X21ldHJhdGlvIiwibHVtaW5vc2l0eSIsInN0X2x1bSIsInBvcyIsInJhc3RyIiwiZGVjc3RyIiwiZGlzdGFuY2UiLCJzeV9kaXN0IiwicmVuZGVyU3RhckNoYXJ0Iiwic3RhckNhcmQiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJjbG9zZVN0YXJDaGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/starChart.js\n");

/***/ }),

/***/ "./src/scripts/stellarObj.js":
/*!***********************************!*\
  !*** ./src/scripts/stellarObj.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _planetaryObj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planetaryObj */ \"./src/scripts/planetaryObj.js\");\n\nclass Star {\n  constructor(canvas, starSystem) {\n    if (canvas) {\n      // if there *is* a canvas passed in, do full construction.\n      this.pos = {\n        \"x\": canvas.width / 2,\n        \"y\": canvas.height / 2\n      };\n      this.class = this.setStellarClass(starSystem[0]);\n      this.radius = this.scaleRadius(starSystem[0][\"st_rad\"]); // given stellar radius in units of radius of the sun, scale to num pixels\n      this.planets = [];\n      this.color = this.scaleColorByTemperature(starSystem[0][\"st_teff\"]);\n      this.addPlanets(starSystem);\n      //console.log(this.radius)\n    } else {\n      // if no canvas, or canvas is 0, just initialize the class.\n      this.class = this.setStellarClass(starSystem[0]);\n    }\n  }\n  setStellarClass(system) {\n    if (system[\"st_spectype\"]) {\n      // some entries have null for spectral type.\n      return system[\"st_spectype\"];\n    } else {\n      // so i have to approximate my own.\n      let kelvin = system[\"st_teff\"];\n      if (kelvin > 30000) {\n        return 'O';\n      } else if (kelvin < 30000 && kelvin > 9700) {\n        return 'B';\n      } else if (kelvin < 9700 && kelvin > 7200) {\n        return 'A';\n      } else if (kelvin < 7200 && kelvin > 5700) {\n        return 'F';\n      } else if (kelvin < 5700 && kelvin > 4900) {\n        return 'G';\n      } else if (kelvin < 4900 && kelvin > 3400) {\n        return 'K';\n      } else if (kelvin < 3400 && kelvin > 2100) {\n        return 'M';\n      }\n    }\n  }\n  scaleColorByTemperature(kelvin) {\n    let r, g, b;\n    if (kelvin > 11000) {\n      // blue\n      r = 222;\n      g = 244;\n      b = 255;\n    } else if (kelvin > 8000 && kelvin < 11000) {\n      //white\n      r = 255;\n      g = 255;\n      b = kelvin / 45;\n    } else if (kelvin > 5000 && kelvin < 8000) {\n      //yellow\n      r = 255;\n      g = kelvin / 30;\n      b = 0;\n    } else if (kelvin > 3500 && kelvin < 5000) {\n      // orange\n      r = 255;\n      g = kelvin / 200;\n      b = 0;\n    } else {\n      // < 3500 k\n      r = 215;\n      g = kelvin / 100;\n      b = 0;\n    }\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n  scaleRadius(radius) {\n    let km = radius * 695700;\n    let scaled = km * 0.00005;\n    if (scaled >= 200) {\n      return scaled * (Math.random() * (1.5 - 1.0) + 1.0);\n    } else if (scaled < 50) {\n      scaled = scaled * (Math.random() * (2.0 - 1.5) + 1.5);\n      console.log(`resized: ${scaled}`);\n      return scaled;\n    } else {\n      return scaled;\n    }\n  }\n  addPlanets(starSystem) {\n    starSystem.forEach(planetData => {\n      let planet = new _planetaryObj__WEBPACK_IMPORTED_MODULE_0__[\"default\"](planetData, this);\n      this.planets.push(planet);\n    });\n  }\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    ctx.shadowColor = this.color;\n    ctx.shadowBlur = 5;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Star);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9zdGVsbGFyT2JqLmpzIiwibWFwcGluZ3MiOiI7O0FBQ21DO0FBRW5DLE1BQU1DLElBQUksQ0FBQztFQUNQQyxXQUFXQSxDQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBQztJQUM1QixJQUFJRCxNQUFNLEVBQUM7TUFBRTtNQUNiLElBQUksQ0FBQ0UsR0FBRyxHQUFHO1FBQUUsR0FBRyxFQUFHRixNQUFNLENBQUNHLEtBQUssR0FBRyxDQUFDO1FBQ3RCLEdBQUcsRUFBR0gsTUFBTSxDQUFDSSxNQUFNLEdBQUc7TUFBQyxDQUFDO01BQ3JDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0MsZUFBZSxDQUFDTCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDaEQsSUFBSSxDQUFDTSxNQUFNLEdBQUcsSUFBSSxDQUFDQyxXQUFXLENBQUNQLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDO01BQ3hELElBQUksQ0FBQ1EsT0FBTyxHQUFHLEVBQUU7TUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQ1YsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO01BQ25FLElBQUksQ0FBQ1csVUFBVSxDQUFDWCxVQUFVLENBQUM7TUFDM0I7SUFDQSxDQUFDLE1BQUs7TUFBRTtNQUNKLElBQUksQ0FBQ0ksS0FBSyxHQUFHLElBQUksQ0FBQ0MsZUFBZSxDQUFDTCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEQ7RUFFSjtFQUNBSyxlQUFlQSxDQUFDTyxNQUFNLEVBQUM7SUFDbkIsSUFBSUEsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFDO01BQUU7TUFDeEIsT0FBT0EsTUFBTSxDQUFDLGFBQWEsQ0FBQztJQUNoQyxDQUFDLE1BQUk7TUFBRTtNQUNILElBQUlDLE1BQU0sR0FBR0QsTUFBTSxDQUFDLFNBQVMsQ0FBQztNQUU5QixJQUFJQyxNQUFNLEdBQUcsS0FBSyxFQUFDO1FBQ2YsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxLQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUM7UUFDdEMsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUM7UUFDckMsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUM7UUFDckMsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUM7UUFDckMsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUM7UUFDckMsT0FBTyxHQUFHO01BQ2QsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUU7UUFDdEMsT0FBTyxHQUFHO01BQ2Q7SUFDSjtFQUNKO0VBRUFILHVCQUF1QkEsQ0FBQ0csTUFBTSxFQUFDO0lBQzNCLElBQUlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ1gsSUFBSUgsTUFBTSxHQUFHLEtBQUssRUFBRTtNQUFFO01BQ2xCQyxDQUFDLEdBQUcsR0FBRztNQUNQQyxDQUFDLEdBQUcsR0FBRztNQUNQQyxDQUFDLEdBQUcsR0FBRztJQUNYLENBQUMsTUFBSyxJQUFJSCxNQUFNLEdBQUcsSUFBSSxJQUFJQSxNQUFNLEdBQUcsS0FBSyxFQUFFO01BQUU7TUFDekNDLENBQUMsR0FBRyxHQUFHO01BQ1BDLENBQUMsR0FBRyxHQUFHO01BQ1BDLENBQUMsR0FBR0gsTUFBTSxHQUFHLEVBQUU7SUFDbkIsQ0FBQyxNQUFLLElBQUlBLE1BQU0sR0FBRyxJQUFJLElBQUlBLE1BQU0sR0FBRyxJQUFJLEVBQUU7TUFBRTtNQUN4Q0MsQ0FBQyxHQUFHLEdBQUc7TUFDUEMsQ0FBQyxHQUFHRixNQUFNLEdBQUcsRUFBRTtNQUNmRyxDQUFDLEdBQUcsQ0FBQztJQUNULENBQUMsTUFBSyxJQUFJSCxNQUFNLEdBQUcsSUFBSSxJQUFJQSxNQUFNLEdBQUcsSUFBSSxFQUFFO01BQUU7TUFDeENDLENBQUMsR0FBRyxHQUFHO01BQ1BDLENBQUMsR0FBR0YsTUFBTSxHQUFHLEdBQUc7TUFDaEJHLENBQUMsR0FBRyxDQUFDO0lBQ1QsQ0FBQyxNQUFLO01BQUU7TUFDSkYsQ0FBQyxHQUFHLEdBQUc7TUFDUEMsQ0FBQyxHQUFHRixNQUFNLEdBQUMsR0FBRztNQUNkRyxDQUFDLEdBQUcsQ0FBQztJQUNUO0lBRUEsT0FBUSxPQUFNRixDQUFFLEtBQUlDLENBQUUsS0FBSUMsQ0FBRSxHQUFFO0VBQ2xDO0VBRUFULFdBQVdBLENBQUNELE1BQU0sRUFBQztJQUNmLElBQUlXLEVBQUUsR0FBR1gsTUFBTSxHQUFHLE1BQU07SUFDeEIsSUFBSVksTUFBTSxHQUFHRCxFQUFFLEdBQUcsT0FBTztJQUV6QixJQUFJQyxNQUFNLElBQUksR0FBRyxFQUFFO01BQ2YsT0FBT0EsTUFBTSxJQUFJQyxJQUFJLENBQUNDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUN2RCxDQUFDLE1BQUssSUFBS0YsTUFBTSxHQUFHLEVBQUUsRUFBRTtNQUNwQkEsTUFBTSxHQUFHQSxNQUFNLElBQUlDLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO01BQ3JEQyxPQUFPLENBQUNDLEdBQUcsQ0FBRSxZQUFXSixNQUFPLEVBQUMsQ0FBQztNQUNqQyxPQUFPQSxNQUFNO0lBQ2pCLENBQUMsTUFBSTtNQUNELE9BQU9BLE1BQU07SUFDakI7RUFDSjtFQUVBUCxVQUFVQSxDQUFDWCxVQUFVLEVBQUM7SUFDbEJBLFVBQVUsQ0FBQ3VCLE9BQU8sQ0FBR0MsVUFBVSxJQUFLO01BQ2hDLElBQUlDLE1BQU0sR0FBRyxJQUFJN0IscURBQU0sQ0FBQzRCLFVBQVUsRUFBRSxJQUFJLENBQUM7TUFDekMsSUFBSSxDQUFDaEIsT0FBTyxDQUFDa0IsSUFBSSxDQUFDRCxNQUFNLENBQUM7SUFDN0IsQ0FBQyxDQUFDO0VBQ047RUFHQUUsSUFBSUEsQ0FBQ0MsR0FBRyxFQUFDO0lBQ0xBLEdBQUcsQ0FBQ0MsU0FBUyxDQUFDLENBQUM7SUFDZkQsR0FBRyxDQUFDRSxHQUFHLENBQUMsSUFBSSxDQUFDN0IsR0FBRyxDQUFDOEIsQ0FBQyxFQUFDLElBQUksQ0FBQzlCLEdBQUcsQ0FBQytCLENBQUMsRUFBRSxJQUFJLENBQUMxQixNQUFNLEVBQUUsQ0FBQyxFQUFFYSxJQUFJLENBQUNjLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDM0RMLEdBQUcsQ0FBQ00sU0FBUyxHQUFHLElBQUksQ0FBQ3pCLEtBQUs7SUFDMUJtQixHQUFHLENBQUNPLElBQUksQ0FBQyxDQUFDO0lBQ1ZQLEdBQUcsQ0FBQ1EsV0FBVyxHQUFHLElBQUksQ0FBQzNCLEtBQUs7SUFDNUJtQixHQUFHLENBQUNTLFVBQVUsR0FBRyxDQUFDO0VBQ3RCO0FBRUo7QUFFQSwrREFBZXhDLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvc2NyaXB0cy9zdGVsbGFyT2JqLmpzP2MxNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgUGxhbmV0IGZyb20gXCIuL3BsYW5ldGFyeU9ialwiXG5cbmNsYXNzIFN0YXIge1xuICAgIGNvbnN0cnVjdG9yIChjYW52YXMsIHN0YXJTeXN0ZW0pe1xuICAgICAgICBpZiAoY2FudmFzKXsgLy8gaWYgdGhlcmUgKmlzKiBhIGNhbnZhcyBwYXNzZWQgaW4sIGRvIGZ1bGwgY29uc3RydWN0aW9uLlxuICAgICAgICB0aGlzLnBvcyA9IHsgXCJ4XCIgOiBjYW52YXMud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICAgXCJ5XCIgOiBjYW52YXMuaGVpZ2h0IC8gMn1cbiAgICAgICAgdGhpcy5jbGFzcyA9IHRoaXMuc2V0U3RlbGxhckNsYXNzKHN0YXJTeXN0ZW1bMF0pXG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5zY2FsZVJhZGl1cyhzdGFyU3lzdGVtWzBdW1wic3RfcmFkXCJdKSAvLyBnaXZlbiBzdGVsbGFyIHJhZGl1cyBpbiB1bml0cyBvZiByYWRpdXMgb2YgdGhlIHN1biwgc2NhbGUgdG8gbnVtIHBpeGVsc1xuICAgICAgICB0aGlzLnBsYW5ldHMgPSBbXVxuICAgICAgICB0aGlzLmNvbG9yID0gdGhpcy5zY2FsZUNvbG9yQnlUZW1wZXJhdHVyZShzdGFyU3lzdGVtWzBdW1wic3RfdGVmZlwiXSlcbiAgICAgICAgdGhpcy5hZGRQbGFuZXRzKHN0YXJTeXN0ZW0pXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5yYWRpdXMpXG4gICAgICAgIH1lbHNlIHsgLy8gaWYgbm8gY2FudmFzLCBvciBjYW52YXMgaXMgMCwganVzdCBpbml0aWFsaXplIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLnNldFN0ZWxsYXJDbGFzcyhzdGFyU3lzdGVtWzBdKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICBzZXRTdGVsbGFyQ2xhc3Moc3lzdGVtKXtcbiAgICAgICAgaWYgKHN5c3RlbVtcInN0X3NwZWN0eXBlXCJdKXsgLy8gc29tZSBlbnRyaWVzIGhhdmUgbnVsbCBmb3Igc3BlY3RyYWwgdHlwZS5cbiAgICAgICAgICAgIHJldHVybiBzeXN0ZW1bXCJzdF9zcGVjdHlwZVwiXVxuICAgICAgICB9ZWxzZXsgLy8gc28gaSBoYXZlIHRvIGFwcHJveGltYXRlIG15IG93bi5cbiAgICAgICAgICAgIGxldCBrZWx2aW4gPSBzeXN0ZW1bXCJzdF90ZWZmXCJdXG5cbiAgICAgICAgICAgIGlmIChrZWx2aW4gPiAzMDAwMCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPJ1xuICAgICAgICAgICAgfWVsc2UgaWYgKGtlbHZpbiA8IDMwMDAwICYmIGtlbHZpbiA+IDk3MDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAnQidcbiAgICAgICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPCA5NzAwICYmIGtlbHZpbiA+IDcyMDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAnQSdcbiAgICAgICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPCA3MjAwICYmIGtlbHZpbiA+IDU3MDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAnRidcbiAgICAgICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPCA1NzAwICYmIGtlbHZpbiA+IDQ5MDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAnRydcbiAgICAgICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPCA0OTAwICYmIGtlbHZpbiA+IDM0MDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAnSydcbiAgICAgICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPCAzNDAwICYmIGtlbHZpbiA+IDIxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ00nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzY2FsZUNvbG9yQnlUZW1wZXJhdHVyZShrZWx2aW4pe1xuICAgICAgICBsZXQgciwgZywgYjtcbiAgICAgICAgaWYgKGtlbHZpbiA+IDExMDAwKSB7IC8vIGJsdWVcbiAgICAgICAgICAgIHIgPSAyMjJcbiAgICAgICAgICAgIGcgPSAyNDRcbiAgICAgICAgICAgIGIgPSAyNTVcbiAgICAgICAgfWVsc2UgaWYgKGtlbHZpbiA+IDgwMDAgJiYga2VsdmluIDwgMTEwMDApIHsgLy93aGl0ZVxuICAgICAgICAgICAgciA9IDI1NVxuICAgICAgICAgICAgZyA9IDI1NVxuICAgICAgICAgICAgYiA9IGtlbHZpbiAvIDQ1XG4gICAgICAgIH1lbHNlIGlmIChrZWx2aW4gPiA1MDAwICYmIGtlbHZpbiA8IDgwMDApIHsgLy95ZWxsb3dcbiAgICAgICAgICAgIHIgPSAyNTVcbiAgICAgICAgICAgIGcgPSBrZWx2aW4gLyAzMFxuICAgICAgICAgICAgYiA9IDBcbiAgICAgICAgfWVsc2UgaWYgKGtlbHZpbiA+IDM1MDAgJiYga2VsdmluIDwgNTAwMCkgeyAvLyBvcmFuZ2VcbiAgICAgICAgICAgIHIgPSAyNTVcbiAgICAgICAgICAgIGcgPSBrZWx2aW4gLyAyMDBcbiAgICAgICAgICAgIGIgPSAwXG4gICAgICAgIH1lbHNlIHsgLy8gPCAzNTAwIGtcbiAgICAgICAgICAgIHIgPSAyMTVcbiAgICAgICAgICAgIGcgPSBrZWx2aW4vMTAwXG4gICAgICAgICAgICBiID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgXG4gICAgfVxuXG4gICAgc2NhbGVSYWRpdXMocmFkaXVzKXtcbiAgICAgICAgbGV0IGttID0gcmFkaXVzICogNjk1NzAwXG4gICAgICAgIGxldCBzY2FsZWQgPSBrbSAqIDAuMDAwMDVcbiAgICAgICAgXG4gICAgICAgIGlmIChzY2FsZWQgPj0gMjAwICl7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVkICogKE1hdGgucmFuZG9tKCkgKiAoMS41IC0gMS4wKSArIDEuMClcbiAgICAgICAgfWVsc2UgaWYgKCBzY2FsZWQgPCA1MCkge1xuICAgICAgICAgICAgc2NhbGVkID0gc2NhbGVkICogKE1hdGgucmFuZG9tKCkgKiAoMi4wIC0gMS41KSArIDEuNSkgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgcmVzaXplZDogJHtzY2FsZWR9YClcbiAgICAgICAgICAgIHJldHVybiBzY2FsZWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVkXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgYWRkUGxhbmV0cyhzdGFyU3lzdGVtKXtcbiAgICAgICAgc3RhclN5c3RlbS5mb3JFYWNoKCAocGxhbmV0RGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBsYW5ldCA9IG5ldyBQbGFuZXQocGxhbmV0RGF0YSwgdGhpcylcbiAgICAgICAgICAgIHRoaXMucGxhbmV0cy5wdXNoKHBsYW5ldClcbiAgICAgICAgfSlcbiAgICB9XG5cblxuICAgIGRyYXcoY3R4KXtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5hcmModGhpcy5wb3MueCx0aGlzLnBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5jb2xvclxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDVcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RhcjsiXSwibmFtZXMiOlsiUGxhbmV0IiwiU3RhciIsImNvbnN0cnVjdG9yIiwiY2FudmFzIiwic3RhclN5c3RlbSIsInBvcyIsIndpZHRoIiwiaGVpZ2h0IiwiY2xhc3MiLCJzZXRTdGVsbGFyQ2xhc3MiLCJyYWRpdXMiLCJzY2FsZVJhZGl1cyIsInBsYW5ldHMiLCJjb2xvciIsInNjYWxlQ29sb3JCeVRlbXBlcmF0dXJlIiwiYWRkUGxhbmV0cyIsInN5c3RlbSIsImtlbHZpbiIsInIiLCJnIiwiYiIsImttIiwic2NhbGVkIiwiTWF0aCIsInJhbmRvbSIsImNvbnNvbGUiLCJsb2ciLCJmb3JFYWNoIiwicGxhbmV0RGF0YSIsInBsYW5ldCIsInB1c2giLCJkcmF3IiwiY3R4IiwiYmVnaW5QYXRoIiwiYXJjIiwieCIsInkiLCJQSSIsImZpbGxTdHlsZSIsImZpbGwiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scripts/stellarObj.js\n");

/***/ }),

/***/ "./src/scripts/view.js":
/*!*****************************!*\
  !*** ./src/scripts/view.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stellarObj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stellarObj */ \"./src/scripts/stellarObj.js\");\n//import stellar card, planetary card, and planet/star classes.\n//responsible for taking in stellar system data, creating star and planets, and animating. \n//consider not using an actual View, but export this thing as a collection of functions. \n//starting to think it doesn't really make sense to have it be a class with a instance methods.. \n//the background will likely not change from instance to instance.\n\n\nclass View {\n  constructor(starSystem, canvas) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\"2d\");\n    this.starSystem = starSystem;\n    this.hostStar = new _stellarObj__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, starSystem);\n    this.planets = this.hostStar.planets;\n  }\n  animate() {\n    this.draw(this.ctx);\n    this.hostStar.draw(this.ctx);\n    this.planets.forEach(planet => {\n      planet.move();\n      //todo add a conditional during elliptical orbit phase - if distance between planet and host star center is < host star radius, do not draw.\n      planet.draw(this.ctx);\n    });\n  }\n  draw(ctx) {\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (View);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy92aWV3LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFFL0IsTUFBTUMsSUFBSSxDQUFDO0VBRVBDLFdBQVdBLENBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFHO0lBQzlCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQ0MsR0FBRyxHQUFHRCxNQUFNLENBQUNFLFVBQVUsQ0FBQyxJQUFJLENBQUM7SUFDbEMsSUFBSSxDQUFDSCxVQUFVLEdBQUdBLFVBQVU7SUFDNUIsSUFBSSxDQUFDSSxRQUFRLEdBQUcsSUFBSVAsbURBQUksQ0FBQ0ksTUFBTSxFQUFFRCxVQUFVLENBQUM7SUFDNUMsSUFBSSxDQUFDSyxPQUFPLEdBQUcsSUFBSSxDQUFDRCxRQUFRLENBQUNDLE9BQU87RUFDeEM7RUFFQUMsT0FBT0EsQ0FBQSxFQUFJO0lBQ1AsSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDTCxHQUFHLENBQUM7SUFDbkIsSUFBSSxDQUFDRSxRQUFRLENBQUNHLElBQUksQ0FBQyxJQUFJLENBQUNMLEdBQUcsQ0FBQztJQUM1QixJQUFJLENBQUNHLE9BQU8sQ0FBQ0csT0FBTyxDQUFJQyxNQUFNLElBQUs7TUFDL0JBLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLENBQUM7TUFDYjtNQUNBRCxNQUFNLENBQUNGLElBQUksQ0FBQyxJQUFJLENBQUNMLEdBQUcsQ0FBQztJQUN6QixDQUFDLENBQUM7RUFDTjtFQUVBSyxJQUFJQSxDQUFDTCxHQUFHLEVBQUM7SUFDTEEsR0FBRyxDQUFDUyxTQUFTLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxJQUFJLENBQUNWLE1BQU0sQ0FBQ1csS0FBSyxFQUFFLElBQUksQ0FBQ1gsTUFBTSxDQUFDWSxNQUFNLENBQUM7SUFDekRYLEdBQUcsQ0FBQ1ksU0FBUyxHQUFHLE9BQU87SUFDdkJaLEdBQUcsQ0FBQ2EsUUFBUSxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsSUFBSSxDQUFDZCxNQUFNLENBQUNXLEtBQUssRUFBRSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksTUFBTSxDQUFDO0VBQzVEO0FBRUo7QUFFQSwrREFBZWYsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLWV4b3BsYW5ldC1leHBsb3Jlci8uL3NyYy9zY3JpcHRzL3ZpZXcuanM/ODBjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCBzdGVsbGFyIGNhcmQsIHBsYW5ldGFyeSBjYXJkLCBhbmQgcGxhbmV0L3N0YXIgY2xhc3Nlcy5cbi8vcmVzcG9uc2libGUgZm9yIHRha2luZyBpbiBzdGVsbGFyIHN5c3RlbSBkYXRhLCBjcmVhdGluZyBzdGFyIGFuZCBwbGFuZXRzLCBhbmQgYW5pbWF0aW5nLiBcbi8vY29uc2lkZXIgbm90IHVzaW5nIGFuIGFjdHVhbCBWaWV3LCBidXQgZXhwb3J0IHRoaXMgdGhpbmcgYXMgYSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucy4gXG4vL3N0YXJ0aW5nIHRvIHRoaW5rIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gaGF2ZSBpdCBiZSBhIGNsYXNzIHdpdGggYSBpbnN0YW5jZSBtZXRob2RzLi4gXG4vL3RoZSBiYWNrZ3JvdW5kIHdpbGwgbGlrZWx5IG5vdCBjaGFuZ2UgZnJvbSBpbnN0YW5jZSB0byBpbnN0YW5jZS5cblxuaW1wb3J0IFN0YXIgZnJvbSBcIi4vc3RlbGxhck9ialwiXG5cbmNsYXNzIFZpZXcge1xuXG4gICAgY29uc3RydWN0b3IoIHN0YXJTeXN0ZW0sIGNhbnZhcyApIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICAgIHRoaXMuc3RhclN5c3RlbSA9IHN0YXJTeXN0ZW1cbiAgICAgICAgdGhpcy5ob3N0U3RhciA9IG5ldyBTdGFyKGNhbnZhcywgc3RhclN5c3RlbSlcbiAgICAgICAgdGhpcy5wbGFuZXRzID0gdGhpcy5ob3N0U3Rhci5wbGFuZXRzXG4gICAgfSBcblxuICAgIGFuaW1hdGUgKCkge1xuICAgICAgICB0aGlzLmRyYXcodGhpcy5jdHgpXG4gICAgICAgIHRoaXMuaG9zdFN0YXIuZHJhdyh0aGlzLmN0eClcbiAgICAgICAgdGhpcy5wbGFuZXRzLmZvckVhY2ggKCAocGxhbmV0KSA9PiB7XG4gICAgICAgICAgICBwbGFuZXQubW92ZSgpXG4gICAgICAgICAgICAvL3RvZG8gYWRkIGEgY29uZGl0aW9uYWwgZHVyaW5nIGVsbGlwdGljYWwgb3JiaXQgcGhhc2UgLSBpZiBkaXN0YW5jZSBiZXR3ZWVuIHBsYW5ldCBhbmQgaG9zdCBzdGFyIGNlbnRlciBpcyA8IGhvc3Qgc3RhciByYWRpdXMsIGRvIG5vdCBkcmF3LlxuICAgICAgICAgICAgcGxhbmV0LmRyYXcodGhpcy5jdHgpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZHJhdyhjdHgpe1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIlxuICAgICAgICBjdHguZmlsbFJlY3QoMCwwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICAgIH1cbiAgIFxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3OyJdLCJuYW1lcyI6WyJTdGFyIiwiVmlldyIsImNvbnN0cnVjdG9yIiwic3RhclN5c3RlbSIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJob3N0U3RhciIsInBsYW5ldHMiLCJhbmltYXRlIiwiZHJhdyIsImZvckVhY2giLCJwbGFuZXQiLCJtb3ZlIiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/view.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy1leG9wbGFuZXQtZXhwbG9yZXIvLi9zcmMvaW5kZXguc2Nzcz85NzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ }),

/***/ "./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AudioMotionAnalyzer; }\n/* harmony export */ });\n/**!\n * audioMotion-analyzer\n * High-resolution real-time graphic audio spectrum analyzer JS module\n *\n * @version 4.4.0\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\n * @license AGPL-3.0-or-later\n */\n\nconst VERSION = '4.4.0';\n\n// internal constants\nconst PI      = Math.PI,\n\t  TAU     = 2 * PI,\n\t  HALF_PI = PI / 2,\n\t  C_1     = 8.17579892;  // frequency for C -1\n\nconst CANVAS_BACKGROUND_COLOR  = '#000',\n\t  CHANNEL_COMBINED         = 'dual-combined',\n\t  CHANNEL_HORIZONTAL       = 'dual-horizontal',\n\t  CHANNEL_SINGLE           = 'single',\n\t  CHANNEL_VERTICAL         = 'dual-vertical',\n\t  COLOR_BAR_INDEX          = 'bar-index',\n\t  COLOR_BAR_LEVEL          = 'bar-level',\n\t  COLOR_GRADIENT           = 'gradient',\n\t  DEBOUNCE_TIMEOUT         = 60,\n\t  EVENT_CLICK              = 'click',\n\t  EVENT_FULLSCREENCHANGE   = 'fullscreenchange',\n\t  EVENT_RESIZE             = 'resize',\n \t  GRADIENT_DEFAULT_BGCOLOR = '#111',\n \t  FILTER_NONE              = '',\n \t  FILTER_A                 = 'A',\n \t  FILTER_B                 = 'B',\n \t  FILTER_C                 = 'C',\n \t  FILTER_D                 = 'D',\n \t  FILTER_468               = '468',\n\t  FONT_FAMILY              = 'sans-serif',\n\t  FPS_COLOR                = '#0f0',\n\t  LEDS_UNLIT_COLOR         = '#7f7f7f22',\n\t  MODE_GRAPH               = 10,\n\t  REASON_CREATE            = 'create',\n\t  REASON_FSCHANGE          = 'fschange',\n\t  REASON_LORES             = 'lores',\n\t  REASON_RESIZE            = EVENT_RESIZE,\n\t  REASON_USER              = 'user',\n\t  SCALEX_BACKGROUND_COLOR  = '#000c',\n\t  SCALEX_LABEL_COLOR       = '#fff',\n\t  SCALEX_HIGHLIGHT_COLOR   = '#4f4',\n\t  SCALEY_LABEL_COLOR       = '#888',\n\t  SCALEY_MIDLINE_COLOR     = '#555',\n\t  SCALE_BARK               = 'bark',\n\t  SCALE_LINEAR             = 'linear',\n\t  SCALE_LOG                = 'log',\n\t  SCALE_MEL                = 'mel';\n\n// built-in gradients\nconst PRISM = [ '#a35', '#c66', '#e94', '#ed0', '#9d5', '#4d8', '#2cb', '#0bc', '#09c', '#36b' ],\n\t  GRADIENTS = [\n\t  [ 'classic', {\n\t\t\tcolorStops: [\n\t\t\t\t'red',\n\t\t\t\t{ color: 'yellow', level: .85, pos: .6 },\n\t\t\t\t{ color: 'lime', level: .475 }\n\t\t\t]\n\t  }],\n\t  [ 'prism', {\n\t\t\tcolorStops: PRISM\n\t  }],\n\t  [ 'rainbow', {\n\t\t\tdir: 'h',\n\t\t\tcolorStops: [ '#817', ...PRISM, '#639' ]\n\t  }],\n\t  [ 'orangered', {\n\t  \t\tbgColor: '#3e2f29',\n\t  \t\tcolorStops: [ 'OrangeRed' ]\n\t  }],\n\t  [ 'steelblue', {\n\t  \t\tbgColor: '#222c35',\n\t  \t\tcolorStops: [ 'SteelBlue' ]\n\t  }]\n];\n\n// settings defaults\nconst DEFAULT_SETTINGS = {\n\talphaBars      : false,\n\tansiBands      : false,\n\tbarSpace       : 0.1,\n\tbgAlpha        : 0.7,\n\tchannelLayout  : CHANNEL_SINGLE,\n\tcolorMode      : COLOR_GRADIENT,\n\tfftSize        : 8192,\n\tfillAlpha      : 1,\n\tfrequencyScale : SCALE_LOG,\n\tgradient       : GRADIENTS[0][0],\n\theight         : undefined,\n\tledBars        : false,\n\tlinearAmplitude: false,\n\tlinearBoost    : 1,\n\tlineWidth      : 0,\n\tloRes          : false,\n\tlumiBars       : false,\n\tmaxDecibels    : -25,\n\tmaxFPS         : 0,\n\tmaxFreq        : 22000,\n\tminDecibels    : -85,\n\tminFreq        : 20,\n\tmirror         : 0,\n\tmode           : 0,\n\tnoteLabels     : false,\n\toutlineBars    : false,\n\toverlay        : false,\n\tpeakLine       : false,\n\tradial\t\t   : false,\n\tradialInvert   : false,\n\tradius         : 0.3,\n\treflexAlpha    : 0.15,\n\treflexBright   : 1,\n\treflexFit      : true,\n\treflexRatio    : 0,\n\troundBars      : false,\n\tshowBgColor    : true,\n\tshowFPS        : false,\n\tshowPeaks      : true,\n\tshowScaleX     : true,\n\tshowScaleY     : false,\n\tsmoothing      : 0.5,\n\tspinSpeed      : 0,\n\tsplitGradient  : false,\n\tstart          : true,\n\ttrueLeds       : false,\n\tuseCanvas      : true,\n\tvolume         : 1,\n\tweightingFilter: FILTER_NONE,\n\twidth          : undefined\n};\n\n// custom error messages\nconst ERR_AUDIO_CONTEXT_FAIL     = [ 'ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?' ],\n\t  ERR_INVALID_AUDIO_CONTEXT  = [ 'ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid' ],\n\t  ERR_UNKNOWN_GRADIENT       = [ 'ERR_UNKNOWN_GRADIENT', 'Unknown gradient' ],\n\t  ERR_FREQUENCY_TOO_LOW      = [ 'ERR_FREQUENCY_TOO_LOW', 'Frequency values must be >= 1' ],\n\t  ERR_INVALID_MODE           = [ 'ERR_INVALID_MODE', 'Invalid mode' ],\n\t  ERR_REFLEX_OUT_OF_RANGE    = [ 'ERR_REFLEX_OUT_OF_RANGE', 'Reflex ratio must be >= 0 and < 1' ],\n\t  ERR_INVALID_AUDIO_SOURCE   = [ 'ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode' ],\n\t  ERR_GRADIENT_INVALID_NAME  = [ 'ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string' ],\n\t  ERR_GRADIENT_NOT_AN_OBJECT = [ 'ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object' ],\n\t  ERR_GRADIENT_MISSING_COLOR = [ 'ERR_GRADIENT_MISSING_COLOR', 'Gradient colorStops must be a non-empty array' ];\n\nclass AudioMotionError extends Error {\n\tconstructor( error, value ) {\n\t\tconst [ code, message ] = error;\n\t\tsuper( message + ( value !== undefined ? `: ${value}` : '' ) );\n\t\tthis.name = 'AudioMotionError';\n\t\tthis.code = code;\n\t}\n}\n\n// helper function - output deprecation warning message on console\nconst deprecate = ( name, alternative ) => console.warn( `${name} is deprecated. Use ${alternative} instead.` );\n\n// helper function - check if a given object is empty (also returns `true` on null, undefined or any non-object value)\nconst isEmpty = obj => {\n\tfor ( const p in obj )\n\t\treturn false;\n\treturn true;\n}\n\n// helper function - validate a given value with an array of strings (by default, all lowercase)\n// returns the validated value, or the first element of `list` if `value` is not found in the array\nconst validateFromList = ( value, list, modifier = 'toLowerCase' ) => list[ Math.max( 0, list.indexOf( ( '' + value )[ modifier ]() ) ) ];\n\n// helper function - find the Y-coordinate of a point located between two other points, given its X-coordinate\nconst findY = ( x1, y1, x2, y2, x ) => y1 + ( y2 - y1 ) * ( x - x1 ) / ( x2 - x1 );\n\n// Polyfill for Array.findLastIndex()\nif ( ! Array.prototype.findLastIndex ) {\n\tArray.prototype.findLastIndex = function( callback ) {\n\t\tlet index = this.length;\n\t\twhile ( index-- > 0 ) {\n\t\t\tif ( callback( this[ index ] ) )\n\t\t\t\treturn index;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n// AudioMotionAnalyzer class\n\nclass AudioMotionAnalyzer {\n\n/**\n * CONSTRUCTOR\n *\n * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\n * @param {object} [options]\n * @returns {object} AudioMotionAnalyzer object\n */\n\tconstructor( container, options = {} ) {\n\n\t\tthis._ready = false;\n\n\t\t// Initialize internal objects\n\t\tthis._aux = {};\t\t\t\t// auxiliary variables\n\t\tthis._canvasGradients = []; // CanvasGradient objects for channels 0 and 1\n\t\tthis._destroyed = false;\n\t\tthis._energy = { val: 0, peak: 0, hold: 0 };\n\t\tthis._flg = {};\t\t\t\t// flags\n\t\tthis._fps = 0;\n\t\tthis._gradients = {};       // registered gradients\n\t\tthis._last = 0;\t\t\t\t// timestamp of last rendered frame\n\t\tthis._outNodes = [];\t\t// output nodes\n\t\tthis._ownContext = false;\n\t\tthis._selectedGrads = [];   // names of the currently selected gradients for channels 0 and 1\n\t\tthis._sources = [];\t\t\t// input nodes\n\n\t\t// Check if options object passed as first argument\n\t\tif ( ! ( container instanceof Element ) ) {\n\t\t\tif ( isEmpty( options ) && ! isEmpty( container ) )\n\t\t\t\toptions = container;\n\t\t\tcontainer = null;\n\t\t}\n\n\t\tthis._ownCanvas = ! ( options.canvas instanceof HTMLCanvasElement );\n\n\t\t// Create a new canvas or use the one provided by the user\n\t\tconst canvas = this._ownCanvas ? document.createElement('canvas') : options.canvas;\n\t\tcanvas.style = 'max-width: 100%;';\n\t\tthis._ctx = canvas.getContext('2d');\n\n\t\t// Register built-in gradients\n\t\tfor ( const [ name, options ] of GRADIENTS )\n\t\t\tthis.registerGradient( name, options );\n\n\t\t// Set container\n\t\tthis._container = container || ( ! this._ownCanvas && canvas.parentElement ) || document.body;\n\n\t\t// Make sure we have minimal width and height dimensions in case of an inline container\n\t\tthis._defaultWidth  = this._container.clientWidth  || 640;\n\t\tthis._defaultHeight = this._container.clientHeight || 270;\n\n\t\t// Use audio context provided by user, or create a new one\n\n\t\tlet audioCtx;\n\n\t\tif ( options.source && ( audioCtx = options.source.context ) ) {\n\t\t\t// get audioContext from provided source audioNode\n\t\t}\n\t\telse if ( audioCtx = options.audioCtx ) {\n\t\t\t// use audioContext provided by user\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\taudioCtx = new ( window.AudioContext || window.webkitAudioContext )();\n\t\t\t\tthis._ownContext = true;\n\t\t\t}\n\t\t\tcatch( err ) {\n\t\t\t\tthrow new AudioMotionError( ERR_AUDIO_CONTEXT_FAIL );\n\t\t\t}\n\t\t}\n\n\t\t// make sure audioContext is valid\n\t\tif ( ! audioCtx.createGain )\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_CONTEXT );\n\n\t\t/*\n\t\t\tConnection routing:\n\t\t\t===================\n\n\t\t\tfor dual channel layouts:                +--->  analyzer[0]  ---+\n\t\t    \t                                     |                      |\n\t\t\t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\n\t\t    \t                                     |                      |\n\t\t        \t                                 +--->  analyzer[1]  ---+\n\n\t\t\tfor single channel layout:\n\n\t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\n\n\t\t*/\n\n\t\t// create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\n\t\tconst analyzer = this._analyzer = [ audioCtx.createAnalyser(), audioCtx.createAnalyser() ];\n\t\tconst splitter = this._splitter = audioCtx.createChannelSplitter(2);\n \t\tconst merger   = this._merger   = audioCtx.createChannelMerger(2);\n \t\tthis._input    = audioCtx.createGain();\n \t\tthis._output   = audioCtx.createGain();\n\n \t\t// connect audio source if provided in the options\n\t\tif ( options.source )\n\t\t\tthis.connectInput( options.source );\n\n \t\t// connect splitter -> analyzers\n \t\tfor ( const i of [0,1] )\n\t\t\tsplitter.connect( analyzer[ i ], i );\n\n\t\t// connect merger -> output\n\t\tmerger.connect( this._output );\n\n\t\t// connect output -> destination (speakers)\n\t\tif ( options.connectSpeakers !== false )\n\t\t\tthis.connectOutput();\n\n\t\t// create auxiliary canvases for the X-axis and radial scale labels\n\t\tfor ( const ctx of [ '_scaleX', '_scaleR' ] )\n\t\t\tthis[ ctx ] = document.createElement('canvas').getContext('2d');\n\n\t\t// set fullscreen element (defaults to canvas)\n\t\tthis._fsEl = options.fsElement || canvas;\n\n\t\t// Update canvas size on container / window resize and fullscreen events\n\n\t\t// Fullscreen changes are handled quite differently across browsers:\n\t\t// 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\n\t\t// 2. Firefox triggers the `fullscreenchange` first and then the `resize`\n\t\t// 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\n\t\t// 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\n\t\t//    event is triggered **on the window** only (last tested on iPadOS 14)\n\n\t\t// helper function for resize events\n\t\tconst onResize = () => {\n\t\t\tif ( ! this._fsTimeout ) {\n\t\t\t\t// delay the resize to prioritize a possible following `fullscreenchange` event\n\t\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\t\tif ( ! this._fsChanging ) {\n\t\t\t\t\t\tthis._setCanvas( REASON_RESIZE );\n\t\t\t\t\t\tthis._fsTimeout = 0;\n\t\t\t\t\t}\n\t\t\t\t}, DEBOUNCE_TIMEOUT );\n\t\t\t}\n\t\t}\n\n\t\t// if browser supports ResizeObserver, listen for resize on the container\n\t\tif ( window.ResizeObserver ) {\n\t\t\tthis._observer = new ResizeObserver( onResize );\n\t\t\tthis._observer.observe( this._container );\n\t\t}\n\n\t\t// create an AbortController to remove event listeners on destroy()\n\t\tthis._controller = new AbortController();\n\t\tconst signal = this._controller.signal;\n\n\t\t// listen for resize events on the window - required for fullscreen on iPadOS\n\t\twindow.addEventListener( EVENT_RESIZE, onResize, { signal } );\n\n\t\t// listen for fullscreenchange events on the canvas - not available on Safari\n\t\tcanvas.addEventListener( EVENT_FULLSCREENCHANGE, () => {\n\t\t\t// set flag to indicate a fullscreen change in progress\n\t\t\tthis._fsChanging = true;\n\n\t\t\t// if there is a scheduled resize event, clear it\n\t\t\tif ( this._fsTimeout )\n\t\t\t\twindow.clearTimeout( this._fsTimeout );\n\n\t\t\t// update the canvas\n\t\t\tthis._setCanvas( REASON_FSCHANGE );\n\n\t\t\t// delay clearing the flag to prevent any shortly following resize event\n\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\tthis._fsChanging = false;\n\t\t\t\tthis._fsTimeout = 0;\n\t\t\t}, DEBOUNCE_TIMEOUT );\n\t\t}, { signal } );\n\n\t\t// Resume audio context if in suspended state (browsers' autoplay policy)\n\t\tconst unlockContext = () => {\n\t\t\tif ( audioCtx.state == 'suspended' )\n\t\t\t\taudioCtx.resume();\n\t\t\twindow.removeEventListener( EVENT_CLICK, unlockContext );\n\t\t}\n\t\twindow.addEventListener( EVENT_CLICK, unlockContext );\n\n\t\t// reset FPS-related variables when window becomes visible (avoid FPS drop due to frames not rendered while hidden)\n\t\tdocument.addEventListener( 'visibilitychange', () => {\n\t\t\tif ( document.visibilityState != 'hidden' ) {\n\t\t\t\tthis._frames = 0;\n\t\t\t\tthis._time = performance.now();\n\t\t\t}\n\t\t}, { signal } );\n\n\t\t// Set configuration options and use defaults for any missing properties\n\t\tthis._setProps( options, true );\n\n\t\t// Add canvas to the container (only when canvas not provided by user)\n\t\tif ( this.useCanvas && this._ownCanvas )\n\t\t\tthis._container.appendChild( canvas );\n\n\t\t// Finish canvas setup\n\t\tthis._ready = true;\n\t\tthis._setCanvas( REASON_CREATE );\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PUBLIC PROPERTIES GETTERS AND SETTERS\n\t *\n\t * ==========================================================================\n\t */\n\n\tget alphaBars() {\n\t\treturn this._alphaBars;\n\t}\n\tset alphaBars( value ) {\n\t\tthis._alphaBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget ansiBands() {\n\t\treturn this._ansiBands;\n\t}\n\tset ansiBands( value ) {\n\t\tthis._ansiBands = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget barSpace() {\n\t\treturn this._barSpace;\n\t}\n\tset barSpace( value ) {\n\t\tthis._barSpace = +value || 0;\n\t\tthis._calcBars();\n\t}\n\n\tget channelLayout() {\n\t\treturn this._chLayout;\n\t}\n\tset channelLayout( value ) {\n\t\tthis._chLayout = validateFromList( value, [ CHANNEL_SINGLE, CHANNEL_HORIZONTAL, CHANNEL_VERTICAL, CHANNEL_COMBINED ] );\n\n\t\t// update node connections\n\t\tthis._input.disconnect();\n\t\tthis._input.connect( this._chLayout != CHANNEL_SINGLE ? this._splitter : this._analyzer[0] );\n\t\tthis._analyzer[0].disconnect();\n\t\tif ( this._outNodes.length ) // connect analyzer only if the output is connected to other nodes\n\t\t\tthis._analyzer[0].connect( this._chLayout != CHANNEL_SINGLE ? this._merger : this._output );\n\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget colorMode() {\n\t\treturn this._colorMode;\n\t}\n\tset colorMode( value ) {\n\t\tthis._colorMode = validateFromList( value, [ COLOR_GRADIENT, COLOR_BAR_INDEX, COLOR_BAR_LEVEL ] );\n\t}\n\n\tget fftSize() {\n\t\treturn this._analyzer[0].fftSize;\n\t}\n\tset fftSize( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].fftSize = value;\n\t\tconst binCount = this._analyzer[0].frequencyBinCount;\n\t\tthis._fftData = [ new Float32Array( binCount ), new Float32Array( binCount ) ];\n\t\tthis._calcBars();\n\t}\n\n\tget frequencyScale() {\n\t\treturn this._frequencyScale;\n\t}\n\tset frequencyScale( value ) {\n\t\tthis._frequencyScale = validateFromList( value, [ SCALE_LOG, SCALE_BARK, SCALE_MEL, SCALE_LINEAR ] );\n\t\tthis._calcBars();\n\t}\n\n\tget gradient() {\n\t\treturn this._selectedGrads[0];\n\t}\n\tset gradient( value ) {\n\t\tthis._setGradient( value );\n\t}\n\n\tget gradientLeft() {\n\t\treturn this._selectedGrads[0];\n\t}\n\tset gradientLeft( value ) {\n\t\tthis._setGradient( value, 0 );\n\t}\n\n\tget gradientRight() {\n\t\treturn this._selectedGrads[1];\n\t}\n\tset gradientRight( value ) {\n\t\tthis._setGradient( value, 1 );\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset height( h ) {\n\t\tthis._height = h;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\tget ledBars() {\n\t\treturn this._showLeds;\n\t}\n\tset ledBars( value ) {\n\t\tthis._showLeds = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget linearAmplitude() {\n\t\treturn this._linearAmplitude;\n\t}\n\tset linearAmplitude( value ) {\n\t\tthis._linearAmplitude = !! value;\n\t}\n\n\tget linearBoost() {\n\t\treturn this._linearBoost;\n\t}\n\tset linearBoost( value ) {\n\t\tthis._linearBoost = value >= 1 ? +value : 1;\n\t}\n\n\tget lineWidth() {\n\t\treturn this._lineWidth;\n\t}\n\tset lineWidth( value ) {\n\t\tthis._lineWidth = +value || 0;\n\t}\n\n\tget loRes() {\n\t\treturn this._loRes;\n\t}\n\tset loRes( value ) {\n\t\tthis._loRes = !! value;\n\t\tthis._setCanvas( REASON_LORES );\n\t}\n\n\tget lumiBars() {\n\t\treturn this._lumiBars;\n\t}\n\tset lumiBars( value ) {\n\t\tthis._lumiBars = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget maxDecibels() {\n\t\treturn this._analyzer[0].maxDecibels;\n\t}\n\tset maxDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].maxDecibels = value;\n\t}\n\n\tget maxFPS() {\n\t\treturn this._maxFPS;\n\t}\n\tset maxFPS( value ) {\n\t\tthis._maxFPS = value < 0 ? 0 : +value || 0;\n\t}\n\n\tget maxFreq() {\n\t\treturn this._maxFreq;\n\t}\n\tset maxFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._maxFreq = Math.min( value, this.audioCtx.sampleRate / 2 );\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget minDecibels() {\n\t\treturn this._analyzer[0].minDecibels;\n\t}\n\tset minDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].minDecibels = value;\n\t}\n\n\tget minFreq() {\n\t\treturn this._minFreq;\n\t}\n\tset minFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._minFreq = +value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget mirror() {\n\t\treturn this._mirror;\n\t}\n\tset mirror( value ) {\n\t\tthis._mirror = Math.sign( value ) | 0; // ensure only -1, 0 or 1\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget mode() {\n\t\treturn this._mode;\n\t}\n\tset mode( value ) {\n\t\tconst mode = value | 0;\n\t\tif ( mode >= 0 && mode <= 10 && mode != 9 ) {\n\t\t\tthis._mode = mode;\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t\telse\n\t\t\tthrow new AudioMotionError( ERR_INVALID_MODE, value );\n\t}\n\n\tget noteLabels() {\n\t\treturn this._noteLabels;\n\t}\n\tset noteLabels( value ) {\n\t\tthis._noteLabels = !! value;\n\t\tthis._createScales();\n\t}\n\n\tget outlineBars() {\n\t\treturn this._outlineBars;\n\t}\n\tset outlineBars( value ) {\n\t\tthis._outlineBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget peakLine() {\n\t\treturn this._peakLine;\n\t}\n\tset peakLine( value ) {\n\t\tthis._peakLine = !! value;\n\t}\n\n\tget radial() {\n\t\treturn this._radial;\n\t}\n\tset radial( value ) {\n\t\tthis._radial = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget radialInvert() {\n\t\treturn this._radialInvert;\n\t}\n\tset radialInvert( value ) {\n\t\tthis._radialInvert = !! value;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget radius() {\n\t\treturn this._radius;\n\t}\n\tset radius( value ) {\n\t\tthis._radius = +value || 0;\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget reflexRatio() {\n\t\treturn this._reflexRatio;\n\t}\n\tset reflexRatio( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( value < 0 || value >= 1 )\n\t\t\tthrow new AudioMotionError( ERR_REFLEX_OUT_OF_RANGE );\n\t\telse {\n\t\t\tthis._reflexRatio = value;\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t}\n\n\tget roundBars() {\n\t\treturn this._roundBars;\n\t}\n\tset roundBars( value ) {\n\t\tthis._roundBars = !! value;\n\t\tthis._calcBars();\n\t}\n\n\tget smoothing() {\n\t\treturn this._analyzer[0].smoothingTimeConstant;\n\t}\n\tset smoothing( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].smoothingTimeConstant = value;\n\t}\n\n\tget spinSpeed() {\n\t\treturn this._spinSpeed;\n\t}\n\tset spinSpeed( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( this._spinSpeed === undefined || value == 0 )\n\t\t\tthis._spinAngle = -HALF_PI; // initialize or reset the rotation angle\n\t\tthis._spinSpeed = value;\n\t}\n\n\tget splitGradient() {\n\t\treturn this._splitGradient;\n\t}\n\tset splitGradient( value ) {\n\t\tthis._splitGradient = !! value;\n\t\tthis._makeGrad();\n\t}\n\n\tget stereo() {\n\t\tdeprecate( 'stereo', 'channelLayout' );\n\t\treturn this._chLayout != CHANNEL_SINGLE;\n\t}\n\tset stereo( value ) {\n\t\tdeprecate( 'stereo', 'channelLayout' );\n\t\tthis.channelLayout = value ? CHANNEL_VERTICAL : CHANNEL_SINGLE;\n\t}\n\n\tget trueLeds() {\n\t\treturn this._trueLeds;\n\t}\n\tset trueLeds( value ) {\n\t\tthis._trueLeds = !! value;\n\t}\n\n\tget volume() {\n\t\treturn this._output.gain.value;\n\t}\n\tset volume( value ) {\n\t\tthis._output.gain.value = value;\n\t}\n\n\tget weightingFilter() {\n\t\treturn this._weightingFilter;\n\t}\n\tset weightingFilter( value ) {\n\t\tthis._weightingFilter = validateFromList( value, [ FILTER_NONE, FILTER_A, FILTER_B, FILTER_C, FILTER_D, FILTER_468 ], 'toUpperCase' );\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset width( w ) {\n\t\tthis._width = w;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\t// Read only properties\n\n\tget audioCtx() {\n\t\treturn this._input.context;\n\t}\n\tget canvas() {\n\t\treturn this._ctx.canvas;\n\t}\n\tget canvasCtx() {\n\t\treturn this._ctx;\n\t}\n\tget connectedSources() {\n\t\treturn this._sources;\n\t}\n\tget connectedTo() {\n\t\treturn this._outNodes;\n\t}\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\tget fsHeight() {\n\t\treturn this._fsHeight;\n\t}\n\tget fsWidth() {\n\t\treturn this._fsWidth;\n\t}\n\tget isAlphaBars() {\n\t\treturn this._flg.isAlpha;\n\t}\n\tget isBandsMode() {\n\t\treturn this._flg.isBands;\n\t}\n\tget isDestroyed() {\n\t\treturn this._destroyed;\n\t}\n\tget isFullscreen() {\n\t\treturn this._fsEl && ( document.fullscreenElement || document.webkitFullscreenElement ) === this._fsEl;\n\t}\n\tget isLedBars() {\n\t\treturn this._flg.isLeds;\n\t}\n\tget isLumiBars() {\n\t\treturn this._flg.isLumi;\n\t}\n\tget isOctaveBands() {\n\t\treturn this._flg.isOctaves;\n\t}\n\tget isOn() {\n\t\treturn !! this._runId;\n\t}\n\tget isOutlineBars() {\n\t\treturn this._flg.isOutline;\n\t}\n\tget pixelRatio() {\n\t\treturn this._pixelRatio;\n\t}\n\tget isRoundBars() {\n\t\treturn this._flg.isRound;\n\t}\n\tstatic get version() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * ==========================================================================\n     *\n\t * PUBLIC METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Connects an HTML media element or audio node to the analyzer\n\t *\n\t * @param {object} an instance of HTMLMediaElement or AudioNode\n\t * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\n\t */\n\tconnectInput( source ) {\n\t\tconst isHTML = source instanceof HTMLMediaElement;\n\n\t\tif ( ! ( isHTML || source.connect ) )\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_SOURCE );\n\n\t\t// if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\n\t\tconst node = isHTML ? this.audioCtx.createMediaElementSource( source ) : source;\n\n\t\tif ( ! this._sources.includes( node ) ) {\n\t\t\tnode.connect( this._input );\n\t\t\tthis._sources.push( node );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Connects the analyzer output to another audio node\n\t *\n\t * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\n\t */\n\tconnectOutput( node = this.audioCtx.destination ) {\n\t\tif ( this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.connect( node );\n\t\tthis._outNodes.push( node );\n\n\t\t// when connecting the first node, also connect the analyzer nodes to the merger / output nodes\n\t\tif ( this._outNodes.length == 1 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].connect( ( this._chLayout == CHANNEL_SINGLE && ! i ? this._output : this._merger ), 0, i );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys instance\n\t */\n\tdestroy() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { audioCtx, canvas, _controller, _input, _merger, _observer, _ownCanvas, _ownContext, _splitter } = this;\n\n\t\tthis._destroyed = true;\n\t\tthis._ready = false;\n\t\tthis.stop();\n\n\t\t// remove event listeners\n\t\t_controller.abort();\n\t\tif ( _observer )\n\t\t\t_observer.disconnect();\n\n\t\t// clear callbacks and fullscreen element\n\t\tthis.onCanvasResize = null;\n\t\tthis.onCanvasDraw = null;\n\t\tthis._fsEl = null;\n\n\t\t// disconnect audio nodes\n\t\tthis.disconnectInput();\n\t\tthis.disconnectOutput(); // also disconnects analyzer nodes\n\t\t_input.disconnect();\n\t\t_splitter.disconnect();\n\t\t_merger.disconnect();\n\n\t\t// if audio context is our own (not provided by the user), close it\n\t\tif ( _ownContext )\n\t\t\taudioCtx.close();\n\n\t\t// remove canvas from the DOM (if not provided by the user)\n\t\tif ( _ownCanvas )\n\t\t\tcanvas.remove();\n\n\t\t// reset flags\n\t\tthis._calcBars();\n\t}\n\n\t/**\n\t * Disconnects audio sources from the analyzer\n\t *\n\t * @param [{object|array}] a connected AudioNode object or an array of such objects; if falsy, all connected nodes are disconnected\n\t * @param [{boolean}] if true, stops/releases audio tracks from disconnected media streams (e.g. microphone)\n\t */\n\tdisconnectInput( sources, stopTracks ) {\n\t\tif ( ! sources )\n\t\t\tsources = Array.from( this._sources );\n\t\telse if ( ! Array.isArray( sources ) )\n\t\t\tsources = [ sources ];\n\n\t\tfor ( const node of sources ) {\n\t\t\tconst idx = this._sources.indexOf( node );\n\t\t\tif ( stopTracks && node.mediaStream ) {\n\t\t\t\tfor ( const track of node.mediaStream.getAudioTracks() ) {\n\t\t\t\t\ttrack.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( idx >= 0 ) {\n\t\t\t\tnode.disconnect( this._input );\n\t\t\t\tthis._sources.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Disconnects the analyzer output from other audio nodes\n\t *\n\t * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectOutput( node ) {\n\t\tif ( node && ! this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.disconnect( node );\n\t\tthis._outNodes = node ? this._outNodes.filter( e => e !== node ) : [];\n\n\t\t// if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\n\t\t// see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\n\t\tif ( this._outNodes.length == 0 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].disconnect();\n\t\t}\n\t}\n\n\t/**\n\t * Returns analyzer bars data\n     *\n\t * @returns {array}\n\t */\n\tgetBars() {\n\t\treturn Array.from( this._bars, ( { posX, freq, freqLo, freqHi, hold, peak, value } ) => ( { posX, freq, freqLo, freqHi, hold, peak, value } ) );\n\t}\n\n\t/**\n\t * Returns the energy of a frequency, or average energy of a range of frequencies\n\t *\n\t * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\n\t * @param [{number}] ending frequency (Hz)\n\t * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\n\t */\n\tgetEnergy( startFreq, endFreq ) {\n\t\tif ( startFreq === undefined )\n\t\t\treturn this._energy.val;\n\n\t\t// if startFreq is a string, check for presets\n\t\tif ( startFreq != +startFreq ) {\n\t\t\tif ( startFreq == 'peak' )\n\t\t\t\treturn this._energy.peak;\n\n\t\t\tconst presets = {\n\t\t\t\tbass:    [ 20, 250 ],\n\t\t\t\tlowMid:  [ 250, 500 ],\n\t\t\t\tmid:     [ 500, 2e3 ],\n\t\t\t\thighMid: [ 2e3, 4e3 ],\n\t\t\t\ttreble:  [ 4e3, 16e3 ]\n\t\t\t}\n\n\t\t\tif ( ! presets[ startFreq ] )\n\t\t\t\treturn null;\n\n\t\t\t[ startFreq, endFreq ] = presets[ startFreq ];\n\t\t}\n\n\t\tconst startBin = this._freqToBin( startFreq ),\n\t\t      endBin   = endFreq ? this._freqToBin( endFreq ) : startBin,\n\t\t      chnCount = this._chLayout == CHANNEL_SINGLE ? 1 : 2;\n\n\t\tlet energy = 0;\n\t\tfor ( let channel = 0; channel < chnCount; channel++ ) {\n\t\t\tfor ( let i = startBin; i <= endBin; i++ )\n\t\t\t\tenergy += this._normalizedB( this._fftData[ channel ][ i ] );\n\t\t}\n\n\t\treturn energy / ( endBin - startBin + 1 ) / chnCount;\n\t}\n\n\t/**\n\t * Returns current analyzer settings in object format\n\t *\n\t * @param [{string|array}] a property name or an array of property names to not include in the returned object\n\t * @returns {object} Options object\n\t */\n\tgetOptions( ignore ) {\n\t\tif ( ! Array.isArray( ignore ) )\n\t\t\tignore = [ ignore ];\n\t\tlet options = {};\n\t\tfor ( const prop of Object.keys( DEFAULT_SETTINGS ) ) {\n\t\t\tif ( ! ignore.includes( prop ) ) {\n\t\t\t\tif ( prop == 'gradient' && this.gradientLeft != this.gradientRight ) {\n\t\t\t\t\toptions.gradientLeft = this.gradientLeft;\n\t\t\t\t\toptions.gradientRight = this.gradientRight;\n\t\t\t\t}\n\t\t\t\telse if ( prop != 'start' )\n\t\t\t\t\toptions[ prop ] = this[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n\t * Registers a custom gradient\n\t *\n\t * @param {string} name\n\t * @param {object} options\n\t */\n\tregisterGradient( name, options ) {\n\t\tif ( typeof name != 'string' || name.trim().length == 0 )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_INVALID_NAME );\n\n\t\tif ( typeof options != 'object' )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_NOT_AN_OBJECT );\n\n\t\tconst { colorStops } = options;\n\n\t\tif ( ! Array.isArray( colorStops ) || ! colorStops.length )\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_MISSING_COLOR );\n\n\t\tconst count     = colorStops.length,\n\t\t\t  isInvalid = val => +val != val || val < 0 || val > 1;\n\n\t\t// normalize all colorStops as objects with `pos`, `color` and `level` properties\n\t\tcolorStops.forEach( ( colorStop, index ) => {\n\t\t\tconst pos = index / Math.max( 1, count - 1 );\n\t\t\tif ( typeof colorStop != 'object' ) // only color string was defined\n\t\t\t\tcolorStops[ index ] = {\tpos, color: colorStop };\n\t\t\telse if ( isInvalid( colorStop.pos ) )\n\t\t\t\tcolorStop.pos = pos;\n\n\t\t\tif ( isInvalid( colorStop.level ) )\n\t\t\t\tcolorStops[ index ].level = 1 - index / count;\n\t\t});\n\n\t\t// make sure colorStops is in descending `level` order and that the first one has `level == 1`\n\t\t// this is crucial for proper operation of 'bar-level' colorMode!\n\t\tcolorStops.sort( ( a, b ) => a.level < b.level ? 1 : a.level > b.level ? -1 : 0 );\n\t\tcolorStops[0].level = 1;\n\n\t\tthis._gradients[ name ] = {\n\t\t\tbgColor:    options.bgColor || GRADIENT_DEFAULT_BGCOLOR,\n\t\t\tdir:        options.dir,\n\t\t\tcolorStops: colorStops\n\t\t};\n\n\t\t// if the registered gradient is one of the currently selected gradients, regenerate them\n\t\tif ( this._selectedGrads.includes( name ) )\n\t\t\tthis._makeGrad();\n\t}\n\n\t/**\n\t * Set dimensions of analyzer's canvas\n\t *\n\t * @param {number} w width in pixels\n\t * @param {number} h height in pixels\n\t */\n\tsetCanvasSize( w, h ) {\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis._setCanvas( REASON_USER );\n\t}\n\n\t/**\n\t * Set desired frequency range\n\t *\n\t * @param {number} min lowest frequency represented in the x-axis\n\t * @param {number} max highest frequency represented in the x-axis\n\t */\n\tsetFreqRange( min, max ) {\n\t\tif ( min < 1 || max < 1 )\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\n\t\telse {\n\t\t\tthis._minFreq = Math.min( min, max );\n\t\t\tthis.maxFreq  = Math.max( min, max ); // use the setter for maxFreq\n\t\t}\n\t}\n\n\t/**\n\t * Set custom parameters for LED effect\n\t * If called with no arguments or if any property is invalid, clears any previous custom parameters\n\t *\n\t * @param {object} [params]\n\t */\n\tsetLedParams( params ) {\n\t\tlet maxLeds, spaceV, spaceH;\n\n\t\t// coerce parameters to Number; `NaN` results are rejected in the condition below\n\t\tif ( params ) {\n\t\t\tmaxLeds = params.maxLeds | 0, // ensure integer\n\t\t\tspaceV  = +params.spaceV,\n\t\t\tspaceH  = +params.spaceH;\n\t\t}\n\n\t\tthis._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [ maxLeds, spaceV, spaceH ] : undefined;\n\t\tthis._calcBars();\n\t}\n\n\t/**\n\t * Shorthand function for setting several options at once\n\t *\n\t * @param {object} options\n\t */\n\tsetOptions( options ) {\n\t\tthis._setProps( options );\n\t}\n\n\t/**\n\t * Adjust the analyzer's sensitivity\n\t *\n\t * @param {number} min minimum decibels value\n\t * @param {number} max maximum decibels value\n\t */\n\tsetSensitivity( min, max ) {\n\t\tfor ( const i of [0,1] ) {\n\t\t\tthis._analyzer[ i ].minDecibels = Math.min( min, max );\n\t\t\tthis._analyzer[ i ].maxDecibels = Math.max( min, max );\n\t\t}\n\t}\n\n\t/**\n\t * Start the analyzer\n\t */\n\tstart() {\n\t\tthis.toggleAnalyzer( true );\n\t}\n\n\t/**\n\t * Stop the analyzer\n\t */\n\tstop() {\n\t\tthis.toggleAnalyzer( false );\n\t}\n\n\t/**\n\t * Start / stop canvas animation\n\t *\n\t * @param {boolean} [force] if undefined, inverts the current state\n\t * @returns {boolean} resulting state after the change\n\t */\n\ttoggleAnalyzer( force ) {\n\t\tconst hasStarted = this.isOn;\n\n\t\tif ( force === undefined )\n\t\t\tforce = ! hasStarted;\n\n\t\t// Stop the analyzer if it was already running and must be disabled\n\t\tif ( hasStarted && ! force ) {\n\t\t\tcancelAnimationFrame( this._runId );\n\t\t\tthis._runId = 0;\n\t\t}\n\t\t// Start the analyzer if it was stopped and must be enabled\n\t\telse if ( ! hasStarted && force && ! this._destroyed ) {\n\t\t\tthis._frames = 0;\n\t\t\tthis._time = performance.now();\n\t\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) ); // arrow function preserves the scope of *this*\n\t\t}\n\n\t\treturn this.isOn;\n\t}\n\n\t/**\n\t * Toggles canvas full-screen mode\n\t */\n\ttoggleFullscreen() {\n\t\tif ( this.isFullscreen ) {\n\t\t\tif ( document.exitFullscreen )\n\t\t\t\tdocument.exitFullscreen();\n\t\t\telse if ( document.webkitExitFullscreen )\n\t\t\t\tdocument.webkitExitFullscreen();\n\t\t}\n\t\telse {\n\t\t\tconst fsEl = this._fsEl;\n\t\t\tif ( ! fsEl )\n\t\t\t\treturn;\n\t\t\tif ( fsEl.requestFullscreen )\n\t\t\t\tfsEl.requestFullscreen();\n\t\t\telse if ( fsEl.webkitRequestFullscreen )\n\t\t\t\tfsEl.webkitRequestFullscreen();\n\t\t}\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PRIVATE METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Return the frequency (in Hz) for a given FFT bin\n\t */\n\t_binToFreq( bin ) {\n\t\treturn bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0\n\t}\n\n\t/**\n\t * Compute all internal data required for the analyzer, based on its current settings\n\t */\n\t_calcBars() {\n\t\tconst bars = this._bars = []; // initialize object property\n\n\t\tif ( ! this._ready ) {\n\t\t\tthis._flg = { isAlpha: false, isBands: false, isLeds: false, isLumi: false, isOctaves: false, isOutline: false, isRound: false, noLedGap: false };\n\t\t\treturn;\n\t\t}\n\n\t\tconst { _ansiBands, _barSpace, canvas, _chLayout, _maxFreq, _minFreq, _mirror, _mode, _radial, _radialInvert, _reflexRatio } = this,\n\t\t\t  centerX          = canvas.width >> 1,\n\t\t\t  centerY          = canvas.height >> 1,\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL && ! _radial,\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n\n\t\t\t  // COMPUTE FLAGS\n\n\t\t\t  isBands   = _mode % 10 != 0, // true for modes 1 to 9\n\t\t\t  isOctaves = isBands && this._frequencyScale == SCALE_LOG,\n\t\t\t  isLeds    = this._showLeds && isBands && ! _radial,\n\t\t\t  isLumi    = this._lumiBars && isBands && ! _radial,\n\t\t\t  isAlpha   = this._alphaBars && ! isLumi && _mode != MODE_GRAPH,\n\t\t\t  isOutline = this._outlineBars && isBands && ! isLumi && ! isLeds,\n\t\t\t  isRound   = this._roundBars && isBands && ! isLumi && ! isLeds,\n\t\t\t  noLedGap  = _chLayout != CHANNEL_VERTICAL || _reflexRatio > 0 && ! isLumi,\n\n\t\t\t  // COMPUTE AUXILIARY VALUES\n\n\t\t\t  // channelHeight is the total canvas height dedicated to each channel, including the reflex area, if any)\n\t\t\t  channelHeight  = canvas.height - ( isDualVertical && ! isLeds ? .5 : 0 ) >> isDualVertical,\n\t\t\t  // analyzerHeight is the effective height used to render the analyzer, excluding the reflex area\n\t\t\t  analyzerHeight = channelHeight * ( isLumi || _radial ? 1 : 1 - _reflexRatio ) | 0,\n\n\t\t\t  analyzerWidth  = canvas.width - centerX * ( isDualHorizontal || _mirror != 0 ),\n\n\t\t\t  // channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\n\t\t\t  // TODO: improve this, make it configurable?\n\t\t\t  channelGap     = isDualVertical ? canvas.height - channelHeight * 2 : 0,\n\n\t\t\t  initialX       = centerX * ( _mirror == -1 && ! isDualHorizontal && ! _radial );\n\n\t\tlet innerRadius = Math.min( canvas.width, canvas.height ) * .375 * ( _chLayout == CHANNEL_VERTICAL ? 1 : this._radius ) | 0,\n\t\t\touterRadius = Math.min( centerX, centerY );\n\n\t\tif ( _radialInvert && _chLayout != CHANNEL_VERTICAL )\n\t\t\t[ innerRadius, outerRadius ] = [ outerRadius, innerRadius ];\n\n\t\t/**\n\t\t *\tCREATE ANALYZER BANDS\n\t\t *\n\t\t *\tUSES:\n\t\t *\t\tanalyzerWidth\n\t\t *\t\tinitialX\n\t\t *\t\tisBands\n\t\t *\t\tisOctaves\n\t\t *\n\t\t *\tGENERATES:\n\t\t *\t\tbars (populates this._bars)\n\t\t *\t\tbardWidth\n\t\t *\t\tscaleMin\n\t\t *\t\tunitWidth\n\t\t */\n\n\t\t// helper function\n\t\t// bar object: { posX, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi, peak, hold, value }\n\t\tconst barsPush = args => bars.push( { ...args, peak: [0,0], hold: [0], value: [0] } );\n\n\t\t/*\n\t\t\tA simple interpolation is used to obtain an approximate amplitude value for any given frequency,\n\t\t\tfrom the available FFT data. We find the FFT bin which closer matches the desired frequency\tand\n\t\t\tinterpolate its value with that of the next adjacent bin, like so:\n\n\t\t\t\tv = v0 + ( v1 - v0 ) * ( log2( f / f0 ) / log2( f1 / f0 ) )\n\t\t\t\t                       \\__________________________________/\n\t\t\t\t                                        |\n\t\t\t\t                                      ratio\n\t\t\t\twhere:\n\n\t\t\t\tf  - desired frequency\n\t\t\t\tv  - amplitude (volume) of desired frequency\n\t\t\t\tf0 - frequency represented by the lower FFT bin\n\t\t\t\tf1 - frequency represented by the upper FFT bin\n\t\t\t\tv0 - amplitude of f0\n\t\t\t\tv1 - amplitude of f1\n\n\t\t\tratio is calculated in advance here, to reduce computational complexity during real-time rendering.\n\t\t*/\n\n\t\t// helper function to calculate FFT bin and interpolation ratio for a given frequency\n\t\tconst calcRatio = freq => {\n\t\t\tconst bin   = this._freqToBin( freq, 'floor' ), // find closest FFT bin\n\t\t\t\t  lower = this._binToFreq( bin ),\n\t\t\t\t  upper = this._binToFreq( bin + 1 ),\n\t\t\t\t  ratio = Math.log2( freq / lower ) / Math.log2( upper / lower );\n\n\t\t\treturn [ bin, ratio ];\n\t\t}\n\n\t\tlet barWidth, scaleMin, unitWidth;\n\n\t\tif ( isOctaves ) {\n\t\t\t// helper function to round a value to a given number of significant digits\n\t\t\t// `atLeast` set to true prevents reducing the number of integer significant digits\n\t\t\tconst roundSD = ( value, digits, atLeast ) => +value.toPrecision( atLeast ? Math.max( digits, 1 + Math.log10( value ) | 0 ) : digits );\n\n\t\t\t// helper function to find the nearest preferred number (Renard series) for a given value\n\t\t\tconst nearestPreferred = value => {\n\t\t\t\t// R20 series is used here, as it provides closer approximations for 1/2 octave bands (non-standard)\n\t\t\t\tconst preferred = [ 1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10 ],\n\t\t\t\t\t  power = Math.log10( value ) | 0,\n\t\t\t\t\t  normalized = value / 10 ** power;\n\n\t\t\t\tlet i = 1;\n\t\t\t\twhile ( i < preferred.length && normalized > preferred[ i ] )\n\t\t\t\t\ti++;\n\n\t\t\t\tif ( normalized - preferred[ i - 1 ] < preferred[ i ] - normalized )\n\t\t\t\t\ti--;\n\n\t\t\t\treturn ( preferred[ i ] * 10 ** ( power + 5 ) | 0 ) / 1e5; // keep 5 significant digits\n\t\t\t}\n\n\t\t\t// ANSI standard octave bands use the base-10 frequency ratio, as preferred by [ANSI S1.11-2004, p.2]\n\t\t\t// The equal-tempered scale uses the base-2 ratio\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ],\n\t\t\t\t  bandWidth = _ansiBands ? 10 ** ( 3 / ( bands * 10 ) ) : 2 ** ( 1 / bands ), // 10^(3/10N) or 2^(1/N)\n\t\t\t\t  halfBand  = bandWidth ** .5;\n\n\t\t\tlet analyzerBars = [],\n\t\t\t\tcurrFreq = _ansiBands ? 7.94328235 / ( bands % 2 ? 1 : halfBand ) : C_1;\n\t\t\t\t// For ANSI bands with even denominators (all except 1/1 and 1/3), the reference frequency (1 kHz)\n\t\t\t\t// must fall on the edges of a pair of adjacent bands, instead of midband [ANSI S1.11-2004, p.2]\n\t\t\t\t// In the equal-tempered scale, all midband frequencies represent a musical note or quarter-tone.\n\n\t\t\tdo {\n\t\t\t\tlet freq = currFreq; // midband frequency\n\n\t\t\t\tconst freqLo = roundSD( freq / halfBand, 4, true ), // lower edge frequency\n\t\t\t\t\t  freqHi = roundSD( freq * halfBand, 4, true ), // upper edge frequency\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\n\n\t\t\t\t// for 1/1, 1/2 and 1/3 ANSI bands, use the preferred numbers to find the nominal midband frequency\n\t\t\t\t// for 1/4 to 1/24, round to 2 or 3 significant digits, according to the MSD [ANSI S1.11-2004, p.12]\n\t\t\t\tif ( _ansiBands )\n\t\t\t\t\tfreq = bands < 4 ? nearestPreferred( freq ) : roundSD( freq, freq.toString()[0] < 5 ? 3 : 2 );\n\t\t\t\telse\n\t\t\t\t\tfreq = roundSD( freq, 4, true );\n\n\t\t\t\tif ( freq >= _minFreq )\n\t\t\t\t\tbarsPush( { posX: 0, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\n\n\t\t\t\tcurrFreq *= bandWidth;\n\t\t\t} while ( currFreq <= _maxFreq );\n\n\t\t\tbarWidth = analyzerWidth / bars.length;\n\n\t\t\tbars.forEach( ( bar, index ) => bar.posX = initialX + index * barWidth );\n\n\t\t\tconst firstBar = bars[0],\n\t\t\t\t  lastBar  = bars[ bars.length - 1 ];\n\n\t\t\tscaleMin = this._freqScaling( firstBar.freqLo );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( lastBar.freqHi ) - scaleMin );\n\n\t\t\t// clamp edge frequencies to minFreq / maxFreq, if necessary\n\t\t\t// this is done after computing scaleMin and unitWidth, for the proper positioning of labels on the X-axis\n\t\t\tif ( firstBar.freqLo < _minFreq ) {\n\t\t\t\tfirstBar.freqLo = _minFreq;\n\t\t\t\t[ firstBar.binLo, firstBar.ratioLo ] = calcRatio( _minFreq );\n\t\t\t}\n\n\t\t\tif ( lastBar.freqHi > _maxFreq ) {\n\t\t\t\tlastBar.freqHi = _maxFreq;\n\t\t\t\t[ lastBar.binHi, lastBar.ratioHi ] = calcRatio( _maxFreq );\n\t\t\t}\n\t\t}\n\t\telse if ( isBands ) { // a bands mode is selected, but frequency scale is not logarithmic\n\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ] * 10;\n\n\t\t\tconst invFreqScaling = x => {\n\t\t\t\tswitch ( this._frequencyScale ) {\n\t\t\t\t\tcase SCALE_BARK :\n\t\t\t\t\t\treturn 1960 / ( 26.81 / ( x + .53 ) - 1 );\n\t\t\t\t\tcase SCALE_MEL :\n\t\t\t\t\t\treturn 700 * ( 2 ** x - 1 );\n\t\t\t\t\tcase SCALE_LINEAR :\n\t\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbarWidth = analyzerWidth / bands;\n\n\t\t\tscaleMin = this._freqScaling( _minFreq );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\n\n\t\t\tfor ( let i = 0, posX = 0; i < bands; i++, posX += barWidth ) {\n\t\t\t\tconst freqLo = invFreqScaling( scaleMin + posX / unitWidth ),\n\t\t\t\t\t  freq   = invFreqScaling( scaleMin + ( posX + barWidth / 2 ) / unitWidth ),\n\t\t\t\t\t  freqHi = invFreqScaling( scaleMin + ( posX + barWidth ) / unitWidth ),\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\n\n\t\t\t\tbarsPush( { posX: initialX + posX, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\n\t\t\t}\n\n\t\t}\n\t\telse {\t// Discrete frequencies modes\n\t\t\tbarWidth = 1;\n\n\t\t\tscaleMin = this._freqScaling( _minFreq );\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\n\n\t\t\tconst minIndex = this._freqToBin( _minFreq, 'floor' ),\n\t\t\t\t  maxIndex = this._freqToBin( _maxFreq );\n\n\t \t\tlet lastPos = -999;\n\n\t\t\tfor ( let i = minIndex; i <= maxIndex; i++ ) {\n\t\t\t\tconst freq = this._binToFreq( i ), // frequency represented by this index\n\t\t\t\t\t  posX = initialX + Math.round( unitWidth * ( this._freqScaling( freq ) - scaleMin ) ); // avoid fractionary pixel values\n\n\t\t\t\t// if it's on a different X-coordinate, create a new bar for this frequency\n\t\t\t\tif ( posX > lastPos ) {\n\t\t\t\t\tbarsPush( { posX, freq, freqLo: freq, freqHi: freq, binLo: i, binHi: i, ratioLo: 0, ratioHi: 0 } );\n\t\t\t\t\tlastPos = posX;\n\t\t\t\t} // otherwise, add this frequency to the last bar's range\n\t\t\t\telse if ( bars.length ) {\n\t\t\t\t\tconst lastBar = bars[ bars.length - 1 ];\n\t\t\t\t\tlastBar.binHi = i;\n\t\t\t\t\tlastBar.freqHi = freq;\n\t\t\t\t\tlastBar.freq = ( lastBar.freqLo * freq ) ** .5; // compute center frequency (geometric mean)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *  COMPUTE ATTRIBUTES FOR THE LED BARS\n\t\t *\n\t\t *\tUSES:\n\t\t *\t\tanalyzerHeight\n\t\t *\t\tbarWidth\n\t\t *\t\tnoLedGap\n\t\t *\n\t\t *\tGENERATES:\n\t\t * \t\tspaceH\n\t\t * \t\tspaceV\n\t\t *\t\tthis._leds\n\t\t */\n\n\t\tlet spaceH = 0,\n\t\t\tspaceV = 0;\n\n\t\tif ( isLeds ) {\n\t\t\t// adjustment for high pixel-ratio values on low-resolution screens (Android TV)\n\t\t\tconst dPR = this._pixelRatio / ( window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1 );\n\n\t\t\tconst params = [ [],\n\t\t\t\t[ 128,  3, .45  ], // mode 1\n\t\t\t\t[ 128,  4, .225 ], // mode 2\n\t\t\t\t[  96,  6, .225 ], // mode 3\n\t\t\t\t[  80,  6, .225 ], // mode 4\n\t\t\t\t[  80,  6, .125 ], // mode 5\n\t\t\t\t[  64,  6, .125 ], // mode 6\n\t\t\t\t[  48,  8, .125 ], // mode 7\n\t\t\t\t[  24, 16, .125 ], // mode 8\n\t\t\t];\n\n\t\t\t// use custom LED parameters if set, or the default parameters for the current mode\n\t\t\tconst customParams = this._ledParams,\n\t\t\t\t  [ maxLeds, spaceVRatio, spaceHRatio ] = customParams || params[ _mode ];\n\n\t\t\tlet ledCount, maxHeight = analyzerHeight;\n\n\t\t\tif ( customParams ) {\n\t\t\t\tconst minHeight = 2 * dPR;\n\t\t\t\tlet blockHeight;\n\t\t\t\tledCount = maxLeds + 1;\n\t\t\t\tdo {\n\t\t\t\t\tledCount--;\n\t\t\t\t\tblockHeight = maxHeight / ledCount / ( 1 + spaceVRatio );\n\t\t\t\t\tspaceV = blockHeight * spaceVRatio;\n\t\t\t\t} while ( ( blockHeight < minHeight || spaceV < minHeight ) && ledCount > 1 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\n\t\t\t\tconst refRatio = 540 / spaceVRatio;\n\t\t\t\tspaceV = Math.min( spaceVRatio * dPR, Math.max( 2, maxHeight / refRatio + .1 | 0 ) );\n\t\t\t}\n\n\t\t\t// remove the extra spacing below the last line of LEDs\n\t\t\tif ( noLedGap )\n\t\t\t\tmaxHeight += spaceV;\n\n\t\t\t// recalculate the number of leds, considering the effective spaceV\n\t\t\tif ( ! customParams )\n\t\t\t\tledCount = Math.min( maxLeds, maxHeight / ( spaceV * 2 ) | 0 );\n\n\t\t\tspaceH = spaceHRatio >= 1 ? spaceHRatio : barWidth * spaceHRatio;\n\n\t\t\tthis._leds = [\n\t\t\t\tledCount,\n\t\t\t\tspaceH,\n\t\t\t\tspaceV,\n\t\t\t\tmaxHeight / ledCount - spaceV // ledHeight\n\t\t\t];\n\t\t}\n\n\t\t// COMPUTE ADDITIONAL BAR POSITIONING, ACCORDING TO THE CURRENT SETTINGS\n\t\t// uses: _barSpace, barWidth, spaceH\n\n\t\tconst barSpacePx = Math.min( barWidth - 1, _barSpace * ( _barSpace > 0 && _barSpace < 1 ? barWidth : 1 ) );\n\n\t\tif ( isBands )\n\t\t\tbarWidth -= Math.max( isLeds ? spaceH : 0, barSpacePx );\n\n\t\tbars.forEach( ( bar, index ) => {\n\t\t\tlet posX  = bar.posX,\n\t\t\t\twidth = barWidth;\n\n\t\t\t// in bands modes we need to update bar.posX to account for bar/led spacing\n\n\t\t\tif ( isBands ) {\n\t\t\t\tif ( _barSpace == 0 && ! isLeds ) {\n\t\t\t\t\t// when barSpace == 0 use integer values for perfect gapless positioning\n\t\t\t\t\tposX |= 0;\n\t\t\t\t\twidth |= 0;\n\t\t\t\t\tif ( index > 0 && posX > bars[ index - 1 ].posX + bars[ index - 1 ].width ) {\n\t\t\t\t\t\tposX--;\n\t\t\t\t\t\twidth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tposX += Math.max( ( isLeds ? spaceH : 0 ), barSpacePx ) / 2;\n\n\t\t\t\tbar.posX = posX; // update\n\t\t\t}\n\n\t\t\tbar.barCenter = posX + ( barWidth == 1 ? 0 : width / 2 );\n\t\t\tbar.width = width;\n\t\t});\n\n\t\t// COMPUTE CHANNEL COORDINATES (uses spaceV)\n\n\t\tconst channelCoords = [];\n\t\tfor ( const channel of [0,1] ) {\n\t\t\tconst channelTop     = _chLayout == CHANNEL_VERTICAL ? ( channelHeight + channelGap ) * channel : 0,\n\t\t\t\t  channelBottom  = channelTop + channelHeight,\n\t\t\t\t  analyzerBottom = channelTop + analyzerHeight - ( ! isLeds || noLedGap ? 0 : spaceV );\n\n\t\t\tchannelCoords.push( { channelTop, channelBottom, analyzerBottom } );\n\t\t}\n\n\t\t// SAVE INTERNAL PROPERTIES\n\n\t\tthis._aux = { analyzerHeight, analyzerWidth, centerX, centerY, channelCoords, channelHeight, channelGap, initialX, innerRadius, outerRadius, scaleMin, unitWidth };\n\t\tthis._flg = { isAlpha, isBands, isLeds, isLumi, isOctaves, isOutline, isRound, noLedGap };\n\n\t\t// generate the X-axis and radial scales\n\t\tthis._createScales();\n\t}\n\n\t/**\n\t * Generate the X-axis and radial scales in auxiliary canvases\n\t */\n\t_createScales() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { analyzerWidth, initialX, innerRadius, scaleMin, unitWidth } = this._aux,\n\t\t\t  { canvas, _frequencyScale, _mirror, _noteLabels, _radial, _scaleX, _scaleR } = this,\n\t\t\t  canvasX          = _scaleX.canvas,\n\t\t\t  canvasR          = _scaleR.canvas,\n\t\t\t  freqLabels       = [],\n\t\t\t  isDualHorizontal = this._chLayout == CHANNEL_HORIZONTAL,\n\t\t\t  isDualVertical   = this._chLayout == CHANNEL_VERTICAL,\n\t\t\t  minDimension     = Math.min( canvas.width, canvas.height ),\n\t\t\t  scale            = [ 'C',, 'D',, 'E', 'F',, 'G',, 'A',, 'B' ], // for note labels (no sharp notes)\n\t\t\t  scaleHeight      = minDimension / 34 | 0, // circular scale height (radial mode)\n  \t\t\t  fontSizeX        = canvasX.height >> 1,\n\t\t\t  fontSizeR        = scaleHeight >> 1,\n\t\t\t  labelWidthX      = fontSizeX * ( _noteLabels ? .7 : 1.5 ),\n\t\t\t  labelWidthR      = fontSizeR * ( _noteLabels ? 1 : 2 ),\n\t\t  \t  root12           = 2 ** ( 1 / 12 );\n\n\t\tif ( ! _noteLabels && ( this._ansiBands || _frequencyScale != SCALE_LOG ) ) {\n\t\t\tfreqLabels.push( 16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3 );\n\t\t\tif ( _frequencyScale == SCALE_LINEAR )\n\t\t\t\tfreqLabels.push( 6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 18e3, 20e3, 22e3 );\n\t\t\telse\n\t\t\t\tfreqLabels.push( 8e3, 16e3 );\n\t\t}\n\t\telse {\n\t\t\tlet freq = C_1;\n\t\t\tfor ( let octave = -1; octave < 11; octave++ ) {\n\t\t\t\tfor ( let note = 0; note < 12; note++ ) {\n\t\t\t\t\tif ( freq >= this._minFreq && freq <= this._maxFreq ) {\n\t\t\t\t\t\tconst pitch = scale[ note ],\n\t\t\t\t\t\t\t  isC   = pitch == 'C';\n\t\t\t\t\t\tif ( ( pitch && _noteLabels && ! _mirror && ! isDualHorizontal ) || isC )\n\t\t\t\t\t\t\tfreqLabels.push( _noteLabels ? [ freq, pitch + ( isC ? octave : '' ) ] : freq );\n\t\t\t\t\t}\n\t\t\t\t\tfreq *= root12;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// in radial dual-vertical layout, the scale is positioned exactly between both channels, by making the canvas a bit larger than the inner diameter\n\t\tcanvasR.width = canvasR.height = Math.max( minDimension * .15, ( innerRadius << 1 ) + ( isDualVertical * scaleHeight ) );\n\n\t\tconst centerR = canvasR.width >> 1,\n\t\t\t  radialY = centerR - scaleHeight * .7;\t// vertical position of text labels in the circular scale\n\n\t\t// helper function\n\t\tconst radialLabel = ( x, label ) => {\n\t\t\tconst angle  = TAU * ( x / canvas.width ),\n\t\t\t\t  adjAng = angle - HALF_PI, // rotate angles so 0 is at the top\n\t\t\t\t  posX   = radialY * Math.cos( adjAng ),\n\t\t\t\t  posY   = radialY * Math.sin( adjAng );\n\n\t\t\t_scaleR.save();\n\t\t\t_scaleR.translate( centerR + posX, centerR + posY );\n\t\t\t_scaleR.rotate( angle );\n\t\t\t_scaleR.fillText( label, 0, 0 );\n\t\t\t_scaleR.restore();\n\t\t}\n\n\t\t// clear scale canvas\n\t\tcanvasX.width |= 0;\n\n\t\t_scaleX.fillStyle = _scaleR.strokeStyle = SCALEX_BACKGROUND_COLOR;\n\t\t_scaleX.fillRect( 0, 0, canvasX.width, canvasX.height );\n\n\t\t_scaleR.arc( centerR, centerR, centerR - scaleHeight / 2, 0, TAU );\n\t\t_scaleR.lineWidth = scaleHeight;\n\t\t_scaleR.stroke();\n\n\t\t_scaleX.fillStyle = _scaleR.fillStyle = SCALEX_LABEL_COLOR;\n\t\t_scaleX.font = `${ fontSizeX }px ${FONT_FAMILY}`;\n\t\t_scaleR.font = `${ fontSizeR }px ${FONT_FAMILY}`;\n\t\t_scaleX.textAlign = _scaleR.textAlign = 'center';\n\n\t\tlet prevX = -labelWidthX / 4,\n\t\t\tprevR = -labelWidthR;\n\n\t\tfor ( const item of freqLabels ) {\n\t\t\tconst [ freq, label ] = Array.isArray( item ) ? item : [ item, item < 1e3 ? item | 0 : `${ ( item / 100 | 0 ) / 10 }k` ],\n\t\t\t\t  x    = unitWidth * ( this._freqScaling( freq ) - scaleMin ),\n\t\t\t\t  y    = canvasX.height * .75,\n\t\t\t\t  isC  = label[0] == 'C',\n\t  \t\t\t  maxW = fontSizeX * ( _noteLabels && ! _mirror && ! isDualHorizontal ? ( isC ? 1.2 : .6 ) : 3 );\n\n\t  \t\t// set label color - no highlight when mirror effect is active (only Cs displayed)\n\t\t\t_scaleX.fillStyle = _scaleR.fillStyle = isC && ! _mirror && ! isDualHorizontal ? SCALEX_HIGHLIGHT_COLOR : SCALEX_LABEL_COLOR;\n\n\t\t\t// prioritizes which note labels are displayed, due to the restricted space on some ranges/scales\n\t\t\tif ( _noteLabels ) {\n\t\t\t\tconst isLog = _frequencyScale == SCALE_LOG,\n\t\t\t\t\t  isLinear = _frequencyScale == SCALE_LINEAR;\n\n\t\t\t\tlet allowedLabels = ['C'];\n\n\t\t\t\tif ( isLog || freq > 2e3 || ( ! isLinear && freq > 250 ) ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 125 || freq > 1e3 ) ) )\n\t\t\t\t\tallowedLabels.push('G');\n\t\t\t\tif ( isLog || freq > 4e3 || ( ! isLinear && freq > 500 ) ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 250 || freq > 2e3 ) ) )\n\t\t\t\t\tallowedLabels.push('E');\n\t\t\t\tif ( isLinear && freq > 4e3 ||\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( isLog || freq > 2e3 || ( ! isLinear && freq > 500 ) ) ) )\n\t\t\t\t\tallowedLabels.push('D','F','A','B');\n\t\t\t\tif ( ! allowedLabels.includes( label[0] ) )\n\t\t\t\t\tcontinue; // skip this label\n\t\t\t}\n\n\t\t\t// linear scale\n\t\t\tif ( x >= prevX + labelWidthX / 2 && x <= analyzerWidth ) {\n\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror == -1 ? analyzerWidth - x : initialX + x, y, maxW );\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthX || _mirror == 1 ) ) )\n\t\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror != 1 ? analyzerWidth + x : ( initialX || canvas.width ) - x, y, maxW );\n\t\t\t\tprevX = x + Math.min( maxW, _scaleX.measureText( label ).width ) / 2;\n\t\t\t}\n\n\t\t\t// radial scale\n\t\t\tif ( x >= prevR + labelWidthR && x < analyzerWidth - labelWidthR ) { // avoid overlapping the last label over the first one\n\t\t\t\tradialLabel( isDualHorizontal && _mirror == 1 ? analyzerWidth - x : x, label );\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthR || _mirror == 1 ) ) ) // avoid overlapping of first labels on mirror mode\n\t\t\t\t\tradialLabel( isDualHorizontal && _mirror != -1 ? analyzerWidth + x : -x, label );\n\t\t\t\tprevR = x;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Redraw the canvas\n\t * this is called 60 times per second by requestAnimationFrame()\n\t */\n\t_draw( timestamp ) {\n\t\t// schedule next canvas update\n\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\n\t\t// frame rate control\n\t\tconst elapsed        = timestamp - this._time, // time since last FPS computation\n\t\t\t  frameTime      = timestamp - this._last, // time since last rendered frame\n\t\t\t  targetInterval = this._maxFPS ? 975 / this._maxFPS : 0; // small tolerance for best results\n\n\t\tif ( frameTime < targetInterval )\n\t\t\treturn;\n\n\t\tthis._last = timestamp - ( targetInterval ? frameTime % targetInterval : 0 ); // thanks https://stackoverflow.com/a/19772220/2370385\n\t\tthis._frames++;\n\n\t\tif ( elapsed >= 1000 ) { // update FPS every second\n\t\t\tthis._fps = this._frames / elapsed * 1000;\n\t\t\tthis._frames = 0;\n\t\t\tthis._time = timestamp;\n\t\t}\n\n\t\t// initialize local constants\n\n\t\tconst { isAlpha,\n\t\t\t    isBands,\n\t\t\t    isLeds,\n\t\t\t    isLumi,\n\t\t\t    isOctaves,\n\t\t\t    isOutline,\n\t\t\t    isRound,\n\t\t\t    noLedGap }     = this._flg,\n\n\t\t\t  { analyzerHeight,\n\t\t\t    centerX,\n\t\t\t    centerY,\n\t\t\t    channelCoords,\n\t\t\t    channelHeight,\n\t\t\t    channelGap,\n\t\t\t    initialX,\n\t\t\t    innerRadius,\n\t\t\t    outerRadius }  = this._aux,\n\n\t\t\t  { _bars,\n\t\t\t    canvas,\n\t\t\t    _canvasGradients,\n\t\t\t    _chLayout,\n\t\t\t    _colorMode,\n\t\t\t    _ctx,\n\t\t\t    _energy,\n\t\t\t    fillAlpha,\n\t\t\t    _fps,\n\t\t\t    _linearAmplitude,\n\t\t\t    _lineWidth,\n\t\t\t    maxDecibels,\n\t\t\t    minDecibels,\n\t\t\t    _mirror,\n\t\t\t    _mode,\n\t\t\t    overlay,\n\t\t\t    _radial,\n\t\t\t    showBgColor,\n\t\t\t    showPeaks,\n\t\t\t    useCanvas,\n\t\t\t    _weightingFilter } = this,\n\n\t\t\t  canvasX          = this._scaleX.canvas,\n\t\t\t  canvasR          = this._scaleR.canvas,\n\t\t\t  holdFrames       = _fps >> 1, // number of frames in half a second\n\t\t\t  isDualCombined   = _chLayout == CHANNEL_COMBINED,\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL,\n\t\t\t  isSingle         = _chLayout == CHANNEL_SINGLE,\n\t\t\t  isTrueLeds       = isLeds && this._trueLeds && _colorMode == COLOR_GRADIENT,\n\t\t\t  analyzerWidth    = _radial ? canvas.width : this._aux.analyzerWidth,\n\t\t\t  finalX           = initialX + analyzerWidth,\n\t\t\t  showPeakLine     = showPeaks && this._peakLine && _mode == MODE_GRAPH,\n\t\t\t  maxBarHeight     = _radial ? outerRadius - innerRadius : analyzerHeight,\n\t\t\t  dbRange \t\t   = maxDecibels - minDecibels,\n\t\t\t  [ ledCount, ledSpaceH, ledSpaceV, ledHeight ] = this._leds || [];\n\n\t\tif ( _energy.val > 0 && _fps > 0 )\n\t\t\tthis._spinAngle += this._spinSpeed * TAU / 60 / _fps; // spinSpeed * angle increment per frame for 1 RPM\n\n\t\t/* HELPER FUNCTIONS */\n\n\t\t// create Reflex effect\n\t\tconst doReflex = channel => {\n\t\t\tif ( this._reflexRatio > 0 && ! isLumi && ! _radial ) {\n\t\t\t\tlet posY, height;\n\t\t\t\tif ( this.reflexFit || isDualVertical ) { // always fit reflex in vertical stereo mode\n\t\t\t\t\tposY   = isDualVertical && channel == 0 ? channelHeight + channelGap : 0;\n\t\t\t\t\theight = channelHeight - analyzerHeight;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposY   = canvas.height - analyzerHeight * 2;\n\t\t\t\t\theight = analyzerHeight;\n\t\t\t\t}\n\n\t\t\t\t_ctx.save();\n\n\t\t\t\t// set alpha and brightness for the reflection\n\t\t\t\t_ctx.globalAlpha = this.reflexAlpha;\n\t\t\t\tif ( this.reflexBright != 1 )\n\t\t\t\t\t_ctx.filter = `brightness(${this.reflexBright})`;\n\n\t\t\t\t// create the reflection\n\t\t\t\t_ctx.setTransform( 1, 0, 0, -1, 0, canvas.height );\n\t\t\t\t_ctx.drawImage( canvas, 0, channelCoords[ channel ].channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height );\n\n\t\t\t\t_ctx.restore();\n\t\t\t}\n\t\t}\n\n\t\t// draw scale on X-axis\n\t\tconst drawScaleX = () => {\n\t\t\tif ( this.showScaleX ) {\n\t\t\t\tif ( _radial ) {\n\t\t\t\t\t_ctx.save();\n\t\t\t\t\t_ctx.translate( centerX, centerY );\n\t\t\t\t\tif ( this._spinSpeed )\n\t\t\t\t\t\t_ctx.rotate( this._spinAngle + HALF_PI );\n\t\t\t\t\t_ctx.drawImage( canvasR, -canvasR.width >> 1, -canvasR.width >> 1 );\n\t\t\t\t\t_ctx.restore();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_ctx.drawImage( canvasX, 0, canvas.height - canvasX.height );\n\t\t\t}\n\t\t}\n\n\t\t// returns the gain (in dB) for a given frequency, considering the currently selected weighting filter\n\t\tconst weightingdB = freq => {\n\t\t\tconst f2 = freq ** 2,\n\t\t\t\t  SQ20_6  = 424.36,\n\t\t\t\t  SQ107_7 = 11599.29,\n\t\t\t\t  SQ158_5 = 25122.25,\n\t\t\t\t  SQ737_9 = 544496.41,\n\t\t\t\t  SQ12194 = 148693636,\n\t\t\t\t  linearTodB = value => 20 * Math.log10( value );\n\n\t\t\tswitch ( _weightingFilter ) {\n\t\t\t\tcase FILTER_A : // A-weighting https://en.wikipedia.org/wiki/A-weighting\n\t\t\t\t\tconst rA = ( SQ12194 * f2 ** 2 ) / ( ( f2 + SQ20_6 ) * Math.sqrt( ( f2 + SQ107_7 ) * ( f2 + SQ737_9 ) ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn 2 + linearTodB( rA );\n\n\t\t\t\tcase FILTER_B :\n\t\t\t\t\tconst rB = ( SQ12194 * f2 * freq ) / ( ( f2 + SQ20_6 ) * Math.sqrt( f2 + SQ158_5 ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn .17 + linearTodB( rB );\n\n\t\t\t\tcase FILTER_C :\n\t\t\t\t\tconst rC = ( SQ12194 * f2 ) / ( ( f2 + SQ20_6 ) * ( f2 + SQ12194 ) );\n\t\t\t\t\treturn .06 + linearTodB( rC );\n\n\t\t\t\tcase FILTER_D :\n\t\t\t\t\tconst h = ( ( 1037918.48 - f2 ) ** 2 + 1080768.16 * f2 ) / ( ( 9837328 - f2 ) ** 2 + 11723776 * f2 ),\n\t\t\t\t\t\t  rD = ( freq / 6.8966888496476e-5 ) * Math.sqrt( h / ( ( f2 + 79919.29 ) * ( f2 + 1345600 ) ) );\n\t\t\t\t\treturn linearTodB( rD );\n\n\t\t\t\tcase FILTER_468 : // ITU-R 468 https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting\n\t\t\t\t\tconst h1 = -4.737338981378384e-24 * freq ** 6 + 2.043828333606125e-15 * freq ** 4 - 1.363894795463638e-7 * f2 + 1,\n\t\t\t\t\t\t  h2 = 1.306612257412824e-19 * freq ** 5 - 2.118150887518656e-11 * freq ** 3 + 5.559488023498642e-4 * freq,\n\t\t\t\t\t\t  rI = 1.246332637532143e-4 * freq / Math.hypot( h1, h2 );\n\t\t\t\t\treturn 18.2 + linearTodB( rI );\n\t\t\t}\n\n\t\t\treturn 0; // unknown filter\n\t\t}\n\n\t\t// draws (stroke) a bar from x,y1 to x,y2\n\t\tconst strokeBar = ( x, y1, y2 ) => {\n\t\t\t_ctx.beginPath();\n\t\t\t_ctx.moveTo( x, y1 );\n\t\t\t_ctx.lineTo( x, y2 );\n\t\t\t_ctx.stroke();\n\t\t}\n\n\t\t// conditionally strokes current path on canvas\n\t\tconst strokeIf = flag => {\n\t\t\tif ( flag && _lineWidth ) {\n\t\t\t\tconst alpha = _ctx.globalAlpha;\n\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t_ctx.stroke();\n\t\t\t\t_ctx.globalAlpha = alpha;\n\t\t\t}\n\t\t}\n\n\t\t// converts a value in [0;1] range to a height in pixels that fits into the current LED elements\n\t\tconst ledPosY = value => Math.max( 0, ( value * ledCount | 0 ) * ( ledHeight + ledSpaceV ) - ledSpaceV );\n\n\t\t// update energy information\n\t\tconst updateEnergy = newVal => {\n\t\t\t_energy.val = newVal;\n\t\t\tif ( _energy.peak > 0 ) {\n\t\t\t\t_energy.hold--;\n\t\t\t\tif ( _energy.hold < 0 )\n\t\t\t\t\t_energy.peak += _energy.hold / ( holdFrames * holdFrames / 2 );\n\t\t\t}\n\t\t\tif ( newVal >= _energy.peak ) {\n\t\t\t\t_energy.peak = newVal;\n\t\t\t\t_energy.hold = holdFrames;\n\t\t\t}\n\t\t}\n\n\t\t/* MAIN FUNCTION */\n\n\t\tif ( overlay )\n\t\t\t_ctx.clearRect( 0, 0, canvas.width, canvas.height );\n\n\t\tlet currentEnergy = 0;\n\n\t\tconst nBars     = _bars.length,\n\t\t\t  nChannels = isSingle ? 1 : 2;\n\n\t\tfor ( let channel = 0; channel < nChannels; channel++ ) {\n\n\t\t\tconst { channelTop, channelBottom, analyzerBottom } = channelCoords[ channel ],\n\t\t\t\t  channelGradient  = this._gradients[ this._selectedGrads[ channel ] ],\n\t\t\t\t  colorStops       = channelGradient.colorStops,\n\t\t\t\t  colorCount       = colorStops.length,\n\t\t\t\t  bgColor          = ( ! showBgColor || isLeds && ! overlay ) ? '#000' : channelGradient.bgColor,\n\t\t\t\t  radialDirection  = isDualVertical && _radial && channel ? -1 : 1, // 1 = outwards, -1 = inwards\n\t\t\t\t  invertedChannel  = ( ! channel && _mirror == -1 ) || ( channel && _mirror == 1 ),\n\t\t\t\t  radialOffsetX    = ! isDualHorizontal || ( channel && _mirror != 1 ) ? 0 : analyzerWidth >> ( channel || ! invertedChannel ),\n\t\t\t\t  angularDirection = isDualHorizontal && invertedChannel ? -1 : 1;  // 1 = clockwise, -1 = counterclockwise\n/*\n\t\t\tExpanded logic for radialOffsetX and angularDirection:\n\n\t\t\tlet radialOffsetX = 0,\n\t\t\t\tangularDirection = 1;\n\n\t\t\tif ( isDualHorizontal ) {\n\t\t\t\tif ( channel == 0 ) { // LEFT channel\n\t\t\t\t\tif ( _mirror == -1 ) {\n\t\t\t\t\t\tradialOffsetX = analyzerWidth;\n\t\t\t\t\t\tangularDirection = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\n\t\t\t\t}\n\t\t\t\telse {                // RIGHT channel\n\t\t\t\t\tif ( _mirror == 1 ) {\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\n\t\t\t\t\t\tangularDirection = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n*/\n\t\t\t// draw scale on Y-axis (uses: channel, channelTop)\n\t\t\tconst drawScaleY = () => {\n\t\t\t\tconst scaleWidth = canvasX.height,\n\t\t\t\t\t  fontSize   = scaleWidth >> 1,\n\t\t\t\t\t  max        = _linearAmplitude ? 100 : maxDecibels,\n\t\t\t\t\t  min        = _linearAmplitude ? 0 : minDecibels,\n\t\t\t\t\t  incr       = _linearAmplitude ? 20 : 5,\n\t\t\t\t\t  interval   = analyzerHeight / ( max - min ),\n\t\t\t\t\t  atStart    = _mirror != -1 && ( ! isDualHorizontal || channel == 0 || _mirror == 1 ),\n\t\t\t\t\t  atEnd      = _mirror != 1 && ( ! isDualHorizontal || channel != _mirror );\n\n\t\t\t\t_ctx.save();\n\t\t\t\t_ctx.fillStyle = SCALEY_LABEL_COLOR;\n\t\t\t\t_ctx.font = `${fontSize}px ${FONT_FAMILY}`;\n\t\t\t\t_ctx.textAlign = 'right';\n\t\t\t\t_ctx.lineWidth = 1;\n\n\t\t\t\tfor ( let val = max; val > min; val -= incr ) {\n\t\t\t\t\tconst posY = channelTop + ( max - val ) * interval,\n\t\t\t\t\t\t  even = ( val % 2 == 0 ) | 0;\n\n\t\t\t\t\tif ( even ) {\n\t\t\t\t\t\tconst labelY = posY + fontSize * ( posY == channelTop ? .8 : .35 );\n\t\t\t\t\t\tif ( atStart )\n\t\t\t\t\t\t\t_ctx.fillText( val, scaleWidth * .85, labelY );\n\t\t\t\t\t\tif ( atEnd )\n\t\t\t\t\t\t\t_ctx.fillText( val, ( isDualHorizontal ? analyzerWidth : canvas.width ) - scaleWidth * .1, labelY );\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_LABEL_COLOR;\n\t\t\t\t\t\t_ctx.setLineDash([2,4]);\n\t\t\t\t\t\t_ctx.lineDashOffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_MIDLINE_COLOR;\n\t\t\t\t\t\t_ctx.setLineDash([2,8]);\n\t\t\t\t\t\t_ctx.lineDashOffset = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t_ctx.moveTo( initialX + scaleWidth * even * atStart, ~~posY + .5 ); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\n\t\t\t\t\t_ctx.lineTo( finalX - scaleWidth * even * atEnd, ~~posY + .5 );\n\t\t\t\t\t_ctx.stroke();\n\t\t\t\t}\n\t\t\t\t_ctx.restore();\n\t\t\t}\n\n\t\t\t// FFT bin data interpolation (uses fftData)\n\t\t\tconst interpolate = ( bin, ratio ) => {\n\t\t\t\tconst value = fftData[ bin ] + ( bin < fftData.length - 1 ? ( fftData[ bin + 1 ] - fftData[ bin ] ) * ratio : 0 );\n\t\t\t\treturn isNaN( value ) ? -Infinity : value;\n\t\t\t}\n\n\t\t\t// converts a given X-coordinate to its corresponding angle in radial mode (uses angularDirection)\n\t\t\tconst getAngle = ( x, dir = angularDirection ) => dir * TAU * ( ( x + radialOffsetX ) / canvas.width ) + this._spinAngle;\n\n\t\t\t// converts planar X,Y coordinates to radial coordinates (uses: getAngle(), radialDirection)\n\t\t\tconst radialXY = ( x, y, dir ) => {\n\t\t\t\tconst height = innerRadius + y * radialDirection,\n\t\t\t\t\t  angle  = getAngle( x, dir );\n\t\t\t\treturn [ centerX + height * Math.cos( angle ), centerY + height * Math.sin( angle ) ];\n\t\t\t}\n\n\t\t\t// draws a polygon of width `w` and height `h` at (x,y) in radial mode (uses: angularDirection, radialDirection)\n\t\t\tconst radialPoly = ( x, y, w, h, stroke ) => {\n\t\t\t\t_ctx.beginPath();\n\t\t\t\tfor ( const dir of ( _mirror && ! isDualHorizontal ? [1,-1] : [ angularDirection ] ) ) {\n\t\t\t\t\tconst [ startAngle, endAngle ] = isRound ? [ getAngle( x, dir ), getAngle( x + w, dir ) ] : [];\n\t\t\t\t\t_ctx.moveTo( ...radialXY( x, y, dir ) );\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x, y + h, dir ) );\n\t\t\t\t\tif ( isRound )\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + ( y + h ) * radialDirection, startAngle, endAngle, dir != 1 );\n\t\t\t\t\telse\n\t\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y + h, dir ) );\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y, dir ) );\n\t\t\t\t\tif ( isRound && ! stroke ) // close the bottom line only when not in outline mode\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + y * radialDirection, endAngle, startAngle, dir == 1 );\n\t\t\t\t}\n\t\t\t\tstrokeIf( stroke );\n\t\t\t\t_ctx.fill();\n\t\t\t}\n\n\t\t\t// set fillStyle and strokeStyle according to current colorMode (uses: channel, colorStops, colorCount)\n\t\t\tconst setBarColor = ( value = 0, barIndex = 0 ) => {\n\t\t\t\tlet color;\n\t\t\t\t// for graph mode, always use the channel gradient (ignore colorMode)\n\t\t\t\tif ( ( _colorMode == COLOR_GRADIENT && ! isTrueLeds ) || _mode == MODE_GRAPH )\n\t\t\t\t\tcolor = _canvasGradients[ channel ];\n\t\t\t\telse {\n\t\t\t\t\tconst selectedIndex = _colorMode == COLOR_BAR_INDEX ? barIndex % colorCount : colorStops.findLastIndex( item => isLeds ? ledPosY( value ) <= ledPosY( item.level ) : value <= item.level );\n\t\t\t\t\tcolor = colorStops[ selectedIndex ].color;\n\t\t\t\t}\n\t\t\t\t_ctx.fillStyle = _ctx.strokeStyle = color;\n\t\t\t}\n\n\t\t\t// CHANNEL START\n\n\t\t\tif ( useCanvas ) {\n\t\t\t\t// set transform (horizontal flip and translation) for dual-horizontal layout\n\t\t\t\tif ( isDualHorizontal && ! _radial ) {\n\t\t\t\t  \tconst translateX = analyzerWidth * ( channel + invertedChannel ),\n\t\t\t\t  \t\t  flipX      = invertedChannel ? -1 : 1;\n\n\t\t\t\t\t_ctx.setTransform( flipX, 0, 0, 1, translateX, 0 );\n\t\t\t\t}\n\n\t\t\t\t// fill the analyzer background if needed (not overlay or overlay + showBgColor)\n\t\t\t\tif ( ! overlay || showBgColor ) {\n\t\t\t\t\tif ( overlay )\n\t\t\t\t\t\t_ctx.globalAlpha = this.bgAlpha;\n\n\t\t\t\t\t_ctx.fillStyle = bgColor;\n\n\t\t\t\t\t// exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\n\t\t\t\t\tif ( channel == 0 || ( ! _radial && ! isDualCombined ) )\n\t\t\t\t\t\t_ctx.fillRect( initialX, channelTop - channelGap, analyzerWidth, ( overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight ) + channelGap );\n\n\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t}\n\n\t\t\t\t// draw dB scale (Y-axis) - avoid drawing it twice on 'dual-combined' channel layout\n\t\t\t\tif ( this.showScaleY && ! isLumi && ! _radial && ( channel == 0 || ! isDualCombined ) )\n\t\t\t\t\tdrawScaleY();\n\n\t\t\t\t// set line width and dash for LEDs effect\n\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t_ctx.setLineDash( [ ledHeight, ledSpaceV ] );\n\t\t\t\t\t_ctx.lineWidth = _bars[0].width;\n\t\t\t\t}\n\t\t\t\telse // for outline effect ensure linewidth is not greater than half the bar width\n\t\t\t\t\t_ctx.lineWidth = isOutline ? Math.min( _lineWidth, _bars[0].width / 2 ) : _lineWidth;\n\n\t\t\t\t// set clipping region\n\t\t\t\t_ctx.save();\n\t\t\t\tif ( ! _radial ) {\n\t\t\t\t\tconst region = new Path2D();\n\t\t\t\t\tregion.rect( 0, channelTop, canvas.width, analyzerHeight );\n\t\t\t\t\t_ctx.clip( region );\n\t\t\t\t}\n\n\t\t\t} // if ( useCanvas )\n\n\t\t\t// get a new array of data from the FFT\n\t\t\tlet fftData = this._fftData[ channel ];\n\t\t\tthis._analyzer[ channel ].getFloatFrequencyData( fftData );\n\n\t\t\t// apply weighting\n\t\t\tif ( _weightingFilter )\n\t\t\t\tfftData = fftData.map( ( val, idx ) => val + weightingdB( this._binToFreq( idx ) ) );\n\n\t\t\t// start drawing path (for graph mode)\n\t\t\t_ctx.beginPath();\n\n\t\t\t// store line graph points to create mirror effect in radial mode\n\t\t\tlet points = [];\n\n\t\t\t// draw bars / lines\n\n\t\t\tfor ( let barIndex = 0; barIndex < nBars; barIndex++ ) {\n\n\t\t\t\tconst bar = _bars[ barIndex ],\n\t\t\t\t\t  { posX, barCenter, width, freq, binLo, binHi, ratioLo, ratioHi } = bar;\n\n\t\t\t\tlet barValue = Math.max( interpolate( binLo, ratioLo ), interpolate( binHi, ratioHi ) );\n\n\t\t\t\t// check additional bins (if any) for this bar and keep the highest value\n\t\t\t\tfor ( let j = binLo + 1; j < binHi; j++ ) {\n\t\t\t\t\tif ( fftData[ j ] > barValue )\n\t\t\t\t\t\tbarValue = fftData[ j ];\n\t\t\t\t}\n\n\t\t\t\t// normalize bar amplitude in [0;1] range\n\t\t\t\tbarValue = this._normalizedB( barValue );\n\n\t\t\t\tbar.value[ channel ] = barValue;\n\t\t\t\tcurrentEnergy += barValue;\n\n\t\t\t\t// update bar peak\n\t\t\t\tif ( bar.peak[ channel ] > 0 ) {\n\t\t\t\t\tbar.hold[ channel ]--;\n\t\t\t\t\t// if hold is negative, it becomes the \"acceleration\" for peak drop\n\t\t\t\t\tif ( bar.hold[ channel ] < 0 )\n\t\t\t\t\t\tbar.peak[ channel ] += bar.hold[ channel ] / ( holdFrames * holdFrames / 2 );\n\t\t\t\t}\n\n\t\t\t\t// check if it's a new peak for this bar\n\t\t\t\tif ( barValue >= bar.peak[ channel ] ) {\n\t\t\t\t\tbar.peak[ channel ] = barValue;\n\t\t\t\t\tbar.hold[ channel ] = holdFrames;\n\t\t\t\t}\n\n\t\t\t\t// if not using the canvas, move earlier to the next bar\n\t\t\t\tif ( ! useCanvas )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// set opacity for bar effects\n\t\t\t\tif ( isLumi || isAlpha )\n\t\t\t\t\t_ctx.globalAlpha = barValue;\n\t\t\t\telse if ( isOutline )\n\t\t\t\t\t_ctx.globalAlpha = fillAlpha;\n\n\t\t\t\t// set fillStyle and strokeStyle for the current bar\n\t\t\t\tsetBarColor( barValue, barIndex );\n\n\t\t\t\t// compute actual bar height on screen\n\t\t\t\tconst barHeight = isLumi ? maxBarHeight : isLeds ? ledPosY( barValue ) : barValue * maxBarHeight | 0;\n\n\t\t\t\t// Draw current bar or line segment\n\n\t\t\t\tif ( _mode == MODE_GRAPH ) {\n\t\t\t\t\t// compute the average between the initial bar (barIndex==0) and the next one\n\t\t\t\t\t// used to smooth the curve when the initial posX is off the screen, in mirror and radial modes\n\t\t\t\t\tconst nextBarAvg = barIndex ? 0 : ( this._normalizedB( fftData[ _bars[1].binLo ] ) * maxBarHeight + barHeight ) / 2;\n\n\t\t\t\t\tif ( _radial ) {\n\t\t\t\t\t\tif ( barIndex == 0 ) {\n\t\t\t\t\t\t\tif ( isDualHorizontal )\n\t\t\t\t\t\t\t\t_ctx.moveTo( ...radialXY( 0, 0 ) );\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( 0, ( posX < 0 ? nextBarAvg : barHeight ) ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to the current point, avoiding overlapping wrap-around frequencies\n\t\t\t\t\t\tif ( posX >= 0 ) {\n\t\t\t\t\t\t\tconst point = [ posX, barHeight ];\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...point ) );\n\t\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // Linear\n\t\t\t\t\t\tif ( barIndex == 0 ) {\n\t\t\t\t\t\t\t// start the line off-screen using the previous FFT bin value as the initial amplitude\n\t\t\t\t\t\t\tif ( _mirror == -1 && ! isDualHorizontal )\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX, analyzerBottom - ( posX < initialX ? nextBarAvg : barHeight ) );\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst prevFFTData = binLo ? this._normalizedB( fftData[ binLo - 1 ] ) * maxBarHeight : barHeight; // use previous FFT bin value, when available\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX - _lineWidth, analyzerBottom - prevFFTData );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to the current point\n\t\t\t\t\t\t// avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy\n\t\t\t\t\t\tif ( isDualHorizontal || _mirror != -1 || posX >= initialX )\n\t\t\t\t\t\t\t_ctx.lineTo( posX, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t\t// draw \"unlit\" leds - avoid drawing it twice on 'dual-combined' channel layout\n\t\t\t\t\t\tif ( showBgColor && ! overlay && ( channel == 0 || ! isDualCombined ) ) {\n\t\t\t\t\t\t\tconst alpha = _ctx.globalAlpha;\n\t\t\t\t\t\t\t_ctx.strokeStyle = LEDS_UNLIT_COLOR;\n\t\t\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t\t\t\tstrokeBar( barCenter, channelTop, analyzerBottom );\n\t\t\t\t\t\t\t// restore properties\n\t\t\t\t\t\t\t_ctx.strokeStyle = _ctx.fillStyle;\n\t\t\t\t\t\t\t_ctx.globalAlpha = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( isTrueLeds ) {\n\t\t\t\t\t\t\t// ledPosY() is used below to fit one entire led height into the selected range\n\t\t\t\t\t\t\tconst colorIndex = isLumi ? 0 : colorStops.findLastIndex( item => ledPosY( barValue ) <= ledPosY( item.level ) );\n\t\t\t\t\t\t\tlet last = analyzerBottom;\n\t\t\t\t\t\t\tfor ( let i = colorCount - 1; i >= colorIndex; i-- ) {\n\t\t\t\t\t\t\t\t_ctx.strokeStyle = colorStops[ i ].color;\n\t\t\t\t\t\t\t\tlet y = analyzerBottom - ( i == colorIndex ? barHeight : ledPosY( colorStops[ i ].level ) );\n\t\t\t\t\t\t\t\tstrokeBar( barCenter, last, y );\n\t\t\t\t\t\t\t\tlast = y - ledSpaceV;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstrokeBar( barCenter, analyzerBottom, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( posX >= initialX ) {\n\t\t\t\t\t\tif ( _radial )\n\t\t\t\t\t\t\tradialPoly( posX, 0, width, barHeight, isOutline );\n\t\t\t\t\t\telse if ( isRound ) {\n\t\t\t\t\t\t\tconst halfWidth = width / 2,\n\t\t\t\t\t\t\t\t  y = analyzerBottom + halfWidth; // round caps have an additional height of half bar width\n\n\t\t\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t\t\t_ctx.moveTo( posX, y );\n\t\t\t\t\t\t\t_ctx.lineTo( posX, y - barHeight );\n\t\t\t\t\t\t\t_ctx.arc( barCenter, y - barHeight, halfWidth, PI, TAU );\n\t\t\t\t\t\t\t_ctx.lineTo( posX + width, y );\n\t\t\t\t\t\t\tstrokeIf( isOutline );\n\t\t\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst offset = isOutline ? _ctx.lineWidth : 0;\n\t\t\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t\t\t_ctx.rect( posX, analyzerBottom + offset, width, -barHeight - offset );\n\t\t\t\t\t\t\tstrokeIf( isOutline );\n\t\t\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Draw peak\n\t\t\t\tconst peak = bar.peak[ channel ];\n\t\t\t\tif ( peak > 0 && showPeaks && ! showPeakLine && ! isLumi && posX >= initialX && posX < finalX ) {\n\t\t\t\t\t// set opacity\n\t\t\t\t\tif ( isOutline && _lineWidth > 0 )\n\t\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t\telse if ( isAlpha )\n\t\t\t\t\t\t_ctx.globalAlpha = peak;\n\n\t\t\t\t\t// select the peak color for 'bar-level' colorMode or 'trueLeds'\n\t\t\t\t\tif ( _colorMode == COLOR_BAR_LEVEL || isTrueLeds )\n\t\t\t\t\t\tsetBarColor( peak );\n\n\t\t\t\t\t// render peak according to current mode / effect\n\t\t\t\t\tif ( isLeds ) {\n\t\t\t\t\t\tconst ledPeak = ledPosY( peak );\n\t\t\t\t\t\tif ( ledPeak >= ledSpaceV ) // avoid peak below first led\n\t\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - ledPeak, width, ledHeight );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( ! _radial )\n\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - peak * maxBarHeight, width, 2 );\n\t\t\t\t\telse if ( _mode != MODE_GRAPH ) { // radial (peaks for graph mode are done by the peakLine code)\n\t\t\t\t\t\tconst y = peak * maxBarHeight;\n\t\t\t\t\t\tradialPoly( posX, y, width, ! this._radialInvert || isDualVertical || y + innerRadius >= 2 ? -2 : 2 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} // for ( let barIndex = 0; barIndex < nBars; barIndex++ )\n\n\t\t\t// if not using the canvas, move earlier to the next channel\n\t\t\tif ( ! useCanvas )\n\t\t\t\tcontinue;\n\n\t\t\t// restore global alpha\n\t\t\t_ctx.globalAlpha = 1;\n\n\t\t\t// Fill/stroke drawing path for graph mode\n\t\t\tif ( _mode == MODE_GRAPH ) {\n\t\t\t\tsetBarColor(); // select channel gradient\n\n\t\t\t\tif ( _radial && ! isDualHorizontal ) {\n\t\t\t\t\tif ( _mirror ) {\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\twhile ( p = points.pop() )\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) );\n\t\t\t\t\t}\n\t\t\t\t\t_ctx.closePath();\n\t\t\t\t}\n\n\t\t\t\tif ( _lineWidth > 0 )\n\t\t\t\t\t_ctx.stroke();\n\n\t\t\t\tif ( fillAlpha > 0 ) {\n\t\t\t\t\tif ( _radial ) {\n\t\t\t\t\t\t// exclude the center circle from the fill area\n\t\t\t\t\t\tconst start = isDualHorizontal ? getAngle( analyzerWidth >> 1 ) : 0,\n\t\t\t\t\t\t\t  end   = isDualHorizontal ? getAngle( analyzerWidth ) : TAU;\n\t\t\t\t\t\t_ctx.moveTo( ...radialXY( isDualHorizontal ? analyzerWidth >> 1 : 0, 0 ) );\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius, start, end, isDualHorizontal ? ! invertedChannel : true );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// close the fill area\n\t\t\t\t\t\t_ctx.lineTo( finalX, analyzerBottom );\n\t\t\t\t\t\t_ctx.lineTo( initialX, analyzerBottom );\n\t\t\t\t\t}\n\n\t\t\t\t\t_ctx.globalAlpha = fillAlpha;\n\t\t\t\t\t_ctx.fill();\n\t\t\t\t\t_ctx.globalAlpha = 1;\n\t\t\t\t}\n\n\t\t\t\t// draw peak line (and standard peaks on radial)\n\t\t\t\tif ( showPeakLine || ( _radial && showPeaks ) ) {\n\t\t\t\t\tpoints = []; // for mirror line on radial\n\t\t\t\t\t_ctx.beginPath();\n\t\t\t\t\t_bars.forEach( ( b, i ) => {\n\t\t\t\t\t\tlet x = b.posX,\n\t\t\t\t\t\t\th = b.peak[ channel ],\n\t\t\t\t\t\t\tm = i ? 'lineTo' : 'moveTo';\n\t\t\t\t\t\tif ( _radial && x < 0 ) {\n\t\t\t\t\t\t\tconst nextBar = _bars[ i + 1 ];\n\t\t\t\t\t\t\th = findY( x, h, nextBar.posX, nextBar.peak[ channel ], 0 );\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th *= maxBarHeight;\n\t\t\t\t\t\tif ( showPeakLine ) {\n\t\t\t\t\t\t\t_ctx[ m ]( ...( _radial ? radialXY( x, h ) : [ x, analyzerBottom - h ] ) );\n\t\t\t\t\t\t\tif ( _radial && _mirror && ! isDualHorizontal )\n\t\t\t\t\t\t\t\tpoints.push( [ x, h ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( h > 0 )\n\t\t\t\t\t\t\tradialPoly( x, h, 1, -2 ); // standard peaks (also does mirror)\n\t\t\t\t\t});\n\t\t\t\t\tif ( showPeakLine ) {\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\twhile ( p = points.pop() )\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) ); // mirror line points\n\t\t\t\t\t\t_ctx.lineWidth = 1;\n\t\t\t\t\t\t_ctx.stroke(); // stroke peak line\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_ctx.restore(); // restore clip region\n\n\t\t\tif ( isDualHorizontal && ! _radial )\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t\t\t// create Reflex effect - for dual-combined and dual-horizontal do it only once, after channel 1\n\t\t\tif ( ( ! isDualHorizontal && ! isDualCombined ) || channel )\n\t\t\t\tdoReflex( channel );\n\n\t\t} // for ( let channel = 0; channel < nChannels; channel++ ) {\n\n\t\tupdateEnergy( currentEnergy / ( nBars << ( nChannels - 1 ) ) );\n\n\t\tif ( useCanvas ) {\n\t\t\t// Mirror effect\n\t\t\tif ( _mirror && ! _radial && ! isDualHorizontal ) {\n\t\t\t\t_ctx.setTransform( -1, 0, 0, 1, canvas.width - initialX, 0 );\n\t\t\t\t_ctx.drawImage( canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height );\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\t\t}\n\n\t\t\t// restore solid lines\n\t\t\t_ctx.setLineDash([]);\n\n\t\t\t// draw frequency scale (X-axis)\n\t\t\tdrawScaleX();\n\t\t}\n\n\t\t// display current frame rate\n\t\tif ( this.showFPS ) {\n\t\t\tconst size = canvasX.height;\n\t\t\t_ctx.font = `bold ${size}px ${FONT_FAMILY}`;\n\t\t\t_ctx.fillStyle = FPS_COLOR;\n\t\t\t_ctx.textAlign = 'right';\n\t\t\t_ctx.fillText( Math.round( _fps ), canvas.width - size, size * 2 );\n\t\t}\n\n\t\t// call callback function, if defined\n\t\tif ( this.onCanvasDraw ) {\n\t\t\t_ctx.save();\n\t\t\t_ctx.fillStyle = _ctx.strokeStyle = _canvasGradients[0];\n\t\t\tthis.onCanvasDraw( this, { timestamp, canvasGradients: _canvasGradients } );\n\t\t\t_ctx.restore();\n\t\t}\n\t}\n\n\t/**\n\t * Return scaled frequency according to the selected scale\n\t */\n\t_freqScaling( freq ) {\n\t\tswitch ( this._frequencyScale ) {\n\t\t\tcase SCALE_LOG :\n\t\t\t\treturn Math.log2( freq );\n\t\t\tcase SCALE_BARK :\n\t\t\t\treturn ( 26.81 * freq ) / ( 1960 + freq ) - .53;\n\t\t\tcase SCALE_MEL :\n\t\t\t\treturn Math.log2( 1 + freq / 700 );\n\t\t\tcase SCALE_LINEAR :\n\t\t\t\treturn freq;\n\t\t}\n\t}\n\n\t/**\n\t * Return the FFT data bin (array index) which represents a given frequency\n\t */\n\t_freqToBin( freq, method = 'round' ) {\n\t\tconst max = this._analyzer[0].frequencyBinCount - 1,\n\t\t\t  bin = Math[ method ]( freq * this.fftSize / this.audioCtx.sampleRate );\n\n\t\treturn bin < max ? bin : max;\n\t}\n\n\t/**\n\t * Generate currently selected gradient\n\t */\n\t_makeGrad() {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { canvas, _ctx, _radial, _reflexRatio } = this,\n\t\t\t  { analyzerWidth, centerX, centerY, initialX, innerRadius, outerRadius } = this._aux,\n\t\t\t  { isLumi }     = this._flg,\n\t\t\t  isDualVertical = this._chLayout == CHANNEL_VERTICAL,\n\t\t\t  analyzerRatio  = 1 - _reflexRatio,\n\t\t\t  gradientHeight = isLumi ? canvas.height : canvas.height * ( 1 - _reflexRatio * ( ! isDualVertical ) ) | 0;\n\t\t\t  \t\t\t\t   // for vertical stereo we keep the full canvas height and handle the reflex areas while generating the color stops\n\n\t\tfor ( const channel of [0,1] ) {\n\t\t\tconst currGradient = this._gradients[ this._selectedGrads[ channel ] ],\n\t\t\t\t  colorStops   = currGradient.colorStops,\n\t\t\t\t  isHorizontal = currGradient.dir == 'h';\n\n\t\t\tlet grad;\n\n\t\t\tif ( _radial )\n\t\t\t\tgrad = _ctx.createRadialGradient( centerX, centerY, outerRadius, centerX, centerY, innerRadius - ( outerRadius - innerRadius ) * isDualVertical );\n\t\t\telse\n\t\t\t\tgrad = _ctx.createLinearGradient( ...( isHorizontal ? [ initialX, 0, initialX + analyzerWidth, 0 ] : [ 0, 0, 0, gradientHeight ] ) );\n\n\t\t\tif ( colorStops ) {\n\t\t\t\tconst dual = isDualVertical && ! this._splitGradient && ( ! isHorizontal || _radial );\n\n\t\t\t\tfor ( let channelArea = 0; channelArea < 1 + dual; channelArea++ ) {\n\t\t\t\t\tconst maxIndex = colorStops.length - 1;\n\n\t\t\t\t\tcolorStops.forEach( ( colorStop, index ) => {\n\t\t\t\t\t\tlet offset = colorStop.pos;\n\n\t\t\t\t\t\t// in dual mode (not split), use half the original offset for each channel\n\t\t\t\t\t\tif ( dual )\n\t\t\t\t\t\t\toffset /= 2;\n\n\t\t\t\t\t\t// constrain the offset within the useful analyzer areas (avoid reflex areas)\n\t\t\t\t\t\tif ( isDualVertical && ! isLumi && ! _radial && ! isHorizontal ) {\n\t\t\t\t\t\t\toffset *= analyzerRatio;\n\t\t\t\t\t\t\t// skip the first reflex area in split mode\n\t\t\t\t\t\t\tif ( ! dual && offset > .5 * analyzerRatio )\n\t\t\t\t\t\t\t\toffset += .5 * _reflexRatio;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only for dual-vertical non-split gradient (creates full gradient on both halves of the canvas)\n\t\t\t\t\t\tif ( channelArea == 1 ) {\n\t\t\t\t\t\t\t// add colors in reverse order if radial or lumi are active\n\t\t\t\t\t\t\tif ( _radial || isLumi ) {\n\t\t\t\t\t\t\t\tconst revIndex = maxIndex - index;\n\t\t\t\t\t\t\t\tcolorStop = colorStops[ revIndex ];\n\t\t\t\t\t\t\t\toffset = 1 - colorStop.pos / 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\n\t\t\t\t\t\t\t\tif ( index == 0 && offset > 0 )\n\t\t\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\n\t\t\t\t\t\t\t\t// bump the offset to the second half of the gradient\n\t\t\t\t\t\t\t\toffset += .5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// add gradient color stop\n\t\t\t\t\t\tgrad.addColorStop( offset, colorStop.color );\n\n\t\t\t\t\t\t// create additional color stop at the end of first channel to prevent bleeding\n\t\t\t\t\t\tif ( isDualVertical && index == maxIndex && offset < .5 )\n\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\n\t\t\t\t\t});\n\t\t\t\t} // for ( let channelArea = 0; channelArea < 1 + dual; channelArea++ )\n\t\t\t}\n\n\t\t\tthis._canvasGradients[ channel ] = grad;\n\t\t} // for ( const channel of [0,1] )\n\t}\n\n\t/**\n\t * Normalize a dB value in the [0;1] range\n\t */\n\t_normalizedB( value ) {\n\t\tconst isLinear   = this._linearAmplitude,\n\t\t\t  boost      = isLinear ? 1 / this._linearBoost : 1,\n\t\t\t  clamp      = ( val, min, max ) => val <= min ? min : val >= max ? max : val,\n\t\t\t  dBToLinear = val => 10 ** ( val / 20 );\n\n\t\tlet maxValue = this.maxDecibels,\n\t\t\tminValue = this.minDecibels;\n\n\t\tif ( isLinear ) {\n\t\t\tmaxValue = dBToLinear( maxValue );\n\t\t\tminValue = dBToLinear( minValue );\n\t\t\tvalue = dBToLinear( value ) ** boost;\n\t\t}\n\n\t\treturn clamp( ( value - minValue ) / ( maxValue - minValue ) ** boost, 0, 1 );\n\t}\n\n\t/**\n\t * Internal function to change canvas dimensions on demand\n\t */\n\t_setCanvas( reason ) {\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst { canvas, _ctx } = this,\n\t\t\t  canvasX    = this._scaleX.canvas,\n\t\t\t  pixelRatio = window.devicePixelRatio / ( this._loRes + 1 );\n\n\t\tlet screenWidth  = window.screen.width  * pixelRatio,\n\t\t\tscreenHeight = window.screen.height * pixelRatio;\n\n\t\t// Fix for iOS Safari - swap width and height when in landscape\n\t\tif ( Math.abs( window.orientation ) == 90 && screenWidth < screenHeight )\n\t\t\t[ screenWidth, screenHeight ] = [ screenHeight, screenWidth ];\n\n\t\tconst isFullscreen = this.isFullscreen,\n\t\t\t  isCanvasFs   = isFullscreen && this._fsEl == canvas,\n\t\t\t  newWidth     = isCanvasFs ? screenWidth  : ( this._width  || this._container.clientWidth  || this._defaultWidth  ) * pixelRatio | 0,\n\t\t\t  newHeight    = isCanvasFs ? screenHeight : ( this._height || this._container.clientHeight || this._defaultHeight ) * pixelRatio | 0;\n\n\t\t// set/update object properties\n\t\tthis._pixelRatio = pixelRatio;\n\t\tthis._fsWidth    = screenWidth;\n\t\tthis._fsHeight   = screenHeight;\n\n\t\t// if this is not the constructor call and canvas dimensions haven't changed, quit\n\t\tif ( reason != REASON_CREATE && canvas.width == newWidth && canvas.height == newHeight )\n\t\t\treturn;\n\n\t\t// apply new dimensions\n\t\tcanvas.width  = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\t// if not in overlay mode, paint the canvas black\n\t\tif ( ! this.overlay ) {\n\t\t\t_ctx.fillStyle = '#000';\n\t\t\t_ctx.fillRect( 0, 0, newWidth, newHeight );\n\t\t}\n\n\t\t// set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\n\t\t_ctx.lineJoin = 'bevel';\n\n\t\t// update dimensions of the scale canvas\n\t\tcanvasX.width = newWidth;\n\t\tcanvasX.height = Math.max( 20 * pixelRatio, Math.min( newWidth, newHeight ) / 32 | 0 );\n\n\t\t// calculate bar positions and led options\n\t\tthis._calcBars();\n\n\t\t// (re)generate gradient\n\t\tthis._makeGrad();\n\n\t\t// detect fullscreen changes (for Safari)\n\t\tif ( this._fsStatus !== undefined && this._fsStatus !== isFullscreen )\n\t\t\treason = REASON_FSCHANGE;\n\t\tthis._fsStatus = isFullscreen;\n\n\t\t// call the callback function, if defined\n\t\tif ( this.onCanvasResize )\n\t\t\tthis.onCanvasResize( reason, this );\n\t}\n\n\t/**\n\t * Select a gradient for one or both channels\n\t *\n\t * @param {string} name gradient name\n\t * @param [{number}] desired channel (0 or 1) - if empty or invalid, sets both channels\n\t */\n\t_setGradient( name, channel ) {\n\t\tif ( ! this._gradients.hasOwnProperty( name ) )\n\t\t\tthrow new AudioMotionError( ERR_UNKNOWN_GRADIENT, name );\n\n\t\tif ( ! [0,1].includes( channel ) ) {\n\t\t\tthis._selectedGrads[1] = name;\n\t\t\tchannel = 0;\n\t\t}\n\n\t\tthis._selectedGrads[ channel ] = name;\n\t\tthis._makeGrad();\n\t}\n\n\t/**\n\t * Set object properties\n\t */\n\t_setProps( options, useDefaults ) {\n\t\t// callback functions properties\n\t\tconst callbacks = [ 'onCanvasDraw', 'onCanvasResize' ];\n\n\t\t// properties not in the defaults (`stereo` is deprecated)\n\t\tconst extraProps = [ 'gradientLeft', 'gradientRight', 'stereo' ];\n\n\t\t// build an array of valid properties; `start` is not an actual property and is handled after setting everything else\n\t\tconst validProps = Object.keys( DEFAULT_SETTINGS ).filter( e => e != 'start' ).concat( callbacks, extraProps );\n\n\t\tif ( useDefaults || options === undefined )\n\t\t\toptions = { ...DEFAULT_SETTINGS, ...options }; // merge options with defaults\n\n\t\tfor ( const prop of Object.keys( options ) ) {\n\t\t\tif ( callbacks.includes( prop ) && typeof options[ prop ] !== 'function' ) // check invalid callback\n\t\t\t\tthis[ prop ] = undefined;\n\t\t\telse if ( validProps.includes( prop ) ) // set only valid properties\n\t\t\t\tthis[ prop ] = options[ prop ];\n\t\t}\n\n\t\t// deprecated - move this to the constructor in the next major release (`start` should be constructor-specific)\n\t\tif ( options.start !== undefined )\n\t\t\tthis.toggleAnalyzer( options.start );\n\t}\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXVkaW9tb3Rpb24tYW5hbHl6ZXIvc3JjL2F1ZGlvTW90aW9uLWFuYWx5emVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNDQUFzQztBQUM1QyxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsTUFBTSxxQkFBcUIsYUFBYTs7QUFFcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLHNEQUFzRDtBQUN6RSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0EsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQSw4QkFBOEI7QUFDOUIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsU0FBUzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRyxJQUFJLFNBQVM7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSxTQUFTOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnR0FBZ0c7O0FBRTFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSw4QkFBOEIsd0JBQXdCO0FBQzVEOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQSxlQUFlLG1DQUFtQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMtZXhvcGxhbmV0LWV4cGxvcmVyLy4vbm9kZV9tb2R1bGVzL2F1ZGlvbW90aW9uLWFuYWx5emVyL3NyYy9hdWRpb01vdGlvbi1hbmFseXplci5qcz8zOTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIGF1ZGlvTW90aW9uLWFuYWx5emVyXG4gKiBIaWdoLXJlc29sdXRpb24gcmVhbC10aW1lIGdyYXBoaWMgYXVkaW8gc3BlY3RydW0gYW5hbHl6ZXIgSlMgbW9kdWxlXG4gKlxuICogQHZlcnNpb24gNC40LjBcbiAqIEBhdXRob3IgIEhlbnJpcXVlIEF2aWxhIFZpYW5uYSA8aHZpYW5uYUBnbWFpbC5jb20+IDxodHRwczovL2hlbnJpcXVldmlhbm5hLmNvbT5cbiAqIEBsaWNlbnNlIEFHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICc0LjQuMCc7XG5cbi8vIGludGVybmFsIGNvbnN0YW50c1xuY29uc3QgUEkgICAgICA9IE1hdGguUEksXG5cdCAgVEFVICAgICA9IDIgKiBQSSxcblx0ICBIQUxGX1BJID0gUEkgLyAyLFxuXHQgIENfMSAgICAgPSA4LjE3NTc5ODkyOyAgLy8gZnJlcXVlbmN5IGZvciBDIC0xXG5cbmNvbnN0IENBTlZBU19CQUNLR1JPVU5EX0NPTE9SICA9ICcjMDAwJyxcblx0ICBDSEFOTkVMX0NPTUJJTkVEICAgICAgICAgPSAnZHVhbC1jb21iaW5lZCcsXG5cdCAgQ0hBTk5FTF9IT1JJWk9OVEFMICAgICAgID0gJ2R1YWwtaG9yaXpvbnRhbCcsXG5cdCAgQ0hBTk5FTF9TSU5HTEUgICAgICAgICAgID0gJ3NpbmdsZScsXG5cdCAgQ0hBTk5FTF9WRVJUSUNBTCAgICAgICAgID0gJ2R1YWwtdmVydGljYWwnLFxuXHQgIENPTE9SX0JBUl9JTkRFWCAgICAgICAgICA9ICdiYXItaW5kZXgnLFxuXHQgIENPTE9SX0JBUl9MRVZFTCAgICAgICAgICA9ICdiYXItbGV2ZWwnLFxuXHQgIENPTE9SX0dSQURJRU5UICAgICAgICAgICA9ICdncmFkaWVudCcsXG5cdCAgREVCT1VOQ0VfVElNRU9VVCAgICAgICAgID0gNjAsXG5cdCAgRVZFTlRfQ0xJQ0sgICAgICAgICAgICAgID0gJ2NsaWNrJyxcblx0ICBFVkVOVF9GVUxMU0NSRUVOQ0hBTkdFICAgPSAnZnVsbHNjcmVlbmNoYW5nZScsXG5cdCAgRVZFTlRfUkVTSVpFICAgICAgICAgICAgID0gJ3Jlc2l6ZScsXG4gXHQgIEdSQURJRU5UX0RFRkFVTFRfQkdDT0xPUiA9ICcjMTExJyxcbiBcdCAgRklMVEVSX05PTkUgICAgICAgICAgICAgID0gJycsXG4gXHQgIEZJTFRFUl9BICAgICAgICAgICAgICAgICA9ICdBJyxcbiBcdCAgRklMVEVSX0IgICAgICAgICAgICAgICAgID0gJ0InLFxuIFx0ICBGSUxURVJfQyAgICAgICAgICAgICAgICAgPSAnQycsXG4gXHQgIEZJTFRFUl9EICAgICAgICAgICAgICAgICA9ICdEJyxcbiBcdCAgRklMVEVSXzQ2OCAgICAgICAgICAgICAgID0gJzQ2OCcsXG5cdCAgRk9OVF9GQU1JTFkgICAgICAgICAgICAgID0gJ3NhbnMtc2VyaWYnLFxuXHQgIEZQU19DT0xPUiAgICAgICAgICAgICAgICA9ICcjMGYwJyxcblx0ICBMRURTX1VOTElUX0NPTE9SICAgICAgICAgPSAnIzdmN2Y3ZjIyJyxcblx0ICBNT0RFX0dSQVBIICAgICAgICAgICAgICAgPSAxMCxcblx0ICBSRUFTT05fQ1JFQVRFICAgICAgICAgICAgPSAnY3JlYXRlJyxcblx0ICBSRUFTT05fRlNDSEFOR0UgICAgICAgICAgPSAnZnNjaGFuZ2UnLFxuXHQgIFJFQVNPTl9MT1JFUyAgICAgICAgICAgICA9ICdsb3JlcycsXG5cdCAgUkVBU09OX1JFU0laRSAgICAgICAgICAgID0gRVZFTlRfUkVTSVpFLFxuXHQgIFJFQVNPTl9VU0VSICAgICAgICAgICAgICA9ICd1c2VyJyxcblx0ICBTQ0FMRVhfQkFDS0dST1VORF9DT0xPUiAgPSAnIzAwMGMnLFxuXHQgIFNDQUxFWF9MQUJFTF9DT0xPUiAgICAgICA9ICcjZmZmJyxcblx0ICBTQ0FMRVhfSElHSExJR0hUX0NPTE9SICAgPSAnIzRmNCcsXG5cdCAgU0NBTEVZX0xBQkVMX0NPTE9SICAgICAgID0gJyM4ODgnLFxuXHQgIFNDQUxFWV9NSURMSU5FX0NPTE9SICAgICA9ICcjNTU1Jyxcblx0ICBTQ0FMRV9CQVJLICAgICAgICAgICAgICAgPSAnYmFyaycsXG5cdCAgU0NBTEVfTElORUFSICAgICAgICAgICAgID0gJ2xpbmVhcicsXG5cdCAgU0NBTEVfTE9HICAgICAgICAgICAgICAgID0gJ2xvZycsXG5cdCAgU0NBTEVfTUVMICAgICAgICAgICAgICAgID0gJ21lbCc7XG5cbi8vIGJ1aWx0LWluIGdyYWRpZW50c1xuY29uc3QgUFJJU00gPSBbICcjYTM1JywgJyNjNjYnLCAnI2U5NCcsICcjZWQwJywgJyM5ZDUnLCAnIzRkOCcsICcjMmNiJywgJyMwYmMnLCAnIzA5YycsICcjMzZiJyBdLFxuXHQgIEdSQURJRU5UUyA9IFtcblx0ICBbICdjbGFzc2ljJywge1xuXHRcdFx0Y29sb3JTdG9wczogW1xuXHRcdFx0XHQncmVkJyxcblx0XHRcdFx0eyBjb2xvcjogJ3llbGxvdycsIGxldmVsOiAuODUsIHBvczogLjYgfSxcblx0XHRcdFx0eyBjb2xvcjogJ2xpbWUnLCBsZXZlbDogLjQ3NSB9XG5cdFx0XHRdXG5cdCAgfV0sXG5cdCAgWyAncHJpc20nLCB7XG5cdFx0XHRjb2xvclN0b3BzOiBQUklTTVxuXHQgIH1dLFxuXHQgIFsgJ3JhaW5ib3cnLCB7XG5cdFx0XHRkaXI6ICdoJyxcblx0XHRcdGNvbG9yU3RvcHM6IFsgJyM4MTcnLCAuLi5QUklTTSwgJyM2MzknIF1cblx0ICB9XSxcblx0ICBbICdvcmFuZ2VyZWQnLCB7XG5cdCAgXHRcdGJnQ29sb3I6ICcjM2UyZjI5Jyxcblx0ICBcdFx0Y29sb3JTdG9wczogWyAnT3JhbmdlUmVkJyBdXG5cdCAgfV0sXG5cdCAgWyAnc3RlZWxibHVlJywge1xuXHQgIFx0XHRiZ0NvbG9yOiAnIzIyMmMzNScsXG5cdCAgXHRcdGNvbG9yU3RvcHM6IFsgJ1N0ZWVsQmx1ZScgXVxuXHQgIH1dXG5dO1xuXG4vLyBzZXR0aW5ncyBkZWZhdWx0c1xuY29uc3QgREVGQVVMVF9TRVRUSU5HUyA9IHtcblx0YWxwaGFCYXJzICAgICAgOiBmYWxzZSxcblx0YW5zaUJhbmRzICAgICAgOiBmYWxzZSxcblx0YmFyU3BhY2UgICAgICAgOiAwLjEsXG5cdGJnQWxwaGEgICAgICAgIDogMC43LFxuXHRjaGFubmVsTGF5b3V0ICA6IENIQU5ORUxfU0lOR0xFLFxuXHRjb2xvck1vZGUgICAgICA6IENPTE9SX0dSQURJRU5ULFxuXHRmZnRTaXplICAgICAgICA6IDgxOTIsXG5cdGZpbGxBbHBoYSAgICAgIDogMSxcblx0ZnJlcXVlbmN5U2NhbGUgOiBTQ0FMRV9MT0csXG5cdGdyYWRpZW50ICAgICAgIDogR1JBRElFTlRTWzBdWzBdLFxuXHRoZWlnaHQgICAgICAgICA6IHVuZGVmaW5lZCxcblx0bGVkQmFycyAgICAgICAgOiBmYWxzZSxcblx0bGluZWFyQW1wbGl0dWRlOiBmYWxzZSxcblx0bGluZWFyQm9vc3QgICAgOiAxLFxuXHRsaW5lV2lkdGggICAgICA6IDAsXG5cdGxvUmVzICAgICAgICAgIDogZmFsc2UsXG5cdGx1bWlCYXJzICAgICAgIDogZmFsc2UsXG5cdG1heERlY2liZWxzICAgIDogLTI1LFxuXHRtYXhGUFMgICAgICAgICA6IDAsXG5cdG1heEZyZXEgICAgICAgIDogMjIwMDAsXG5cdG1pbkRlY2liZWxzICAgIDogLTg1LFxuXHRtaW5GcmVxICAgICAgICA6IDIwLFxuXHRtaXJyb3IgICAgICAgICA6IDAsXG5cdG1vZGUgICAgICAgICAgIDogMCxcblx0bm90ZUxhYmVscyAgICAgOiBmYWxzZSxcblx0b3V0bGluZUJhcnMgICAgOiBmYWxzZSxcblx0b3ZlcmxheSAgICAgICAgOiBmYWxzZSxcblx0cGVha0xpbmUgICAgICAgOiBmYWxzZSxcblx0cmFkaWFsXHRcdCAgIDogZmFsc2UsXG5cdHJhZGlhbEludmVydCAgIDogZmFsc2UsXG5cdHJhZGl1cyAgICAgICAgIDogMC4zLFxuXHRyZWZsZXhBbHBoYSAgICA6IDAuMTUsXG5cdHJlZmxleEJyaWdodCAgIDogMSxcblx0cmVmbGV4Rml0ICAgICAgOiB0cnVlLFxuXHRyZWZsZXhSYXRpbyAgICA6IDAsXG5cdHJvdW5kQmFycyAgICAgIDogZmFsc2UsXG5cdHNob3dCZ0NvbG9yICAgIDogdHJ1ZSxcblx0c2hvd0ZQUyAgICAgICAgOiBmYWxzZSxcblx0c2hvd1BlYWtzICAgICAgOiB0cnVlLFxuXHRzaG93U2NhbGVYICAgICA6IHRydWUsXG5cdHNob3dTY2FsZVkgICAgIDogZmFsc2UsXG5cdHNtb290aGluZyAgICAgIDogMC41LFxuXHRzcGluU3BlZWQgICAgICA6IDAsXG5cdHNwbGl0R3JhZGllbnQgIDogZmFsc2UsXG5cdHN0YXJ0ICAgICAgICAgIDogdHJ1ZSxcblx0dHJ1ZUxlZHMgICAgICAgOiBmYWxzZSxcblx0dXNlQ2FudmFzICAgICAgOiB0cnVlLFxuXHR2b2x1bWUgICAgICAgICA6IDEsXG5cdHdlaWdodGluZ0ZpbHRlcjogRklMVEVSX05PTkUsXG5cdHdpZHRoICAgICAgICAgIDogdW5kZWZpbmVkXG59O1xuXG4vLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbmNvbnN0IEVSUl9BVURJT19DT05URVhUX0ZBSUwgICAgID0gWyAnRVJSX0FVRElPX0NPTlRFWFRfRkFJTCcsICdDb3VsZCBub3QgY3JlYXRlIGF1ZGlvIGNvbnRleHQuIFdlYiBBdWRpbyBBUEkgbm90IHN1cHBvcnRlZD8nIF0sXG5cdCAgRVJSX0lOVkFMSURfQVVESU9fQ09OVEVYVCAgPSBbICdFUlJfSU5WQUxJRF9BVURJT19DT05URVhUJywgJ1Byb3ZpZGVkIGF1ZGlvIGNvbnRleHQgaXMgbm90IHZhbGlkJyBdLFxuXHQgIEVSUl9VTktOT1dOX0dSQURJRU5UICAgICAgID0gWyAnRVJSX1VOS05PV05fR1JBRElFTlQnLCAnVW5rbm93biBncmFkaWVudCcgXSxcblx0ICBFUlJfRlJFUVVFTkNZX1RPT19MT1cgICAgICA9IFsgJ0VSUl9GUkVRVUVOQ1lfVE9PX0xPVycsICdGcmVxdWVuY3kgdmFsdWVzIG11c3QgYmUgPj0gMScgXSxcblx0ICBFUlJfSU5WQUxJRF9NT0RFICAgICAgICAgICA9IFsgJ0VSUl9JTlZBTElEX01PREUnLCAnSW52YWxpZCBtb2RlJyBdLFxuXHQgIEVSUl9SRUZMRVhfT1VUX09GX1JBTkdFICAgID0gWyAnRVJSX1JFRkxFWF9PVVRfT0ZfUkFOR0UnLCAnUmVmbGV4IHJhdGlvIG11c3QgYmUgPj0gMCBhbmQgPCAxJyBdLFxuXHQgIEVSUl9JTlZBTElEX0FVRElPX1NPVVJDRSAgID0gWyAnRVJSX0lOVkFMSURfQVVESU9fU09VUkNFJywgJ0F1ZGlvIHNvdXJjZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxNZWRpYUVsZW1lbnQgb3IgQXVkaW9Ob2RlJyBdLFxuXHQgIEVSUl9HUkFESUVOVF9JTlZBTElEX05BTUUgID0gWyAnRVJSX0dSQURJRU5UX0lOVkFMSURfTkFNRScsICdHcmFkaWVudCBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyBdLFxuXHQgIEVSUl9HUkFESUVOVF9OT1RfQU5fT0JKRUNUID0gWyAnRVJSX0dSQURJRU5UX05PVF9BTl9PQkpFQ1QnLCAnR3JhZGllbnQgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcgXSxcblx0ICBFUlJfR1JBRElFTlRfTUlTU0lOR19DT0xPUiA9IFsgJ0VSUl9HUkFESUVOVF9NSVNTSU5HX0NPTE9SJywgJ0dyYWRpZW50IGNvbG9yU3RvcHMgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheScgXTtcblxuY2xhc3MgQXVkaW9Nb3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoIGVycm9yLCB2YWx1ZSApIHtcblx0XHRjb25zdCBbIGNvZGUsIG1lc3NhZ2UgXSA9IGVycm9yO1xuXHRcdHN1cGVyKCBtZXNzYWdlICsgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gYDogJHt2YWx1ZX1gIDogJycgKSApO1xuXHRcdHRoaXMubmFtZSA9ICdBdWRpb01vdGlvbkVycm9yJztcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHR9XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiAtIG91dHB1dCBkZXByZWNhdGlvbiB3YXJuaW5nIG1lc3NhZ2Ugb24gY29uc29sZVxuY29uc3QgZGVwcmVjYXRlID0gKCBuYW1lLCBhbHRlcm5hdGl2ZSApID0+IGNvbnNvbGUud2FybiggYCR7bmFtZX0gaXMgZGVwcmVjYXRlZC4gVXNlICR7YWx0ZXJuYXRpdmV9IGluc3RlYWQuYCApO1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gLSBjaGVjayBpZiBhIGdpdmVuIG9iamVjdCBpcyBlbXB0eSAoYWxzbyByZXR1cm5zIGB0cnVlYCBvbiBudWxsLCB1bmRlZmluZWQgb3IgYW55IG5vbi1vYmplY3QgdmFsdWUpXG5jb25zdCBpc0VtcHR5ID0gb2JqID0+IHtcblx0Zm9yICggY29uc3QgcCBpbiBvYmogKVxuXHRcdHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiAtIHZhbGlkYXRlIGEgZ2l2ZW4gdmFsdWUgd2l0aCBhbiBhcnJheSBvZiBzdHJpbmdzIChieSBkZWZhdWx0LCBhbGwgbG93ZXJjYXNlKVxuLy8gcmV0dXJucyB0aGUgdmFsaWRhdGVkIHZhbHVlLCBvciB0aGUgZmlyc3QgZWxlbWVudCBvZiBgbGlzdGAgaWYgYHZhbHVlYCBpcyBub3QgZm91bmQgaW4gdGhlIGFycmF5XG5jb25zdCB2YWxpZGF0ZUZyb21MaXN0ID0gKCB2YWx1ZSwgbGlzdCwgbW9kaWZpZXIgPSAndG9Mb3dlckNhc2UnICkgPT4gbGlzdFsgTWF0aC5tYXgoIDAsIGxpc3QuaW5kZXhPZiggKCAnJyArIHZhbHVlIClbIG1vZGlmaWVyIF0oKSApICkgXTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIC0gZmluZCB0aGUgWS1jb29yZGluYXRlIG9mIGEgcG9pbnQgbG9jYXRlZCBiZXR3ZWVuIHR3byBvdGhlciBwb2ludHMsIGdpdmVuIGl0cyBYLWNvb3JkaW5hdGVcbmNvbnN0IGZpbmRZID0gKCB4MSwgeTEsIHgyLCB5MiwgeCApID0+IHkxICsgKCB5MiAtIHkxICkgKiAoIHggLSB4MSApIC8gKCB4MiAtIHgxICk7XG5cbi8vIFBvbHlmaWxsIGZvciBBcnJheS5maW5kTGFzdEluZGV4KClcbmlmICggISBBcnJheS5wcm90b3R5cGUuZmluZExhc3RJbmRleCApIHtcblx0QXJyYXkucHJvdG90eXBlLmZpbmRMYXN0SW5kZXggPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0bGV0IGluZGV4ID0gdGhpcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpbmRleC0tID4gMCApIHtcblx0XHRcdGlmICggY2FsbGJhY2soIHRoaXNbIGluZGV4IF0gKSApXG5cdFx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG59XG5cbi8vIEF1ZGlvTW90aW9uQW5hbHl6ZXIgY2xhc3NcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9Nb3Rpb25BbmFseXplciB7XG5cbi8qKlxuICogQ09OU1RSVUNUT1JcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRhaW5lcl0gRE9NIGVsZW1lbnQgd2hlcmUgdG8gaW5zZXJ0IHRoZSBhbmFseXplcjsgaWYgdW5kZWZpbmVkLCB1c2VzIHRoZSBkb2N1bWVudCBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBdWRpb01vdGlvbkFuYWx5emVyIG9iamVjdFxuICovXG5cdGNvbnN0cnVjdG9yKCBjb250YWluZXIsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHRoaXMuX3JlYWR5ID0gZmFsc2U7XG5cblx0XHQvLyBJbml0aWFsaXplIGludGVybmFsIG9iamVjdHNcblx0XHR0aGlzLl9hdXggPSB7fTtcdFx0XHRcdC8vIGF1eGlsaWFyeSB2YXJpYWJsZXNcblx0XHR0aGlzLl9jYW52YXNHcmFkaWVudHMgPSBbXTsgLy8gQ2FudmFzR3JhZGllbnQgb2JqZWN0cyBmb3IgY2hhbm5lbHMgMCBhbmQgMVxuXHRcdHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2VuZXJneSA9IHsgdmFsOiAwLCBwZWFrOiAwLCBob2xkOiAwIH07XG5cdFx0dGhpcy5fZmxnID0ge307XHRcdFx0XHQvLyBmbGFnc1xuXHRcdHRoaXMuX2ZwcyA9IDA7XG5cdFx0dGhpcy5fZ3JhZGllbnRzID0ge307ICAgICAgIC8vIHJlZ2lzdGVyZWQgZ3JhZGllbnRzXG5cdFx0dGhpcy5fbGFzdCA9IDA7XHRcdFx0XHQvLyB0aW1lc3RhbXAgb2YgbGFzdCByZW5kZXJlZCBmcmFtZVxuXHRcdHRoaXMuX291dE5vZGVzID0gW107XHRcdC8vIG91dHB1dCBub2Rlc1xuXHRcdHRoaXMuX293bkNvbnRleHQgPSBmYWxzZTtcblx0XHR0aGlzLl9zZWxlY3RlZEdyYWRzID0gW107ICAgLy8gbmFtZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBncmFkaWVudHMgZm9yIGNoYW5uZWxzIDAgYW5kIDFcblx0XHR0aGlzLl9zb3VyY2VzID0gW107XHRcdFx0Ly8gaW5wdXQgbm9kZXNcblxuXHRcdC8vIENoZWNrIGlmIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudFxuXHRcdGlmICggISAoIGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQgKSApIHtcblx0XHRcdGlmICggaXNFbXB0eSggb3B0aW9ucyApICYmICEgaXNFbXB0eSggY29udGFpbmVyICkgKVxuXHRcdFx0XHRvcHRpb25zID0gY29udGFpbmVyO1xuXHRcdFx0Y29udGFpbmVyID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLl9vd25DYW52YXMgPSAhICggb3B0aW9ucy5jYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGNhbnZhcyBvciB1c2UgdGhlIG9uZSBwcm92aWRlZCBieSB0aGUgdXNlclxuXHRcdGNvbnN0IGNhbnZhcyA9IHRoaXMuX293bkNhbnZhcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogb3B0aW9ucy5jYW52YXM7XG5cdFx0Y2FudmFzLnN0eWxlID0gJ21heC13aWR0aDogMTAwJTsnO1xuXHRcdHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgYnVpbHQtaW4gZ3JhZGllbnRzXG5cdFx0Zm9yICggY29uc3QgWyBuYW1lLCBvcHRpb25zIF0gb2YgR1JBRElFTlRTIClcblx0XHRcdHRoaXMucmVnaXN0ZXJHcmFkaWVudCggbmFtZSwgb3B0aW9ucyApO1xuXG5cdFx0Ly8gU2V0IGNvbnRhaW5lclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lciB8fCAoICEgdGhpcy5fb3duQ2FudmFzICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICkgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIG1pbmltYWwgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIGluIGNhc2Ugb2YgYW4gaW5saW5lIGNvbnRhaW5lclxuXHRcdHRoaXMuX2RlZmF1bHRXaWR0aCAgPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggIHx8IDY0MDtcblx0XHR0aGlzLl9kZWZhdWx0SGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAyNzA7XG5cblx0XHQvLyBVc2UgYXVkaW8gY29udGV4dCBwcm92aWRlZCBieSB1c2VyLCBvciBjcmVhdGUgYSBuZXcgb25lXG5cblx0XHRsZXQgYXVkaW9DdHg7XG5cblx0XHRpZiAoIG9wdGlvbnMuc291cmNlICYmICggYXVkaW9DdHggPSBvcHRpb25zLnNvdXJjZS5jb250ZXh0ICkgKSB7XG5cdFx0XHQvLyBnZXQgYXVkaW9Db250ZXh0IGZyb20gcHJvdmlkZWQgc291cmNlIGF1ZGlvTm9kZVxuXHRcdH1cblx0XHRlbHNlIGlmICggYXVkaW9DdHggPSBvcHRpb25zLmF1ZGlvQ3R4ICkge1xuXHRcdFx0Ly8gdXNlIGF1ZGlvQ29udGV4dCBwcm92aWRlZCBieSB1c2VyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXVkaW9DdHggPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXHRcdFx0XHR0aGlzLl9vd25Db250ZXh0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGNhdGNoKCBlcnIgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfQVVESU9fQ09OVEVYVF9GQUlMICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBzdXJlIGF1ZGlvQ29udGV4dCBpcyB2YWxpZFxuXHRcdGlmICggISBhdWRpb0N0eC5jcmVhdGVHYWluIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfSU5WQUxJRF9BVURJT19DT05URVhUICk7XG5cblx0XHQvKlxuXHRcdFx0Q29ubmVjdGlvbiByb3V0aW5nOlxuXHRcdFx0PT09PT09PT09PT09PT09PT09PVxuXG5cdFx0XHRmb3IgZHVhbCBjaGFubmVsIGxheW91dHM6ICAgICAgICAgICAgICAgICstLS0+ICBhbmFseXplclswXSAgLS0tK1xuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdChzb3VyY2UpIC0tLT4gIGlucHV0ICAtLS0+ICBzcGxpdHRlciAgLS0tKyAgICAgICAgICAgICAgICAgICAgICArLS0tPiAgbWVyZ2VyICAtLS0+ICBvdXRwdXQgIC0tLT4gKGRlc3RpbmF0aW9uKVxuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHQgICAgICAgIFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLT4gIGFuYWx5emVyWzFdICAtLS0rXG5cblx0XHRcdGZvciBzaW5nbGUgY2hhbm5lbCBsYXlvdXQ6XG5cblx0XHRcdChzb3VyY2UpIC0tLT4gIGlucHV0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4gIGFuYWx5emVyWzBdICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0+ICBvdXRwdXQgIC0tLT4gKGRlc3RpbmF0aW9uKVxuXG5cdFx0Ki9cblxuXHRcdC8vIGNyZWF0ZSB0aGUgYW5hbHl6ZXIgbm9kZXMsIGNoYW5uZWwgc3BsaXR0ZXIgYW5kIG1lcmdlciwgYW5kIGdhaW4gbm9kZXMgZm9yIGlucHV0L291dHB1dCBjb25uZWN0aW9uc1xuXHRcdGNvbnN0IGFuYWx5emVyID0gdGhpcy5fYW5hbHl6ZXIgPSBbIGF1ZGlvQ3R4LmNyZWF0ZUFuYWx5c2VyKCksIGF1ZGlvQ3R4LmNyZWF0ZUFuYWx5c2VyKCkgXTtcblx0XHRjb25zdCBzcGxpdHRlciA9IHRoaXMuX3NwbGl0dGVyID0gYXVkaW9DdHguY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuIFx0XHRjb25zdCBtZXJnZXIgICA9IHRoaXMuX21lcmdlciAgID0gYXVkaW9DdHguY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiBcdFx0dGhpcy5faW5wdXQgICAgPSBhdWRpb0N0eC5jcmVhdGVHYWluKCk7XG4gXHRcdHRoaXMuX291dHB1dCAgID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuXG4gXHRcdC8vIGNvbm5lY3QgYXVkaW8gc291cmNlIGlmIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zXG5cdFx0aWYgKCBvcHRpb25zLnNvdXJjZSApXG5cdFx0XHR0aGlzLmNvbm5lY3RJbnB1dCggb3B0aW9ucy5zb3VyY2UgKTtcblxuIFx0XHQvLyBjb25uZWN0IHNwbGl0dGVyIC0+IGFuYWx5emVyc1xuIFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdHNwbGl0dGVyLmNvbm5lY3QoIGFuYWx5emVyWyBpIF0sIGkgKTtcblxuXHRcdC8vIGNvbm5lY3QgbWVyZ2VyIC0+IG91dHB1dFxuXHRcdG1lcmdlci5jb25uZWN0KCB0aGlzLl9vdXRwdXQgKTtcblxuXHRcdC8vIGNvbm5lY3Qgb3V0cHV0IC0+IGRlc3RpbmF0aW9uIChzcGVha2Vycylcblx0XHRpZiAoIG9wdGlvbnMuY29ubmVjdFNwZWFrZXJzICE9PSBmYWxzZSApXG5cdFx0XHR0aGlzLmNvbm5lY3RPdXRwdXQoKTtcblxuXHRcdC8vIGNyZWF0ZSBhdXhpbGlhcnkgY2FudmFzZXMgZm9yIHRoZSBYLWF4aXMgYW5kIHJhZGlhbCBzY2FsZSBsYWJlbHNcblx0XHRmb3IgKCBjb25zdCBjdHggb2YgWyAnX3NjYWxlWCcsICdfc2NhbGVSJyBdIClcblx0XHRcdHRoaXNbIGN0eCBdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIHNldCBmdWxsc2NyZWVuIGVsZW1lbnQgKGRlZmF1bHRzIHRvIGNhbnZhcylcblx0XHR0aGlzLl9mc0VsID0gb3B0aW9ucy5mc0VsZW1lbnQgfHwgY2FudmFzO1xuXG5cdFx0Ly8gVXBkYXRlIGNhbnZhcyBzaXplIG9uIGNvbnRhaW5lciAvIHdpbmRvdyByZXNpemUgYW5kIGZ1bGxzY3JlZW4gZXZlbnRzXG5cblx0XHQvLyBGdWxsc2NyZWVuIGNoYW5nZXMgYXJlIGhhbmRsZWQgcXVpdGUgZGlmZmVyZW50bHkgYWNyb3NzIGJyb3dzZXJzOlxuXHRcdC8vIDEuIENocm9taXVtIGJyb3dzZXJzIHdpbGwgdHJpZ2dlciBhIGByZXNpemVgIGV2ZW50IGZvbGxvd2VkIGJ5IGEgYGZ1bGxzY3JlZW5jaGFuZ2VgXG5cdFx0Ly8gMi4gRmlyZWZveCB0cmlnZ2VycyB0aGUgYGZ1bGxzY3JlZW5jaGFuZ2VgIGZpcnN0IGFuZCB0aGVuIHRoZSBgcmVzaXplYFxuXHRcdC8vIDMuIENocm9tZSBvbiBBbmRyb2lkIChUVikgd29uJ3QgdHJpZ2dlciBhIGByZXNpemVgIGV2ZW50LCBvbmx5IGBmdWxsc2NyZWVuY2hhbmdlYFxuXHRcdC8vIDQuIFNhZmFyaSB3b24ndCB0cmlnZ2VyIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudHMgYXQgYWxsLCBhbmQgb24gaVBhZE9TIHRoZSBgcmVzaXplYFxuXHRcdC8vICAgIGV2ZW50IGlzIHRyaWdnZXJlZCAqKm9uIHRoZSB3aW5kb3cqKiBvbmx5IChsYXN0IHRlc3RlZCBvbiBpUGFkT1MgMTQpXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIHJlc2l6ZSBldmVudHNcblx0XHRjb25zdCBvblJlc2l6ZSA9ICgpID0+IHtcblx0XHRcdGlmICggISB0aGlzLl9mc1RpbWVvdXQgKSB7XG5cdFx0XHRcdC8vIGRlbGF5IHRoZSByZXNpemUgdG8gcHJpb3JpdGl6ZSBhIHBvc3NpYmxlIGZvbGxvd2luZyBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcblx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0XHRpZiAoICEgdGhpcy5fZnNDaGFuZ2luZyApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX1JFU0laRSApO1xuXHRcdFx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIERFQk9VTkNFX1RJTUVPVVQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiBicm93c2VyIHN1cHBvcnRzIFJlc2l6ZU9ic2VydmVyLCBsaXN0ZW4gZm9yIHJlc2l6ZSBvbiB0aGUgY29udGFpbmVyXG5cdFx0aWYgKCB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgKSB7XG5cdFx0XHR0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlciggb25SZXNpemUgKTtcblx0XHRcdHRoaXMuX29ic2VydmVyLm9ic2VydmUoIHRoaXMuX2NvbnRhaW5lciApO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBhbiBBYm9ydENvbnRyb2xsZXIgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBvbiBkZXN0cm95KClcblx0XHR0aGlzLl9jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRcdGNvbnN0IHNpZ25hbCA9IHRoaXMuX2NvbnRyb2xsZXIuc2lnbmFsO1xuXG5cdFx0Ly8gbGlzdGVuIGZvciByZXNpemUgZXZlbnRzIG9uIHRoZSB3aW5kb3cgLSByZXF1aXJlZCBmb3IgZnVsbHNjcmVlbiBvbiBpUGFkT1Ncblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfUkVTSVpFLCBvblJlc2l6ZSwgeyBzaWduYWwgfSApO1xuXG5cdFx0Ly8gbGlzdGVuIGZvciBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50cyBvbiB0aGUgY2FudmFzIC0gbm90IGF2YWlsYWJsZSBvbiBTYWZhcmlcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfRlVMTFNDUkVFTkNIQU5HRSwgKCkgPT4ge1xuXHRcdFx0Ly8gc2V0IGZsYWcgdG8gaW5kaWNhdGUgYSBmdWxsc2NyZWVuIGNoYW5nZSBpbiBwcm9ncmVzc1xuXHRcdFx0dGhpcy5fZnNDaGFuZ2luZyA9IHRydWU7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEgc2NoZWR1bGVkIHJlc2l6ZSBldmVudCwgY2xlYXIgaXRcblx0XHRcdGlmICggdGhpcy5fZnNUaW1lb3V0IClcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGhpcy5fZnNUaW1lb3V0ICk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgY2FudmFzXG5cdFx0XHR0aGlzLl9zZXRDYW52YXMoIFJFQVNPTl9GU0NIQU5HRSApO1xuXG5cdFx0XHQvLyBkZWxheSBjbGVhcmluZyB0aGUgZmxhZyB0byBwcmV2ZW50IGFueSBzaG9ydGx5IGZvbGxvd2luZyByZXNpemUgZXZlbnRcblx0XHRcdHRoaXMuX2ZzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2ZzQ2hhbmdpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gMDtcblx0XHRcdH0sIERFQk9VTkNFX1RJTUVPVVQgKTtcblx0XHR9LCB7IHNpZ25hbCB9ICk7XG5cblx0XHQvLyBSZXN1bWUgYXVkaW8gY29udGV4dCBpZiBpbiBzdXNwZW5kZWQgc3RhdGUgKGJyb3dzZXJzJyBhdXRvcGxheSBwb2xpY3kpXG5cdFx0Y29uc3QgdW5sb2NrQ29udGV4dCA9ICgpID0+IHtcblx0XHRcdGlmICggYXVkaW9DdHguc3RhdGUgPT0gJ3N1c3BlbmRlZCcgKVxuXHRcdFx0XHRhdWRpb0N0eC5yZXN1bWUoKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBFVkVOVF9DTElDSywgdW5sb2NrQ29udGV4dCApO1xuXHRcdH1cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggRVZFTlRfQ0xJQ0ssIHVubG9ja0NvbnRleHQgKTtcblxuXHRcdC8vIHJlc2V0IEZQUy1yZWxhdGVkIHZhcmlhYmxlcyB3aGVuIHdpbmRvdyBiZWNvbWVzIHZpc2libGUgKGF2b2lkIEZQUyBkcm9wIGR1ZSB0byBmcmFtZXMgbm90IHJlbmRlcmVkIHdoaWxlIGhpZGRlbilcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcblx0XHRcdGlmICggZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9ICdoaWRkZW4nICkge1xuXHRcdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0XHR0aGlzLl90aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHR9XG5cdFx0fSwgeyBzaWduYWwgfSApO1xuXG5cdFx0Ly8gU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgdXNlIGRlZmF1bHRzIGZvciBhbnkgbWlzc2luZyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fc2V0UHJvcHMoIG9wdGlvbnMsIHRydWUgKTtcblxuXHRcdC8vIEFkZCBjYW52YXMgdG8gdGhlIGNvbnRhaW5lciAob25seSB3aGVuIGNhbnZhcyBub3QgcHJvdmlkZWQgYnkgdXNlcilcblx0XHRpZiAoIHRoaXMudXNlQ2FudmFzICYmIHRoaXMuX293bkNhbnZhcyApXG5cdFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuXG5cdFx0Ly8gRmluaXNoIGNhbnZhcyBzZXR1cFxuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHR0aGlzLl9zZXRDYW52YXMoIFJFQVNPTl9DUkVBVEUgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKlxuXHQgKiBQVUJMSUMgUFJPUEVSVElFUyBHRVRURVJTIEFORCBTRVRURVJTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cdGdldCBhbHBoYUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhQmFycztcblx0fVxuXHRzZXQgYWxwaGFCYXJzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9hbHBoYUJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGFuc2lCYW5kcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5zaUJhbmRzO1xuXHR9XG5cdHNldCBhbnNpQmFuZHMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2Fuc2lCYW5kcyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdH1cblxuXHRnZXQgYmFyU3BhY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JhclNwYWNlO1xuXHR9XG5cdHNldCBiYXJTcGFjZSggdmFsdWUgKSB7XG5cdFx0dGhpcy5fYmFyU3BhY2UgPSArdmFsdWUgfHwgMDtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGNoYW5uZWxMYXlvdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoTGF5b3V0O1xuXHR9XG5cdHNldCBjaGFubmVsTGF5b3V0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9jaExheW91dCA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIENIQU5ORUxfU0lOR0xFLCBDSEFOTkVMX0hPUklaT05UQUwsIENIQU5ORUxfVkVSVElDQUwsIENIQU5ORUxfQ09NQklORUQgXSApO1xuXG5cdFx0Ly8gdXBkYXRlIG5vZGUgY29ubmVjdGlvbnNcblx0XHR0aGlzLl9pbnB1dC5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5faW5wdXQuY29ubmVjdCggdGhpcy5fY2hMYXlvdXQgIT0gQ0hBTk5FTF9TSU5HTEUgPyB0aGlzLl9zcGxpdHRlciA6IHRoaXMuX2FuYWx5emVyWzBdICk7XG5cdFx0dGhpcy5fYW5hbHl6ZXJbMF0uZGlzY29ubmVjdCgpO1xuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoICkgLy8gY29ubmVjdCBhbmFseXplciBvbmx5IGlmIHRoZSBvdXRwdXQgaXMgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzXG5cdFx0XHR0aGlzLl9hbmFseXplclswXS5jb25uZWN0KCB0aGlzLl9jaExheW91dCAhPSBDSEFOTkVMX1NJTkdMRSA/IHRoaXMuX21lcmdlciA6IHRoaXMuX291dHB1dCApO1xuXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IGNvbG9yTW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3JNb2RlO1xuXHR9XG5cdHNldCBjb2xvck1vZGUoIHZhbHVlICkge1xuXHRcdHRoaXMuX2NvbG9yTW9kZSA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIENPTE9SX0dSQURJRU5ULCBDT0xPUl9CQVJfSU5ERVgsIENPTE9SX0JBUl9MRVZFTCBdICk7XG5cdH1cblxuXHRnZXQgZmZ0U2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0uZmZ0U2l6ZTtcblx0fVxuXHRzZXQgZmZ0U2l6ZSggdmFsdWUgKSB7XG5cdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHR0aGlzLl9hbmFseXplclsgaSBdLmZmdFNpemUgPSB2YWx1ZTtcblx0XHRjb25zdCBiaW5Db3VudCA9IHRoaXMuX2FuYWx5emVyWzBdLmZyZXF1ZW5jeUJpbkNvdW50O1xuXHRcdHRoaXMuX2ZmdERhdGEgPSBbIG5ldyBGbG9hdDMyQXJyYXkoIGJpbkNvdW50ICksIG5ldyBGbG9hdDMyQXJyYXkoIGJpbkNvdW50ICkgXTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IGZyZXF1ZW5jeVNjYWxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9mcmVxdWVuY3lTY2FsZTtcblx0fVxuXHRzZXQgZnJlcXVlbmN5U2NhbGUoIHZhbHVlICkge1xuXHRcdHRoaXMuX2ZyZXF1ZW5jeVNjYWxlID0gdmFsaWRhdGVGcm9tTGlzdCggdmFsdWUsIFsgU0NBTEVfTE9HLCBTQ0FMRV9CQVJLLCBTQ0FMRV9NRUwsIFNDQUxFX0xJTkVBUiBdICk7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdGdldCBncmFkaWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRHcmFkc1swXTtcblx0fVxuXHRzZXQgZ3JhZGllbnQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3NldEdyYWRpZW50KCB2YWx1ZSApO1xuXHR9XG5cblx0Z2V0IGdyYWRpZW50TGVmdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRHcmFkc1swXTtcblx0fVxuXHRzZXQgZ3JhZGllbnRMZWZ0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRHcmFkaWVudCggdmFsdWUsIDAgKTtcblx0fVxuXG5cdGdldCBncmFkaWVudFJpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEdyYWRzWzFdO1xuXHR9XG5cdHNldCBncmFkaWVudFJpZ2h0KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRHcmFkaWVudCggdmFsdWUsIDEgKTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fVxuXHRzZXQgaGVpZ2h0KCBoICkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGg7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCBSRUFTT05fVVNFUiApO1xuXHR9XG5cblx0Z2V0IGxlZEJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Nob3dMZWRzO1xuXHR9XG5cdHNldCBsZWRCYXJzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zaG93TGVkcyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdH1cblxuXHRnZXQgbGluZWFyQW1wbGl0dWRlKCkge1xuXHRcdHJldHVybiB0aGlzLl9saW5lYXJBbXBsaXR1ZGU7XG5cdH1cblx0c2V0IGxpbmVhckFtcGxpdHVkZSggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbGluZWFyQW1wbGl0dWRlID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgbGluZWFyQm9vc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVhckJvb3N0O1xuXHR9XG5cdHNldCBsaW5lYXJCb29zdCggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbGluZWFyQm9vc3QgPSB2YWx1ZSA+PSAxID8gK3ZhbHVlIDogMTtcblx0fVxuXG5cdGdldCBsaW5lV2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVXaWR0aDtcblx0fVxuXHRzZXQgbGluZVdpZHRoKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9saW5lV2lkdGggPSArdmFsdWUgfHwgMDtcblx0fVxuXG5cdGdldCBsb1JlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9SZXM7XG5cdH1cblx0c2V0IGxvUmVzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9sb1JlcyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX0xPUkVTICk7XG5cdH1cblxuXHRnZXQgbHVtaUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2x1bWlCYXJzO1xuXHR9XG5cdHNldCBsdW1pQmFycyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbHVtaUJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHRnZXQgbWF4RGVjaWJlbHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FuYWx5emVyWzBdLm1heERlY2liZWxzO1xuXHR9XG5cdHNldCBtYXhEZWNpYmVscyggdmFsdWUgKSB7XG5cdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHR0aGlzLl9hbmFseXplclsgaSBdLm1heERlY2liZWxzID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgbWF4RlBTKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhGUFM7XG5cdH1cblx0c2V0IG1heEZQUyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbWF4RlBTID0gdmFsdWUgPCAwID8gMCA6ICt2YWx1ZSB8fCAwO1xuXHR9XG5cblx0Z2V0IG1heEZyZXEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heEZyZXE7XG5cdH1cblx0c2V0IG1heEZyZXEoIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPCAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfRlJFUVVFTkNZX1RPT19MT1cgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21heEZyZXEgPSBNYXRoLm1pbiggdmFsdWUsIHRoaXMuYXVkaW9DdHguc2FtcGxlUmF0ZSAvIDIgKTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IG1pbkRlY2liZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmFseXplclswXS5taW5EZWNpYmVscztcblx0fVxuXHRzZXQgbWluRGVjaWJlbHMoIHZhbHVlICkge1xuXHRcdGZvciAoIGNvbnN0IGkgb2YgWzAsMV0gKVxuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5taW5EZWNpYmVscyA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IG1pbkZyZXEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkZyZXE7XG5cdH1cblx0c2V0IG1pbkZyZXEoIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPCAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfRlJFUVVFTkNZX1RPT19MT1cgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21pbkZyZXEgPSArdmFsdWU7XG5cdFx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBtaXJyb3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pcnJvcjtcblx0fVxuXHRzZXQgbWlycm9yKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9taXJyb3IgPSBNYXRoLnNpZ24oIHZhbHVlICkgfCAwOyAvLyBlbnN1cmUgb25seSAtMSwgMCBvciAxXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IG1vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGU7XG5cdH1cblx0c2V0IG1vZGUoIHZhbHVlICkge1xuXHRcdGNvbnN0IG1vZGUgPSB2YWx1ZSB8IDA7XG5cdFx0aWYgKCBtb2RlID49IDAgJiYgbW9kZSA8PSAxMCAmJiBtb2RlICE9IDkgKSB7XG5cdFx0XHR0aGlzLl9tb2RlID0gbW9kZTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggRVJSX0lOVkFMSURfTU9ERSwgdmFsdWUgKTtcblx0fVxuXG5cdGdldCBub3RlTGFiZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLl9ub3RlTGFiZWxzO1xuXHR9XG5cdHNldCBub3RlTGFiZWxzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9ub3RlTGFiZWxzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY3JlYXRlU2NhbGVzKCk7XG5cdH1cblxuXHRnZXQgb3V0bGluZUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX291dGxpbmVCYXJzO1xuXHR9XG5cdHNldCBvdXRsaW5lQmFycyggdmFsdWUgKSB7XG5cdFx0dGhpcy5fb3V0bGluZUJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IHBlYWtMaW5lKCkge1xuXHRcdHJldHVybiB0aGlzLl9wZWFrTGluZTtcblx0fVxuXHRzZXQgcGVha0xpbmUoIHZhbHVlICkge1xuXHRcdHRoaXMuX3BlYWtMaW5lID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgcmFkaWFsKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH1cblx0c2V0IHJhZGlhbCggdmFsdWUgKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IHJhZGlhbEludmVydCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsSW52ZXJ0O1xuXHR9XG5cdHNldCByYWRpYWxJbnZlcnQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3JhZGlhbEludmVydCA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCByYWRpdXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fVxuXHRzZXQgcmFkaXVzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9yYWRpdXMgPSArdmFsdWUgfHwgMDtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHRnZXQgcmVmbGV4UmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlZmxleFJhdGlvO1xuXHR9XG5cdHNldCByZWZsZXhSYXRpbyggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSArdmFsdWUgfHwgMDtcblx0XHRpZiAoIHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfUkVGTEVYX09VVF9PRl9SQU5HRSApO1xuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVmbGV4UmF0aW8gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHRcdH1cblx0fVxuXG5cdGdldCByb3VuZEJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JvdW5kQmFycztcblx0fVxuXHRzZXQgcm91bmRCYXJzKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9yb3VuZEJhcnMgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHR9XG5cblx0Z2V0IHNtb290aGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0uc21vb3RoaW5nVGltZUNvbnN0YW50O1xuXHR9XG5cdHNldCBzbW9vdGhpbmcoIHZhbHVlICkge1xuXHRcdGZvciAoIGNvbnN0IGkgb2YgWzAsMV0gKVxuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBzcGluU3BlZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NwaW5TcGVlZDtcblx0fVxuXHRzZXQgc3BpblNwZWVkKCB2YWx1ZSApIHtcblx0XHR2YWx1ZSA9ICt2YWx1ZSB8fCAwO1xuXHRcdGlmICggdGhpcy5fc3BpblNwZWVkID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT0gMCApXG5cdFx0XHR0aGlzLl9zcGluQW5nbGUgPSAtSEFMRl9QSTsgLy8gaW5pdGlhbGl6ZSBvciByZXNldCB0aGUgcm90YXRpb24gYW5nbGVcblx0XHR0aGlzLl9zcGluU3BlZWQgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBzcGxpdEdyYWRpZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9zcGxpdEdyYWRpZW50O1xuXHR9XG5cdHNldCBzcGxpdEdyYWRpZW50KCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zcGxpdEdyYWRpZW50ID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCBzdGVyZW8oKSB7XG5cdFx0ZGVwcmVjYXRlKCAnc3RlcmVvJywgJ2NoYW5uZWxMYXlvdXQnICk7XG5cdFx0cmV0dXJuIHRoaXMuX2NoTGF5b3V0ICE9IENIQU5ORUxfU0lOR0xFO1xuXHR9XG5cdHNldCBzdGVyZW8oIHZhbHVlICkge1xuXHRcdGRlcHJlY2F0ZSggJ3N0ZXJlbycsICdjaGFubmVsTGF5b3V0JyApO1xuXHRcdHRoaXMuY2hhbm5lbExheW91dCA9IHZhbHVlID8gQ0hBTk5FTF9WRVJUSUNBTCA6IENIQU5ORUxfU0lOR0xFO1xuXHR9XG5cblx0Z2V0IHRydWVMZWRzKCkge1xuXHRcdHJldHVybiB0aGlzLl90cnVlTGVkcztcblx0fVxuXHRzZXQgdHJ1ZUxlZHMoIHZhbHVlICkge1xuXHRcdHRoaXMuX3RydWVMZWRzID0gISEgdmFsdWU7XG5cdH1cblxuXHRnZXQgdm9sdW1lKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXRwdXQuZ2Fpbi52YWx1ZTtcblx0fVxuXHRzZXQgdm9sdW1lKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9vdXRwdXQuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHdlaWdodGluZ0ZpbHRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2VpZ2h0aW5nRmlsdGVyO1xuXHR9XG5cdHNldCB3ZWlnaHRpbmdGaWx0ZXIoIHZhbHVlICkge1xuXHRcdHRoaXMuX3dlaWdodGluZ0ZpbHRlciA9IHZhbGlkYXRlRnJvbUxpc3QoIHZhbHVlLCBbIEZJTFRFUl9OT05FLCBGSUxURVJfQSwgRklMVEVSX0IsIEZJTFRFUl9DLCBGSUxURVJfRCwgRklMVEVSXzQ2OCBdLCAndG9VcHBlckNhc2UnICk7XG5cdH1cblxuXHRnZXQgd2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9XG5cdHNldCB3aWR0aCggdyApIHtcblx0XHR0aGlzLl93aWR0aCA9IHc7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCBSRUFTT05fVVNFUiApO1xuXHR9XG5cblx0Ly8gUmVhZCBvbmx5IHByb3BlcnRpZXNcblxuXHRnZXQgYXVkaW9DdHgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LmNvbnRleHQ7XG5cdH1cblx0Z2V0IGNhbnZhcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3R4LmNhbnZhcztcblx0fVxuXHRnZXQgY2FudmFzQ3R4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jdHg7XG5cdH1cblx0Z2V0IGNvbm5lY3RlZFNvdXJjZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZXM7XG5cdH1cblx0Z2V0IGNvbm5lY3RlZFRvKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXROb2Rlcztcblx0fVxuXHRnZXQgZnBzKCkge1xuXHRcdHJldHVybiB0aGlzLl9mcHM7XG5cdH1cblx0Z2V0IGZzSGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9mc0hlaWdodDtcblx0fVxuXHRnZXQgZnNXaWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnNXaWR0aDtcblx0fVxuXHRnZXQgaXNBbHBoYUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZsZy5pc0FscGhhO1xuXHR9XG5cdGdldCBpc0JhbmRzTW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzQmFuZHM7XG5cdH1cblx0Z2V0IGlzRGVzdHJveWVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG5cdH1cblx0Z2V0IGlzRnVsbHNjcmVlbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnNFbCAmJiAoIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ICkgPT09IHRoaXMuX2ZzRWw7XG5cdH1cblx0Z2V0IGlzTGVkQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzTGVkcztcblx0fVxuXHRnZXQgaXNMdW1pQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzTHVtaTtcblx0fVxuXHRnZXQgaXNPY3RhdmVCYW5kcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmxnLmlzT2N0YXZlcztcblx0fVxuXHRnZXQgaXNPbigpIHtcblx0XHRyZXR1cm4gISEgdGhpcy5fcnVuSWQ7XG5cdH1cblx0Z2V0IGlzT3V0bGluZUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZsZy5pc091dGxpbmU7XG5cdH1cblx0Z2V0IHBpeGVsUmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH1cblx0Z2V0IGlzUm91bmRCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9mbGcuaXNSb3VuZDtcblx0fVxuXHRzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG5cdFx0cmV0dXJuIFZFUlNJT047XG5cdH1cblxuXHQvKipcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKlxuXHQgKiBQVUJMSUMgTUVUSE9EU1xuXHQgKlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKi9cblxuXHQvKipcblx0ICogQ29ubmVjdHMgYW4gSFRNTCBtZWRpYSBlbGVtZW50IG9yIGF1ZGlvIG5vZGUgdG8gdGhlIGFuYWx5emVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhbiBpbnN0YW5jZSBvZiBIVE1MTWVkaWFFbGVtZW50IG9yIEF1ZGlvTm9kZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBhIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSBvYmplY3QgaWYgY3JlYXRlZCBmcm9tIEhUTUwgZWxlbWVudCwgb3IgdGhlIHNhbWUgaW5wdXQgb2JqZWN0IG90aGVyd2lzZVxuXHQgKi9cblx0Y29ubmVjdElucHV0KCBzb3VyY2UgKSB7XG5cdFx0Y29uc3QgaXNIVE1MID0gc291cmNlIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudDtcblxuXHRcdGlmICggISAoIGlzSFRNTCB8fCBzb3VyY2UuY29ubmVjdCApIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfSU5WQUxJRF9BVURJT19TT1VSQ0UgKTtcblxuXHRcdC8vIGlmIHNvdXJjZSBpcyBhbiBIVE1MIGVsZW1lbnQsIGNyZWF0ZSBhbiBhdWRpbyBub2RlIGZvciBpdDsgb3RoZXJ3aXNlLCB1c2UgdGhlIHByb3ZpZGVkIGF1ZGlvIG5vZGVcblx0XHRjb25zdCBub2RlID0gaXNIVE1MID8gdGhpcy5hdWRpb0N0eC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoIHNvdXJjZSApIDogc291cmNlO1xuXG5cdFx0aWYgKCAhIHRoaXMuX3NvdXJjZXMuaW5jbHVkZXMoIG5vZGUgKSApIHtcblx0XHRcdG5vZGUuY29ubmVjdCggdGhpcy5faW5wdXQgKTtcblx0XHRcdHRoaXMuX3NvdXJjZXMucHVzaCggbm9kZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIHRoZSBhbmFseXplciBvdXRwdXQgdG8gYW5vdGhlciBhdWRpbyBub2RlXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdH1dIGFuIEF1ZGlvTm9kZTsgaWYgdW5kZWZpbmVkLCB0aGUgb3V0cHV0IGlzIGNvbm5lY3RlZCB0byB0aGUgYXVkaW8gY29udGV4dCBkZXN0aW5hdGlvbiAoc3BlYWtlcnMpXG5cdCAqL1xuXHRjb25uZWN0T3V0cHV0KCBub2RlID0gdGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbiApIHtcblx0XHRpZiAoIHRoaXMuX291dE5vZGVzLmluY2x1ZGVzKCBub2RlICkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fb3V0cHV0LmNvbm5lY3QoIG5vZGUgKTtcblx0XHR0aGlzLl9vdXROb2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHQvLyB3aGVuIGNvbm5lY3RpbmcgdGhlIGZpcnN0IG5vZGUsIGFsc28gY29ubmVjdCB0aGUgYW5hbHl6ZXIgbm9kZXMgdG8gdGhlIG1lcmdlciAvIG91dHB1dCBub2Rlc1xuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoID09IDEgKSB7XG5cdFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5jb25uZWN0KCAoIHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfU0lOR0xFICYmICEgaSA/IHRoaXMuX291dHB1dCA6IHRoaXMuX21lcmdlciApLCAwLCBpICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIGluc3RhbmNlXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdGlmICggISB0aGlzLl9yZWFkeSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjb25zdCB7IGF1ZGlvQ3R4LCBjYW52YXMsIF9jb250cm9sbGVyLCBfaW5wdXQsIF9tZXJnZXIsIF9vYnNlcnZlciwgX293bkNhbnZhcywgX293bkNvbnRleHQsIF9zcGxpdHRlciB9ID0gdGhpcztcblxuXHRcdHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRfY29udHJvbGxlci5hYm9ydCgpO1xuXHRcdGlmICggX29ic2VydmVyIClcblx0XHRcdF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cblx0XHQvLyBjbGVhciBjYWxsYmFja3MgYW5kIGZ1bGxzY3JlZW4gZWxlbWVudFxuXHRcdHRoaXMub25DYW52YXNSZXNpemUgPSBudWxsO1xuXHRcdHRoaXMub25DYW52YXNEcmF3ID0gbnVsbDtcblx0XHR0aGlzLl9mc0VsID0gbnVsbDtcblxuXHRcdC8vIGRpc2Nvbm5lY3QgYXVkaW8gbm9kZXNcblx0XHR0aGlzLmRpc2Nvbm5lY3RJbnB1dCgpO1xuXHRcdHRoaXMuZGlzY29ubmVjdE91dHB1dCgpOyAvLyBhbHNvIGRpc2Nvbm5lY3RzIGFuYWx5emVyIG5vZGVzXG5cdFx0X2lucHV0LmRpc2Nvbm5lY3QoKTtcblx0XHRfc3BsaXR0ZXIuZGlzY29ubmVjdCgpO1xuXHRcdF9tZXJnZXIuZGlzY29ubmVjdCgpO1xuXG5cdFx0Ly8gaWYgYXVkaW8gY29udGV4dCBpcyBvdXIgb3duIChub3QgcHJvdmlkZWQgYnkgdGhlIHVzZXIpLCBjbG9zZSBpdFxuXHRcdGlmICggX293bkNvbnRleHQgKVxuXHRcdFx0YXVkaW9DdHguY2xvc2UoKTtcblxuXHRcdC8vIHJlbW92ZSBjYW52YXMgZnJvbSB0aGUgRE9NIChpZiBub3QgcHJvdmlkZWQgYnkgdGhlIHVzZXIpXG5cdFx0aWYgKCBfb3duQ2FudmFzIClcblx0XHRcdGNhbnZhcy5yZW1vdmUoKTtcblxuXHRcdC8vIHJlc2V0IGZsYWdzXG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0cyBhdWRpbyBzb3VyY2VzIGZyb20gdGhlIGFuYWx5emVyXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdHxhcnJheX1dIGEgY29ubmVjdGVkIEF1ZGlvTm9kZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygc3VjaCBvYmplY3RzOyBpZiBmYWxzeSwgYWxsIGNvbm5lY3RlZCBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdCAqIEBwYXJhbSBbe2Jvb2xlYW59XSBpZiB0cnVlLCBzdG9wcy9yZWxlYXNlcyBhdWRpbyB0cmFja3MgZnJvbSBkaXNjb25uZWN0ZWQgbWVkaWEgc3RyZWFtcyAoZS5nLiBtaWNyb3Bob25lKVxuXHQgKi9cblx0ZGlzY29ubmVjdElucHV0KCBzb3VyY2VzLCBzdG9wVHJhY2tzICkge1xuXHRcdGlmICggISBzb3VyY2VzIClcblx0XHRcdHNvdXJjZXMgPSBBcnJheS5mcm9tKCB0aGlzLl9zb3VyY2VzICk7XG5cdFx0ZWxzZSBpZiAoICEgQXJyYXkuaXNBcnJheSggc291cmNlcyApIClcblx0XHRcdHNvdXJjZXMgPSBbIHNvdXJjZXMgXTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2Ygc291cmNlcyApIHtcblx0XHRcdGNvbnN0IGlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZiggbm9kZSApO1xuXHRcdFx0aWYgKCBzdG9wVHJhY2tzICYmIG5vZGUubWVkaWFTdHJlYW0gKSB7XG5cdFx0XHRcdGZvciAoIGNvbnN0IHRyYWNrIG9mIG5vZGUubWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSApIHtcblx0XHRcdFx0XHR0cmFjay5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggaWR4ID49IDAgKSB7XG5cdFx0XHRcdG5vZGUuZGlzY29ubmVjdCggdGhpcy5faW5wdXQgKTtcblx0XHRcdFx0dGhpcy5fc291cmNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0cyB0aGUgYW5hbHl6ZXIgb3V0cHV0IGZyb20gb3RoZXIgYXVkaW8gbm9kZXNcblx0ICpcblx0ICogQHBhcmFtIFt7b2JqZWN0fV0gYSBjb25uZWN0ZWQgQXVkaW9Ob2RlIG9iamVjdDsgaWYgdW5kZWZpbmVkLCBhbGwgY29ubmVjdGVkIG5vZGVzIGFyZSBkaXNjb25uZWN0ZWRcblx0ICovXG5cdGRpc2Nvbm5lY3RPdXRwdXQoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmICEgdGhpcy5fb3V0Tm9kZXMuaW5jbHVkZXMoIG5vZGUgKSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9vdXRwdXQuZGlzY29ubmVjdCggbm9kZSApO1xuXHRcdHRoaXMuX291dE5vZGVzID0gbm9kZSA/IHRoaXMuX291dE5vZGVzLmZpbHRlciggZSA9PiBlICE9PSBub2RlICkgOiBbXTtcblxuXHRcdC8vIGlmIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBub2RlcywgYWxzbyBkaXNjb25uZWN0IHRoZSBhbmFseXplciBub2RlcyBzbyB0aGV5IGtlZXAgd29ya2luZyBvbiBDaHJvbWl1bVxuXHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaHZpYW5uYS9hdWRpb01vdGlvbi1hbmFseXplci9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTgwODc2NDg0OFxuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoID09IDAgKSB7XG5cdFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5kaXNjb25uZWN0KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW5hbHl6ZXIgYmFycyBkYXRhXG4gICAgICpcblx0ICogQHJldHVybnMge2FycmF5fVxuXHQgKi9cblx0Z2V0QmFycygpIHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSggdGhpcy5fYmFycywgKCB7IHBvc1gsIGZyZXEsIGZyZXFMbywgZnJlcUhpLCBob2xkLCBwZWFrLCB2YWx1ZSB9ICkgPT4gKCB7IHBvc1gsIGZyZXEsIGZyZXFMbywgZnJlcUhpLCBob2xkLCBwZWFrLCB2YWx1ZSB9ICkgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbmVyZ3kgb2YgYSBmcmVxdWVuY3ksIG9yIGF2ZXJhZ2UgZW5lcmd5IG9mIGEgcmFuZ2Ugb2YgZnJlcXVlbmNpZXNcblx0ICpcblx0ICogQHBhcmFtIFt7bnVtYmVyfHN0cmluZ31dIHNpbmdsZSBvciBpbml0aWFsIGZyZXF1ZW5jeSAoSHopLCBvciBwcmVzZXQgbmFtZTsgaWYgdW5kZWZpbmVkLCByZXR1cm5zIHRoZSBvdmVyYWxsIGVuZXJneVxuXHQgKiBAcGFyYW0gW3tudW1iZXJ9XSBlbmRpbmcgZnJlcXVlbmN5IChIeilcblx0ICogQHJldHVybnMge251bWJlcnxudWxsfSBlbmVyZ3kgdmFsdWUgKDAgdG8gMSkgb3IgbnVsbCwgaWYgdGhlIHNwZWNpZmllZCBwcmVzZXQgaXMgdW5rbm93blxuXHQgKi9cblx0Z2V0RW5lcmd5KCBzdGFydEZyZXEsIGVuZEZyZXEgKSB7XG5cdFx0aWYgKCBzdGFydEZyZXEgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRyZXR1cm4gdGhpcy5fZW5lcmd5LnZhbDtcblxuXHRcdC8vIGlmIHN0YXJ0RnJlcSBpcyBhIHN0cmluZywgY2hlY2sgZm9yIHByZXNldHNcblx0XHRpZiAoIHN0YXJ0RnJlcSAhPSArc3RhcnRGcmVxICkge1xuXHRcdFx0aWYgKCBzdGFydEZyZXEgPT0gJ3BlYWsnIClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuZXJneS5wZWFrO1xuXG5cdFx0XHRjb25zdCBwcmVzZXRzID0ge1xuXHRcdFx0XHRiYXNzOiAgICBbIDIwLCAyNTAgXSxcblx0XHRcdFx0bG93TWlkOiAgWyAyNTAsIDUwMCBdLFxuXHRcdFx0XHRtaWQ6ICAgICBbIDUwMCwgMmUzIF0sXG5cdFx0XHRcdGhpZ2hNaWQ6IFsgMmUzLCA0ZTMgXSxcblx0XHRcdFx0dHJlYmxlOiAgWyA0ZTMsIDE2ZTMgXVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgcHJlc2V0c1sgc3RhcnRGcmVxIF0gKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0WyBzdGFydEZyZXEsIGVuZEZyZXEgXSA9IHByZXNldHNbIHN0YXJ0RnJlcSBdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXJ0QmluID0gdGhpcy5fZnJlcVRvQmluKCBzdGFydEZyZXEgKSxcblx0XHQgICAgICBlbmRCaW4gICA9IGVuZEZyZXEgPyB0aGlzLl9mcmVxVG9CaW4oIGVuZEZyZXEgKSA6IHN0YXJ0QmluLFxuXHRcdCAgICAgIGNobkNvdW50ID0gdGhpcy5fY2hMYXlvdXQgPT0gQ0hBTk5FTF9TSU5HTEUgPyAxIDogMjtcblxuXHRcdGxldCBlbmVyZ3kgPSAwO1xuXHRcdGZvciAoIGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNobkNvdW50OyBjaGFubmVsKysgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0QmluOyBpIDw9IGVuZEJpbjsgaSsrIClcblx0XHRcdFx0ZW5lcmd5ICs9IHRoaXMuX25vcm1hbGl6ZWRCKCB0aGlzLl9mZnREYXRhWyBjaGFubmVsIF1bIGkgXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmVyZ3kgLyAoIGVuZEJpbiAtIHN0YXJ0QmluICsgMSApIC8gY2huQ291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBjdXJyZW50IGFuYWx5emVyIHNldHRpbmdzIGluIG9iamVjdCBmb3JtYXRcblx0ICpcblx0ICogQHBhcmFtIFt7c3RyaW5nfGFycmF5fV0gYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIG5vdCBpbmNsdWRlIGluIHRoZSByZXR1cm5lZCBvYmplY3Rcblx0ICogQHJldHVybnMge29iamVjdH0gT3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdGdldE9wdGlvbnMoIGlnbm9yZSApIHtcblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggaWdub3JlICkgKVxuXHRcdFx0aWdub3JlID0gWyBpZ25vcmUgXTtcblx0XHRsZXQgb3B0aW9ucyA9IHt9O1xuXHRcdGZvciAoIGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoIERFRkFVTFRfU0VUVElOR1MgKSApIHtcblx0XHRcdGlmICggISBpZ25vcmUuaW5jbHVkZXMoIHByb3AgKSApIHtcblx0XHRcdFx0aWYgKCBwcm9wID09ICdncmFkaWVudCcgJiYgdGhpcy5ncmFkaWVudExlZnQgIT0gdGhpcy5ncmFkaWVudFJpZ2h0ICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuZ3JhZGllbnRMZWZ0ID0gdGhpcy5ncmFkaWVudExlZnQ7XG5cdFx0XHRcdFx0b3B0aW9ucy5ncmFkaWVudFJpZ2h0ID0gdGhpcy5ncmFkaWVudFJpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBwcm9wICE9ICdzdGFydCcgKVxuXHRcdFx0XHRcdG9wdGlvbnNbIHByb3AgXSA9IHRoaXNbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY3VzdG9tIGdyYWRpZW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRyZWdpc3RlckdyYWRpZW50KCBuYW1lLCBvcHRpb25zICkge1xuXHRcdGlmICggdHlwZW9mIG5hbWUgIT0gJ3N0cmluZycgfHwgbmFtZS50cmltKCkubGVuZ3RoID09IDAgKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9JTlZBTElEX05BTUUgKTtcblxuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcgKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9OT1RfQU5fT0JKRUNUICk7XG5cblx0XHRjb25zdCB7IGNvbG9yU3RvcHMgfSA9IG9wdGlvbnM7XG5cblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggY29sb3JTdG9wcyApIHx8ICEgY29sb3JTdG9wcy5sZW5ndGggKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoIEVSUl9HUkFESUVOVF9NSVNTSU5HX0NPTE9SICk7XG5cblx0XHRjb25zdCBjb3VudCAgICAgPSBjb2xvclN0b3BzLmxlbmd0aCxcblx0XHRcdCAgaXNJbnZhbGlkID0gdmFsID0+ICt2YWwgIT0gdmFsIHx8IHZhbCA8IDAgfHwgdmFsID4gMTtcblxuXHRcdC8vIG5vcm1hbGl6ZSBhbGwgY29sb3JTdG9wcyBhcyBvYmplY3RzIHdpdGggYHBvc2AsIGBjb2xvcmAgYW5kIGBsZXZlbGAgcHJvcGVydGllc1xuXHRcdGNvbG9yU3RvcHMuZm9yRWFjaCggKCBjb2xvclN0b3AsIGluZGV4ICkgPT4ge1xuXHRcdFx0Y29uc3QgcG9zID0gaW5kZXggLyBNYXRoLm1heCggMSwgY291bnQgLSAxICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb2xvclN0b3AgIT0gJ29iamVjdCcgKSAvLyBvbmx5IGNvbG9yIHN0cmluZyB3YXMgZGVmaW5lZFxuXHRcdFx0XHRjb2xvclN0b3BzWyBpbmRleCBdID0ge1x0cG9zLCBjb2xvcjogY29sb3JTdG9wIH07XG5cdFx0XHRlbHNlIGlmICggaXNJbnZhbGlkKCBjb2xvclN0b3AucG9zICkgKVxuXHRcdFx0XHRjb2xvclN0b3AucG9zID0gcG9zO1xuXG5cdFx0XHRpZiAoIGlzSW52YWxpZCggY29sb3JTdG9wLmxldmVsICkgKVxuXHRcdFx0XHRjb2xvclN0b3BzWyBpbmRleCBdLmxldmVsID0gMSAtIGluZGV4IC8gY291bnQ7XG5cdFx0fSk7XG5cblx0XHQvLyBtYWtlIHN1cmUgY29sb3JTdG9wcyBpcyBpbiBkZXNjZW5kaW5nIGBsZXZlbGAgb3JkZXIgYW5kIHRoYXQgdGhlIGZpcnN0IG9uZSBoYXMgYGxldmVsID09IDFgXG5cdFx0Ly8gdGhpcyBpcyBjcnVjaWFsIGZvciBwcm9wZXIgb3BlcmF0aW9uIG9mICdiYXItbGV2ZWwnIGNvbG9yTW9kZSFcblx0XHRjb2xvclN0b3BzLnNvcnQoICggYSwgYiApID0+IGEubGV2ZWwgPCBiLmxldmVsID8gMSA6IGEubGV2ZWwgPiBiLmxldmVsID8gLTEgOiAwICk7XG5cdFx0Y29sb3JTdG9wc1swXS5sZXZlbCA9IDE7XG5cblx0XHR0aGlzLl9ncmFkaWVudHNbIG5hbWUgXSA9IHtcblx0XHRcdGJnQ29sb3I6ICAgIG9wdGlvbnMuYmdDb2xvciB8fCBHUkFESUVOVF9ERUZBVUxUX0JHQ09MT1IsXG5cdFx0XHRkaXI6ICAgICAgICBvcHRpb25zLmRpcixcblx0XHRcdGNvbG9yU3RvcHM6IGNvbG9yU3RvcHNcblx0XHR9O1xuXG5cdFx0Ly8gaWYgdGhlIHJlZ2lzdGVyZWQgZ3JhZGllbnQgaXMgb25lIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZ3JhZGllbnRzLCByZWdlbmVyYXRlIHRoZW1cblx0XHRpZiAoIHRoaXMuX3NlbGVjdGVkR3JhZHMuaW5jbHVkZXMoIG5hbWUgKSApXG5cdFx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBkaW1lbnNpb25zIG9mIGFuYWx5emVyJ3MgY2FudmFzXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqL1xuXHRzZXRDYW52YXNTaXplKCB3LCBoICkge1xuXHRcdHRoaXMuX3dpZHRoID0gdztcblx0XHR0aGlzLl9oZWlnaHQgPSBoO1xuXHRcdHRoaXMuX3NldENhbnZhcyggUkVBU09OX1VTRVIgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgZGVzaXJlZCBmcmVxdWVuY3kgcmFuZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiBsb3dlc3QgZnJlcXVlbmN5IHJlcHJlc2VudGVkIGluIHRoZSB4LWF4aXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCBoaWdoZXN0IGZyZXF1ZW5jeSByZXByZXNlbnRlZCBpbiB0aGUgeC1heGlzXG5cdCAqL1xuXHRzZXRGcmVxUmFuZ2UoIG1pbiwgbWF4ICkge1xuXHRcdGlmICggbWluIDwgMSB8fCBtYXggPCAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfRlJFUVVFTkNZX1RPT19MT1cgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21pbkZyZXEgPSBNYXRoLm1pbiggbWluLCBtYXggKTtcblx0XHRcdHRoaXMubWF4RnJlcSAgPSBNYXRoLm1heCggbWluLCBtYXggKTsgLy8gdXNlIHRoZSBzZXR0ZXIgZm9yIG1heEZyZXFcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGN1c3RvbSBwYXJhbWV0ZXJzIGZvciBMRUQgZWZmZWN0XG5cdCAqIElmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyBvciBpZiBhbnkgcHJvcGVydHkgaXMgaW52YWxpZCwgY2xlYXJzIGFueSBwcmV2aW91cyBjdXN0b20gcGFyYW1ldGVyc1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc11cblx0ICovXG5cdHNldExlZFBhcmFtcyggcGFyYW1zICkge1xuXHRcdGxldCBtYXhMZWRzLCBzcGFjZVYsIHNwYWNlSDtcblxuXHRcdC8vIGNvZXJjZSBwYXJhbWV0ZXJzIHRvIE51bWJlcjsgYE5hTmAgcmVzdWx0cyBhcmUgcmVqZWN0ZWQgaW4gdGhlIGNvbmRpdGlvbiBiZWxvd1xuXHRcdGlmICggcGFyYW1zICkge1xuXHRcdFx0bWF4TGVkcyA9IHBhcmFtcy5tYXhMZWRzIHwgMCwgLy8gZW5zdXJlIGludGVnZXJcblx0XHRcdHNwYWNlViAgPSArcGFyYW1zLnNwYWNlVixcblx0XHRcdHNwYWNlSCAgPSArcGFyYW1zLnNwYWNlSDtcblx0XHR9XG5cblx0XHR0aGlzLl9sZWRQYXJhbXMgPSBtYXhMZWRzID4gMCAmJiBzcGFjZVYgPiAwICYmIHNwYWNlSCA+PSAwID8gWyBtYXhMZWRzLCBzcGFjZVYsIHNwYWNlSCBdIDogdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnRoYW5kIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHNldmVyYWwgb3B0aW9ucyBhdCBvbmNlXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRzZXRPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdHRoaXMuX3NldFByb3BzKCBvcHRpb25zICk7XG5cdH1cblxuXHQvKipcblx0ICogQWRqdXN0IHRoZSBhbmFseXplcidzIHNlbnNpdGl2aXR5XG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSBkZWNpYmVscyB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gZGVjaWJlbHMgdmFsdWVcblx0ICovXG5cdHNldFNlbnNpdGl2aXR5KCBtaW4sIG1heCApIHtcblx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdICkge1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5taW5EZWNpYmVscyA9IE1hdGgubWluKCBtaW4sIG1heCApO1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5tYXhEZWNpYmVscyA9IE1hdGgubWF4KCBtaW4sIG1heCApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydCB0aGUgYW5hbHl6ZXJcblx0ICovXG5cdHN0YXJ0KCkge1xuXHRcdHRoaXMudG9nZ2xlQW5hbHl6ZXIoIHRydWUgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wIHRoZSBhbmFseXplclxuXHQgKi9cblx0c3RvcCgpIHtcblx0XHR0aGlzLnRvZ2dsZUFuYWx5emVyKCBmYWxzZSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IC8gc3RvcCBjYW52YXMgYW5pbWF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBpZiB1bmRlZmluZWQsIGludmVydHMgdGhlIGN1cnJlbnQgc3RhdGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdGluZyBzdGF0ZSBhZnRlciB0aGUgY2hhbmdlXG5cdCAqL1xuXHR0b2dnbGVBbmFseXplciggZm9yY2UgKSB7XG5cdFx0Y29uc3QgaGFzU3RhcnRlZCA9IHRoaXMuaXNPbjtcblxuXHRcdGlmICggZm9yY2UgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRmb3JjZSA9ICEgaGFzU3RhcnRlZDtcblxuXHRcdC8vIFN0b3AgdGhlIGFuYWx5emVyIGlmIGl0IHdhcyBhbHJlYWR5IHJ1bm5pbmcgYW5kIG11c3QgYmUgZGlzYWJsZWRcblx0XHRpZiAoIGhhc1N0YXJ0ZWQgJiYgISBmb3JjZSApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9ydW5JZCApO1xuXHRcdFx0dGhpcy5fcnVuSWQgPSAwO1xuXHRcdH1cblx0XHQvLyBTdGFydCB0aGUgYW5hbHl6ZXIgaWYgaXQgd2FzIHN0b3BwZWQgYW5kIG11c3QgYmUgZW5hYmxlZFxuXHRcdGVsc2UgaWYgKCAhIGhhc1N0YXJ0ZWQgJiYgZm9yY2UgJiYgISB0aGlzLl9kZXN0cm95ZWQgKSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0dGhpcy5fcnVuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHRpbWVzdGFtcCA9PiB0aGlzLl9kcmF3KCB0aW1lc3RhbXAgKSApOyAvLyBhcnJvdyBmdW5jdGlvbiBwcmVzZXJ2ZXMgdGhlIHNjb3BlIG9mICp0aGlzKlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmlzT247XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlcyBjYW52YXMgZnVsbC1zY3JlZW4gbW9kZVxuXHQgKi9cblx0dG9nZ2xlRnVsbHNjcmVlbigpIHtcblx0XHRpZiAoIHRoaXMuaXNGdWxsc2NyZWVuICkge1xuXHRcdFx0aWYgKCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0XHRlbHNlIGlmICggZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4gKVxuXHRcdFx0XHRkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IGZzRWwgPSB0aGlzLl9mc0VsO1xuXHRcdFx0aWYgKCAhIGZzRWwgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoIGZzRWwucmVxdWVzdEZ1bGxzY3JlZW4gKVxuXHRcdFx0XHRmc0VsLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG5cdFx0XHRlbHNlIGlmICggZnNFbC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGZzRWwud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICpcblx0ICogUFJJVkFURSBNRVRIT0RTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGZyZXF1ZW5jeSAoaW4gSHopIGZvciBhIGdpdmVuIEZGVCBiaW5cblx0ICovXG5cdF9iaW5Ub0ZyZXEoIGJpbiApIHtcblx0XHRyZXR1cm4gYmluICogdGhpcy5hdWRpb0N0eC5zYW1wbGVSYXRlIC8gdGhpcy5mZnRTaXplIHx8IDE7IC8vIHJldHVybnMgMSBmb3IgYmluIDBcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlIGFsbCBpbnRlcm5hbCBkYXRhIHJlcXVpcmVkIGZvciB0aGUgYW5hbHl6ZXIsIGJhc2VkIG9uIGl0cyBjdXJyZW50IHNldHRpbmdzXG5cdCAqL1xuXHRfY2FsY0JhcnMoKSB7XG5cdFx0Y29uc3QgYmFycyA9IHRoaXMuX2JhcnMgPSBbXTsgLy8gaW5pdGlhbGl6ZSBvYmplY3QgcHJvcGVydHlcblxuXHRcdGlmICggISB0aGlzLl9yZWFkeSApIHtcblx0XHRcdHRoaXMuX2ZsZyA9IHsgaXNBbHBoYTogZmFsc2UsIGlzQmFuZHM6IGZhbHNlLCBpc0xlZHM6IGZhbHNlLCBpc0x1bWk6IGZhbHNlLCBpc09jdGF2ZXM6IGZhbHNlLCBpc091dGxpbmU6IGZhbHNlLCBpc1JvdW5kOiBmYWxzZSwgbm9MZWRHYXA6IGZhbHNlIH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBfYW5zaUJhbmRzLCBfYmFyU3BhY2UsIGNhbnZhcywgX2NoTGF5b3V0LCBfbWF4RnJlcSwgX21pbkZyZXEsIF9taXJyb3IsIF9tb2RlLCBfcmFkaWFsLCBfcmFkaWFsSW52ZXJ0LCBfcmVmbGV4UmF0aW8gfSA9IHRoaXMsXG5cdFx0XHQgIGNlbnRlclggICAgICAgICAgPSBjYW52YXMud2lkdGggPj4gMSxcblx0XHRcdCAgY2VudGVyWSAgICAgICAgICA9IGNhbnZhcy5oZWlnaHQgPj4gMSxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgICA9IF9jaExheW91dCA9PSBDSEFOTkVMX1ZFUlRJQ0FMICYmICEgX3JhZGlhbCxcblx0XHRcdCAgaXNEdWFsSG9yaXpvbnRhbCA9IF9jaExheW91dCA9PSBDSEFOTkVMX0hPUklaT05UQUwsXG5cblx0XHRcdCAgLy8gQ09NUFVURSBGTEFHU1xuXG5cdFx0XHQgIGlzQmFuZHMgICA9IF9tb2RlICUgMTAgIT0gMCwgLy8gdHJ1ZSBmb3IgbW9kZXMgMSB0byA5XG5cdFx0XHQgIGlzT2N0YXZlcyA9IGlzQmFuZHMgJiYgdGhpcy5fZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTE9HLFxuXHRcdFx0ICBpc0xlZHMgICAgPSB0aGlzLl9zaG93TGVkcyAmJiBpc0JhbmRzICYmICEgX3JhZGlhbCxcblx0XHRcdCAgaXNMdW1pICAgID0gdGhpcy5fbHVtaUJhcnMgJiYgaXNCYW5kcyAmJiAhIF9yYWRpYWwsXG5cdFx0XHQgIGlzQWxwaGEgICA9IHRoaXMuX2FscGhhQmFycyAmJiAhIGlzTHVtaSAmJiBfbW9kZSAhPSBNT0RFX0dSQVBILFxuXHRcdFx0ICBpc091dGxpbmUgPSB0aGlzLl9vdXRsaW5lQmFycyAmJiBpc0JhbmRzICYmICEgaXNMdW1pICYmICEgaXNMZWRzLFxuXHRcdFx0ICBpc1JvdW5kICAgPSB0aGlzLl9yb3VuZEJhcnMgJiYgaXNCYW5kcyAmJiAhIGlzTHVtaSAmJiAhIGlzTGVkcyxcblx0XHRcdCAgbm9MZWRHYXAgID0gX2NoTGF5b3V0ICE9IENIQU5ORUxfVkVSVElDQUwgfHwgX3JlZmxleFJhdGlvID4gMCAmJiAhIGlzTHVtaSxcblxuXHRcdFx0ICAvLyBDT01QVVRFIEFVWElMSUFSWSBWQUxVRVNcblxuXHRcdFx0ICAvLyBjaGFubmVsSGVpZ2h0IGlzIHRoZSB0b3RhbCBjYW52YXMgaGVpZ2h0IGRlZGljYXRlZCB0byBlYWNoIGNoYW5uZWwsIGluY2x1ZGluZyB0aGUgcmVmbGV4IGFyZWEsIGlmIGFueSlcblx0XHRcdCAgY2hhbm5lbEhlaWdodCAgPSBjYW52YXMuaGVpZ2h0IC0gKCBpc0R1YWxWZXJ0aWNhbCAmJiAhIGlzTGVkcyA/IC41IDogMCApID4+IGlzRHVhbFZlcnRpY2FsLFxuXHRcdFx0ICAvLyBhbmFseXplckhlaWdodCBpcyB0aGUgZWZmZWN0aXZlIGhlaWdodCB1c2VkIHRvIHJlbmRlciB0aGUgYW5hbHl6ZXIsIGV4Y2x1ZGluZyB0aGUgcmVmbGV4IGFyZWFcblx0XHRcdCAgYW5hbHl6ZXJIZWlnaHQgPSBjaGFubmVsSGVpZ2h0ICogKCBpc0x1bWkgfHwgX3JhZGlhbCA/IDEgOiAxIC0gX3JlZmxleFJhdGlvICkgfCAwLFxuXG5cdFx0XHQgIGFuYWx5emVyV2lkdGggID0gY2FudmFzLndpZHRoIC0gY2VudGVyWCAqICggaXNEdWFsSG9yaXpvbnRhbCB8fCBfbWlycm9yICE9IDAgKSxcblxuXHRcdFx0ICAvLyBjaGFubmVsR2FwIGlzICoqMCoqIGlmIGlzTGVkRGlzcGxheSA9PSB0cnVlIChMRURzIGFscmVhZHkgaGF2ZSBzcGFjaW5nKTsgKioxKiogaWYgY2FudmFzIGhlaWdodCBpcyBvZGQgKHdpbmRvd2VkKTsgKioyKiogaWYgaXQncyBldmVuXG5cdFx0XHQgIC8vIFRPRE86IGltcHJvdmUgdGhpcywgbWFrZSBpdCBjb25maWd1cmFibGU/XG5cdFx0XHQgIGNoYW5uZWxHYXAgICAgID0gaXNEdWFsVmVydGljYWwgPyBjYW52YXMuaGVpZ2h0IC0gY2hhbm5lbEhlaWdodCAqIDIgOiAwLFxuXG5cdFx0XHQgIGluaXRpYWxYICAgICAgID0gY2VudGVyWCAqICggX21pcnJvciA9PSAtMSAmJiAhIGlzRHVhbEhvcml6b250YWwgJiYgISBfcmFkaWFsICk7XG5cblx0XHRsZXQgaW5uZXJSYWRpdXMgPSBNYXRoLm1pbiggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICkgKiAuMzc1ICogKCBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9WRVJUSUNBTCA/IDEgOiB0aGlzLl9yYWRpdXMgKSB8IDAsXG5cdFx0XHRvdXRlclJhZGl1cyA9IE1hdGgubWluKCBjZW50ZXJYLCBjZW50ZXJZICk7XG5cblx0XHRpZiAoIF9yYWRpYWxJbnZlcnQgJiYgX2NoTGF5b3V0ICE9IENIQU5ORUxfVkVSVElDQUwgKVxuXHRcdFx0WyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgXSA9IFsgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzIF07XG5cblx0XHQvKipcblx0XHQgKlx0Q1JFQVRFIEFOQUxZWkVSIEJBTkRTXG5cdFx0ICpcblx0XHQgKlx0VVNFUzpcblx0XHQgKlx0XHRhbmFseXplcldpZHRoXG5cdFx0ICpcdFx0aW5pdGlhbFhcblx0XHQgKlx0XHRpc0JhbmRzXG5cdFx0ICpcdFx0aXNPY3RhdmVzXG5cdFx0ICpcblx0XHQgKlx0R0VORVJBVEVTOlxuXHRcdCAqXHRcdGJhcnMgKHBvcHVsYXRlcyB0aGlzLl9iYXJzKVxuXHRcdCAqXHRcdGJhcmRXaWR0aFxuXHRcdCAqXHRcdHNjYWxlTWluXG5cdFx0ICpcdFx0dW5pdFdpZHRoXG5cdFx0ICovXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25cblx0XHQvLyBiYXIgb2JqZWN0OiB7IHBvc1gsIGZyZXEsIGZyZXFMbywgZnJlcUhpLCBiaW5MbywgYmluSGksIHJhdGlvTG8sIHJhdGlvSGksIHBlYWssIGhvbGQsIHZhbHVlIH1cblx0XHRjb25zdCBiYXJzUHVzaCA9IGFyZ3MgPT4gYmFycy5wdXNoKCB7IC4uLmFyZ3MsIHBlYWs6IFswLDBdLCBob2xkOiBbMF0sIHZhbHVlOiBbMF0gfSApO1xuXG5cdFx0Lypcblx0XHRcdEEgc2ltcGxlIGludGVycG9sYXRpb24gaXMgdXNlZCB0byBvYnRhaW4gYW4gYXBwcm94aW1hdGUgYW1wbGl0dWRlIHZhbHVlIGZvciBhbnkgZ2l2ZW4gZnJlcXVlbmN5LFxuXHRcdFx0ZnJvbSB0aGUgYXZhaWxhYmxlIEZGVCBkYXRhLiBXZSBmaW5kIHRoZSBGRlQgYmluIHdoaWNoIGNsb3NlciBtYXRjaGVzIHRoZSBkZXNpcmVkIGZyZXF1ZW5jeVx0YW5kXG5cdFx0XHRpbnRlcnBvbGF0ZSBpdHMgdmFsdWUgd2l0aCB0aGF0IG9mIHRoZSBuZXh0IGFkamFjZW50IGJpbiwgbGlrZSBzbzpcblxuXHRcdFx0XHR2ID0gdjAgKyAoIHYxIC0gdjAgKSAqICggbG9nMiggZiAvIGYwICkgLyBsb2cyKCBmMSAvIGYwICkgKVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFxcX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXy9cblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpb1xuXHRcdFx0XHR3aGVyZTpcblxuXHRcdFx0XHRmICAtIGRlc2lyZWQgZnJlcXVlbmN5XG5cdFx0XHRcdHYgIC0gYW1wbGl0dWRlICh2b2x1bWUpIG9mIGRlc2lyZWQgZnJlcXVlbmN5XG5cdFx0XHRcdGYwIC0gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBGRlQgYmluXG5cdFx0XHRcdGYxIC0gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoZSB1cHBlciBGRlQgYmluXG5cdFx0XHRcdHYwIC0gYW1wbGl0dWRlIG9mIGYwXG5cdFx0XHRcdHYxIC0gYW1wbGl0dWRlIG9mIGYxXG5cblx0XHRcdHJhdGlvIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZSBoZXJlLCB0byByZWR1Y2UgY29tcHV0YXRpb25hbCBjb21wbGV4aXR5IGR1cmluZyByZWFsLXRpbWUgcmVuZGVyaW5nLlxuXHRcdCovXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIEZGVCBiaW4gYW5kIGludGVycG9sYXRpb24gcmF0aW8gZm9yIGEgZ2l2ZW4gZnJlcXVlbmN5XG5cdFx0Y29uc3QgY2FsY1JhdGlvID0gZnJlcSA9PiB7XG5cdFx0XHRjb25zdCBiaW4gICA9IHRoaXMuX2ZyZXFUb0JpbiggZnJlcSwgJ2Zsb29yJyApLCAvLyBmaW5kIGNsb3Nlc3QgRkZUIGJpblxuXHRcdFx0XHQgIGxvd2VyID0gdGhpcy5fYmluVG9GcmVxKCBiaW4gKSxcblx0XHRcdFx0ICB1cHBlciA9IHRoaXMuX2JpblRvRnJlcSggYmluICsgMSApLFxuXHRcdFx0XHQgIHJhdGlvID0gTWF0aC5sb2cyKCBmcmVxIC8gbG93ZXIgKSAvIE1hdGgubG9nMiggdXBwZXIgLyBsb3dlciApO1xuXG5cdFx0XHRyZXR1cm4gWyBiaW4sIHJhdGlvIF07XG5cdFx0fVxuXG5cdFx0bGV0IGJhcldpZHRoLCBzY2FsZU1pbiwgdW5pdFdpZHRoO1xuXG5cdFx0aWYgKCBpc09jdGF2ZXMgKSB7XG5cdFx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdG8gcm91bmQgYSB2YWx1ZSB0byBhIGdpdmVuIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcblx0XHRcdC8vIGBhdExlYXN0YCBzZXQgdG8gdHJ1ZSBwcmV2ZW50cyByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIGludGVnZXIgc2lnbmlmaWNhbnQgZGlnaXRzXG5cdFx0XHRjb25zdCByb3VuZFNEID0gKCB2YWx1ZSwgZGlnaXRzLCBhdExlYXN0ICkgPT4gK3ZhbHVlLnRvUHJlY2lzaW9uKCBhdExlYXN0ID8gTWF0aC5tYXgoIGRpZ2l0cywgMSArIE1hdGgubG9nMTAoIHZhbHVlICkgfCAwICkgOiBkaWdpdHMgKTtcblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIG5lYXJlc3QgcHJlZmVycmVkIG51bWJlciAoUmVuYXJkIHNlcmllcykgZm9yIGEgZ2l2ZW4gdmFsdWVcblx0XHRcdGNvbnN0IG5lYXJlc3RQcmVmZXJyZWQgPSB2YWx1ZSA9PiB7XG5cdFx0XHRcdC8vIFIyMCBzZXJpZXMgaXMgdXNlZCBoZXJlLCBhcyBpdCBwcm92aWRlcyBjbG9zZXIgYXBwcm94aW1hdGlvbnMgZm9yIDEvMiBvY3RhdmUgYmFuZHMgKG5vbi1zdGFuZGFyZClcblx0XHRcdFx0Y29uc3QgcHJlZmVycmVkID0gWyAxLCAxLjEyLCAxLjI1LCAxLjQsIDEuNiwgMS44LCAyLCAyLjI0LCAyLjUsIDIuOCwgMy4xNSwgMy41NSwgNCwgNC41LCA1LCA1LjYsIDYuMywgNy4xLCA4LCA5LCAxMCBdLFxuXHRcdFx0XHRcdCAgcG93ZXIgPSBNYXRoLmxvZzEwKCB2YWx1ZSApIHwgMCxcblx0XHRcdFx0XHQgIG5vcm1hbGl6ZWQgPSB2YWx1ZSAvIDEwICoqIHBvd2VyO1xuXG5cdFx0XHRcdGxldCBpID0gMTtcblx0XHRcdFx0d2hpbGUgKCBpIDwgcHJlZmVycmVkLmxlbmd0aCAmJiBub3JtYWxpemVkID4gcHJlZmVycmVkWyBpIF0gKVxuXHRcdFx0XHRcdGkrKztcblxuXHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgLSBwcmVmZXJyZWRbIGkgLSAxIF0gPCBwcmVmZXJyZWRbIGkgXSAtIG5vcm1hbGl6ZWQgKVxuXHRcdFx0XHRcdGktLTtcblxuXHRcdFx0XHRyZXR1cm4gKCBwcmVmZXJyZWRbIGkgXSAqIDEwICoqICggcG93ZXIgKyA1ICkgfCAwICkgLyAxZTU7IC8vIGtlZXAgNSBzaWduaWZpY2FudCBkaWdpdHNcblx0XHRcdH1cblxuXHRcdFx0Ly8gQU5TSSBzdGFuZGFyZCBvY3RhdmUgYmFuZHMgdXNlIHRoZSBiYXNlLTEwIGZyZXF1ZW5jeSByYXRpbywgYXMgcHJlZmVycmVkIGJ5IFtBTlNJIFMxLjExLTIwMDQsIHAuMl1cblx0XHRcdC8vIFRoZSBlcXVhbC10ZW1wZXJlZCBzY2FsZSB1c2VzIHRoZSBiYXNlLTIgcmF0aW9cblx0XHRcdGNvbnN0IGJhbmRzID0gWzAsMjQsMTIsOCw2LDQsMywyLDFdWyBfbW9kZSBdLFxuXHRcdFx0XHQgIGJhbmRXaWR0aCA9IF9hbnNpQmFuZHMgPyAxMCAqKiAoIDMgLyAoIGJhbmRzICogMTAgKSApIDogMiAqKiAoIDEgLyBiYW5kcyApLCAvLyAxMF4oMy8xME4pIG9yIDJeKDEvTilcblx0XHRcdFx0ICBoYWxmQmFuZCAgPSBiYW5kV2lkdGggKiogLjU7XG5cblx0XHRcdGxldCBhbmFseXplckJhcnMgPSBbXSxcblx0XHRcdFx0Y3VyckZyZXEgPSBfYW5zaUJhbmRzID8gNy45NDMyODIzNSAvICggYmFuZHMgJSAyID8gMSA6IGhhbGZCYW5kICkgOiBDXzE7XG5cdFx0XHRcdC8vIEZvciBBTlNJIGJhbmRzIHdpdGggZXZlbiBkZW5vbWluYXRvcnMgKGFsbCBleGNlcHQgMS8xIGFuZCAxLzMpLCB0aGUgcmVmZXJlbmNlIGZyZXF1ZW5jeSAoMSBrSHopXG5cdFx0XHRcdC8vIG11c3QgZmFsbCBvbiB0aGUgZWRnZXMgb2YgYSBwYWlyIG9mIGFkamFjZW50IGJhbmRzLCBpbnN0ZWFkIG9mIG1pZGJhbmQgW0FOU0kgUzEuMTEtMjAwNCwgcC4yXVxuXHRcdFx0XHQvLyBJbiB0aGUgZXF1YWwtdGVtcGVyZWQgc2NhbGUsIGFsbCBtaWRiYW5kIGZyZXF1ZW5jaWVzIHJlcHJlc2VudCBhIG11c2ljYWwgbm90ZSBvciBxdWFydGVyLXRvbmUuXG5cblx0XHRcdGRvIHtcblx0XHRcdFx0bGV0IGZyZXEgPSBjdXJyRnJlcTsgLy8gbWlkYmFuZCBmcmVxdWVuY3lcblxuXHRcdFx0XHRjb25zdCBmcmVxTG8gPSByb3VuZFNEKCBmcmVxIC8gaGFsZkJhbmQsIDQsIHRydWUgKSwgLy8gbG93ZXIgZWRnZSBmcmVxdWVuY3lcblx0XHRcdFx0XHQgIGZyZXFIaSA9IHJvdW5kU0QoIGZyZXEgKiBoYWxmQmFuZCwgNCwgdHJ1ZSApLCAvLyB1cHBlciBlZGdlIGZyZXF1ZW5jeVxuXHRcdFx0XHRcdCAgWyBiaW5MbywgcmF0aW9MbyBdID0gY2FsY1JhdGlvKCBmcmVxTG8gKSxcblx0XHRcdFx0XHQgIFsgYmluSGksIHJhdGlvSGkgXSA9IGNhbGNSYXRpbyggZnJlcUhpICk7XG5cblx0XHRcdFx0Ly8gZm9yIDEvMSwgMS8yIGFuZCAxLzMgQU5TSSBiYW5kcywgdXNlIHRoZSBwcmVmZXJyZWQgbnVtYmVycyB0byBmaW5kIHRoZSBub21pbmFsIG1pZGJhbmQgZnJlcXVlbmN5XG5cdFx0XHRcdC8vIGZvciAxLzQgdG8gMS8yNCwgcm91bmQgdG8gMiBvciAzIHNpZ25pZmljYW50IGRpZ2l0cywgYWNjb3JkaW5nIHRvIHRoZSBNU0QgW0FOU0kgUzEuMTEtMjAwNCwgcC4xMl1cblx0XHRcdFx0aWYgKCBfYW5zaUJhbmRzIClcblx0XHRcdFx0XHRmcmVxID0gYmFuZHMgPCA0ID8gbmVhcmVzdFByZWZlcnJlZCggZnJlcSApIDogcm91bmRTRCggZnJlcSwgZnJlcS50b1N0cmluZygpWzBdIDwgNSA/IDMgOiAyICk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRmcmVxID0gcm91bmRTRCggZnJlcSwgNCwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggZnJlcSA+PSBfbWluRnJlcSApXG5cdFx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWDogMCwgZnJlcSwgZnJlcUxvLCBmcmVxSGksIGJpbkxvLCBiaW5IaSwgcmF0aW9MbywgcmF0aW9IaSB9ICk7XG5cblx0XHRcdFx0Y3VyckZyZXEgKj0gYmFuZFdpZHRoO1xuXHRcdFx0fSB3aGlsZSAoIGN1cnJGcmVxIDw9IF9tYXhGcmVxICk7XG5cblx0XHRcdGJhcldpZHRoID0gYW5hbHl6ZXJXaWR0aCAvIGJhcnMubGVuZ3RoO1xuXG5cdFx0XHRiYXJzLmZvckVhY2goICggYmFyLCBpbmRleCApID0+IGJhci5wb3NYID0gaW5pdGlhbFggKyBpbmRleCAqIGJhcldpZHRoICk7XG5cblx0XHRcdGNvbnN0IGZpcnN0QmFyID0gYmFyc1swXSxcblx0XHRcdFx0ICBsYXN0QmFyICA9IGJhcnNbIGJhcnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRzY2FsZU1pbiA9IHRoaXMuX2ZyZXFTY2FsaW5nKCBmaXJzdEJhci5mcmVxTG8gKTtcblx0XHRcdHVuaXRXaWR0aCA9IGFuYWx5emVyV2lkdGggLyAoIHRoaXMuX2ZyZXFTY2FsaW5nKCBsYXN0QmFyLmZyZXFIaSApIC0gc2NhbGVNaW4gKTtcblxuXHRcdFx0Ly8gY2xhbXAgZWRnZSBmcmVxdWVuY2llcyB0byBtaW5GcmVxIC8gbWF4RnJlcSwgaWYgbmVjZXNzYXJ5XG5cdFx0XHQvLyB0aGlzIGlzIGRvbmUgYWZ0ZXIgY29tcHV0aW5nIHNjYWxlTWluIGFuZCB1bml0V2lkdGgsIGZvciB0aGUgcHJvcGVyIHBvc2l0aW9uaW5nIG9mIGxhYmVscyBvbiB0aGUgWC1heGlzXG5cdFx0XHRpZiAoIGZpcnN0QmFyLmZyZXFMbyA8IF9taW5GcmVxICkge1xuXHRcdFx0XHRmaXJzdEJhci5mcmVxTG8gPSBfbWluRnJlcTtcblx0XHRcdFx0WyBmaXJzdEJhci5iaW5MbywgZmlyc3RCYXIucmF0aW9MbyBdID0gY2FsY1JhdGlvKCBfbWluRnJlcSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxhc3RCYXIuZnJlcUhpID4gX21heEZyZXEgKSB7XG5cdFx0XHRcdGxhc3RCYXIuZnJlcUhpID0gX21heEZyZXE7XG5cdFx0XHRcdFsgbGFzdEJhci5iaW5IaSwgbGFzdEJhci5yYXRpb0hpIF0gPSBjYWxjUmF0aW8oIF9tYXhGcmVxICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBpc0JhbmRzICkgeyAvLyBhIGJhbmRzIG1vZGUgaXMgc2VsZWN0ZWQsIGJ1dCBmcmVxdWVuY3kgc2NhbGUgaXMgbm90IGxvZ2FyaXRobWljXG5cblx0XHRcdGNvbnN0IGJhbmRzID0gWzAsMjQsMTIsOCw2LDQsMywyLDFdWyBfbW9kZSBdICogMTA7XG5cblx0XHRcdGNvbnN0IGludkZyZXFTY2FsaW5nID0geCA9PiB7XG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMuX2ZyZXF1ZW5jeVNjYWxlICkge1xuXHRcdFx0XHRcdGNhc2UgU0NBTEVfQkFSSyA6XG5cdFx0XHRcdFx0XHRyZXR1cm4gMTk2MCAvICggMjYuODEgLyAoIHggKyAuNTMgKSAtIDEgKTtcblx0XHRcdFx0XHRjYXNlIFNDQUxFX01FTCA6XG5cdFx0XHRcdFx0XHRyZXR1cm4gNzAwICogKCAyICoqIHggLSAxICk7XG5cdFx0XHRcdFx0Y2FzZSBTQ0FMRV9MSU5FQVIgOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YmFyV2lkdGggPSBhbmFseXplcldpZHRoIC8gYmFuZHM7XG5cblx0XHRcdHNjYWxlTWluID0gdGhpcy5fZnJlcVNjYWxpbmcoIF9taW5GcmVxICk7XG5cdFx0XHR1bml0V2lkdGggPSBhbmFseXplcldpZHRoIC8gKCB0aGlzLl9mcmVxU2NhbGluZyggX21heEZyZXEgKSAtIHNjYWxlTWluICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgcG9zWCA9IDA7IGkgPCBiYW5kczsgaSsrLCBwb3NYICs9IGJhcldpZHRoICkge1xuXHRcdFx0XHRjb25zdCBmcmVxTG8gPSBpbnZGcmVxU2NhbGluZyggc2NhbGVNaW4gKyBwb3NYIC8gdW5pdFdpZHRoICksXG5cdFx0XHRcdFx0ICBmcmVxICAgPSBpbnZGcmVxU2NhbGluZyggc2NhbGVNaW4gKyAoIHBvc1ggKyBiYXJXaWR0aCAvIDIgKSAvIHVuaXRXaWR0aCApLFxuXHRcdFx0XHRcdCAgZnJlcUhpID0gaW52RnJlcVNjYWxpbmcoIHNjYWxlTWluICsgKCBwb3NYICsgYmFyV2lkdGggKSAvIHVuaXRXaWR0aCApLFxuXHRcdFx0XHRcdCAgWyBiaW5MbywgcmF0aW9MbyBdID0gY2FsY1JhdGlvKCBmcmVxTG8gKSxcblx0XHRcdFx0XHQgIFsgYmluSGksIHJhdGlvSGkgXSA9IGNhbGNSYXRpbyggZnJlcUhpICk7XG5cblx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWDogaW5pdGlhbFggKyBwb3NYLCBmcmVxLCBmcmVxTG8sIGZyZXFIaSwgYmluTG8sIGJpbkhpLCByYXRpb0xvLCByYXRpb0hpIH0gKTtcblx0XHRcdH1cblxuXHRcdH1cblx0XHRlbHNlIHtcdC8vIERpc2NyZXRlIGZyZXF1ZW5jaWVzIG1vZGVzXG5cdFx0XHRiYXJXaWR0aCA9IDE7XG5cblx0XHRcdHNjYWxlTWluID0gdGhpcy5fZnJlcVNjYWxpbmcoIF9taW5GcmVxICk7XG5cdFx0XHR1bml0V2lkdGggPSBhbmFseXplcldpZHRoIC8gKCB0aGlzLl9mcmVxU2NhbGluZyggX21heEZyZXEgKSAtIHNjYWxlTWluICk7XG5cblx0XHRcdGNvbnN0IG1pbkluZGV4ID0gdGhpcy5fZnJlcVRvQmluKCBfbWluRnJlcSwgJ2Zsb29yJyApLFxuXHRcdFx0XHQgIG1heEluZGV4ID0gdGhpcy5fZnJlcVRvQmluKCBfbWF4RnJlcSApO1xuXG5cdCBcdFx0bGV0IGxhc3RQb3MgPSAtOTk5O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IG1pbkluZGV4OyBpIDw9IG1heEluZGV4OyBpKysgKSB7XG5cdFx0XHRcdGNvbnN0IGZyZXEgPSB0aGlzLl9iaW5Ub0ZyZXEoIGkgKSwgLy8gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoaXMgaW5kZXhcblx0XHRcdFx0XHQgIHBvc1ggPSBpbml0aWFsWCArIE1hdGgucm91bmQoIHVuaXRXaWR0aCAqICggdGhpcy5fZnJlcVNjYWxpbmcoIGZyZXEgKSAtIHNjYWxlTWluICkgKTsgLy8gYXZvaWQgZnJhY3Rpb25hcnkgcGl4ZWwgdmFsdWVzXG5cblx0XHRcdFx0Ly8gaWYgaXQncyBvbiBhIGRpZmZlcmVudCBYLWNvb3JkaW5hdGUsIGNyZWF0ZSBhIG5ldyBiYXIgZm9yIHRoaXMgZnJlcXVlbmN5XG5cdFx0XHRcdGlmICggcG9zWCA+IGxhc3RQb3MgKSB7XG5cdFx0XHRcdFx0YmFyc1B1c2goIHsgcG9zWCwgZnJlcSwgZnJlcUxvOiBmcmVxLCBmcmVxSGk6IGZyZXEsIGJpbkxvOiBpLCBiaW5IaTogaSwgcmF0aW9MbzogMCwgcmF0aW9IaTogMCB9ICk7XG5cdFx0XHRcdFx0bGFzdFBvcyA9IHBvc1g7XG5cdFx0XHRcdH0gLy8gb3RoZXJ3aXNlLCBhZGQgdGhpcyBmcmVxdWVuY3kgdG8gdGhlIGxhc3QgYmFyJ3MgcmFuZ2Vcblx0XHRcdFx0ZWxzZSBpZiAoIGJhcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNvbnN0IGxhc3RCYXIgPSBiYXJzWyBiYXJzLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHRsYXN0QmFyLmJpbkhpID0gaTtcblx0XHRcdFx0XHRsYXN0QmFyLmZyZXFIaSA9IGZyZXE7XG5cdFx0XHRcdFx0bGFzdEJhci5mcmVxID0gKCBsYXN0QmFyLmZyZXFMbyAqIGZyZXEgKSAqKiAuNTsgLy8gY29tcHV0ZSBjZW50ZXIgZnJlcXVlbmN5IChnZW9tZXRyaWMgbWVhbilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqICBDT01QVVRFIEFUVFJJQlVURVMgRk9SIFRIRSBMRUQgQkFSU1xuXHRcdCAqXG5cdFx0ICpcdFVTRVM6XG5cdFx0ICpcdFx0YW5hbHl6ZXJIZWlnaHRcblx0XHQgKlx0XHRiYXJXaWR0aFxuXHRcdCAqXHRcdG5vTGVkR2FwXG5cdFx0ICpcblx0XHQgKlx0R0VORVJBVEVTOlxuXHRcdCAqIFx0XHRzcGFjZUhcblx0XHQgKiBcdFx0c3BhY2VWXG5cdFx0ICpcdFx0dGhpcy5fbGVkc1xuXHRcdCAqL1xuXG5cdFx0bGV0IHNwYWNlSCA9IDAsXG5cdFx0XHRzcGFjZVYgPSAwO1xuXG5cdFx0aWYgKCBpc0xlZHMgKSB7XG5cdFx0XHQvLyBhZGp1c3RtZW50IGZvciBoaWdoIHBpeGVsLXJhdGlvIHZhbHVlcyBvbiBsb3ctcmVzb2x1dGlvbiBzY3JlZW5zIChBbmRyb2lkIFRWKVxuXHRcdFx0Y29uc3QgZFBSID0gdGhpcy5fcGl4ZWxSYXRpbyAvICggd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmIHdpbmRvdy5zY3JlZW4uaGVpZ2h0IDw9IDU0MCA/IDIgOiAxICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtcyA9IFsgW10sXG5cdFx0XHRcdFsgMTI4LCAgMywgLjQ1ICBdLCAvLyBtb2RlIDFcblx0XHRcdFx0WyAxMjgsICA0LCAuMjI1IF0sIC8vIG1vZGUgMlxuXHRcdFx0XHRbICA5NiwgIDYsIC4yMjUgXSwgLy8gbW9kZSAzXG5cdFx0XHRcdFsgIDgwLCAgNiwgLjIyNSBdLCAvLyBtb2RlIDRcblx0XHRcdFx0WyAgODAsICA2LCAuMTI1IF0sIC8vIG1vZGUgNVxuXHRcdFx0XHRbICA2NCwgIDYsIC4xMjUgXSwgLy8gbW9kZSA2XG5cdFx0XHRcdFsgIDQ4LCAgOCwgLjEyNSBdLCAvLyBtb2RlIDdcblx0XHRcdFx0WyAgMjQsIDE2LCAuMTI1IF0sIC8vIG1vZGUgOFxuXHRcdFx0XTtcblxuXHRcdFx0Ly8gdXNlIGN1c3RvbSBMRUQgcGFyYW1ldGVycyBpZiBzZXQsIG9yIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgZm9yIHRoZSBjdXJyZW50IG1vZGVcblx0XHRcdGNvbnN0IGN1c3RvbVBhcmFtcyA9IHRoaXMuX2xlZFBhcmFtcyxcblx0XHRcdFx0ICBbIG1heExlZHMsIHNwYWNlVlJhdGlvLCBzcGFjZUhSYXRpbyBdID0gY3VzdG9tUGFyYW1zIHx8IHBhcmFtc1sgX21vZGUgXTtcblxuXHRcdFx0bGV0IGxlZENvdW50LCBtYXhIZWlnaHQgPSBhbmFseXplckhlaWdodDtcblxuXHRcdFx0aWYgKCBjdXN0b21QYXJhbXMgKSB7XG5cdFx0XHRcdGNvbnN0IG1pbkhlaWdodCA9IDIgKiBkUFI7XG5cdFx0XHRcdGxldCBibG9ja0hlaWdodDtcblx0XHRcdFx0bGVkQ291bnQgPSBtYXhMZWRzICsgMTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGxlZENvdW50LS07XG5cdFx0XHRcdFx0YmxvY2tIZWlnaHQgPSBtYXhIZWlnaHQgLyBsZWRDb3VudCAvICggMSArIHNwYWNlVlJhdGlvICk7XG5cdFx0XHRcdFx0c3BhY2VWID0gYmxvY2tIZWlnaHQgKiBzcGFjZVZSYXRpbztcblx0XHRcdFx0fSB3aGlsZSAoICggYmxvY2tIZWlnaHQgPCBtaW5IZWlnaHQgfHwgc3BhY2VWIDwgbWluSGVpZ2h0ICkgJiYgbGVkQ291bnQgPiAxICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHZlcnRpY2FsIHNwYWNpbmcgLSBhaW0gZm9yIHRoZSByZWZlcmVuY2UgcmF0aW8sIGJ1dCBtYWtlIHN1cmUgaXQncyBhdCBsZWFzdCAycHhcblx0XHRcdFx0Y29uc3QgcmVmUmF0aW8gPSA1NDAgLyBzcGFjZVZSYXRpbztcblx0XHRcdFx0c3BhY2VWID0gTWF0aC5taW4oIHNwYWNlVlJhdGlvICogZFBSLCBNYXRoLm1heCggMiwgbWF4SGVpZ2h0IC8gcmVmUmF0aW8gKyAuMSB8IDAgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgdGhlIGV4dHJhIHNwYWNpbmcgYmVsb3cgdGhlIGxhc3QgbGluZSBvZiBMRURzXG5cdFx0XHRpZiAoIG5vTGVkR2FwIClcblx0XHRcdFx0bWF4SGVpZ2h0ICs9IHNwYWNlVjtcblxuXHRcdFx0Ly8gcmVjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBsZWRzLCBjb25zaWRlcmluZyB0aGUgZWZmZWN0aXZlIHNwYWNlVlxuXHRcdFx0aWYgKCAhIGN1c3RvbVBhcmFtcyApXG5cdFx0XHRcdGxlZENvdW50ID0gTWF0aC5taW4oIG1heExlZHMsIG1heEhlaWdodCAvICggc3BhY2VWICogMiApIHwgMCApO1xuXG5cdFx0XHRzcGFjZUggPSBzcGFjZUhSYXRpbyA+PSAxID8gc3BhY2VIUmF0aW8gOiBiYXJXaWR0aCAqIHNwYWNlSFJhdGlvO1xuXG5cdFx0XHR0aGlzLl9sZWRzID0gW1xuXHRcdFx0XHRsZWRDb3VudCxcblx0XHRcdFx0c3BhY2VILFxuXHRcdFx0XHRzcGFjZVYsXG5cdFx0XHRcdG1heEhlaWdodCAvIGxlZENvdW50IC0gc3BhY2VWIC8vIGxlZEhlaWdodFxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHQvLyBDT01QVVRFIEFERElUSU9OQUwgQkFSIFBPU0lUSU9OSU5HLCBBQ0NPUkRJTkcgVE8gVEhFIENVUlJFTlQgU0VUVElOR1Ncblx0XHQvLyB1c2VzOiBfYmFyU3BhY2UsIGJhcldpZHRoLCBzcGFjZUhcblxuXHRcdGNvbnN0IGJhclNwYWNlUHggPSBNYXRoLm1pbiggYmFyV2lkdGggLSAxLCBfYmFyU3BhY2UgKiAoIF9iYXJTcGFjZSA+IDAgJiYgX2JhclNwYWNlIDwgMSA/IGJhcldpZHRoIDogMSApICk7XG5cblx0XHRpZiAoIGlzQmFuZHMgKVxuXHRcdFx0YmFyV2lkdGggLT0gTWF0aC5tYXgoIGlzTGVkcyA/IHNwYWNlSCA6IDAsIGJhclNwYWNlUHggKTtcblxuXHRcdGJhcnMuZm9yRWFjaCggKCBiYXIsIGluZGV4ICkgPT4ge1xuXHRcdFx0bGV0IHBvc1ggID0gYmFyLnBvc1gsXG5cdFx0XHRcdHdpZHRoID0gYmFyV2lkdGg7XG5cblx0XHRcdC8vIGluIGJhbmRzIG1vZGVzIHdlIG5lZWQgdG8gdXBkYXRlIGJhci5wb3NYIHRvIGFjY291bnQgZm9yIGJhci9sZWQgc3BhY2luZ1xuXG5cdFx0XHRpZiAoIGlzQmFuZHMgKSB7XG5cdFx0XHRcdGlmICggX2JhclNwYWNlID09IDAgJiYgISBpc0xlZHMgKSB7XG5cdFx0XHRcdFx0Ly8gd2hlbiBiYXJTcGFjZSA9PSAwIHVzZSBpbnRlZ2VyIHZhbHVlcyBmb3IgcGVyZmVjdCBnYXBsZXNzIHBvc2l0aW9uaW5nXG5cdFx0XHRcdFx0cG9zWCB8PSAwO1xuXHRcdFx0XHRcdHdpZHRoIHw9IDA7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCA+IDAgJiYgcG9zWCA+IGJhcnNbIGluZGV4IC0gMSBdLnBvc1ggKyBiYXJzWyBpbmRleCAtIDEgXS53aWR0aCApIHtcblx0XHRcdFx0XHRcdHBvc1gtLTtcblx0XHRcdFx0XHRcdHdpZHRoKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwb3NYICs9IE1hdGgubWF4KCAoIGlzTGVkcyA/IHNwYWNlSCA6IDAgKSwgYmFyU3BhY2VQeCApIC8gMjtcblxuXHRcdFx0XHRiYXIucG9zWCA9IHBvc1g7IC8vIHVwZGF0ZVxuXHRcdFx0fVxuXG5cdFx0XHRiYXIuYmFyQ2VudGVyID0gcG9zWCArICggYmFyV2lkdGggPT0gMSA/IDAgOiB3aWR0aCAvIDIgKTtcblx0XHRcdGJhci53aWR0aCA9IHdpZHRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ09NUFVURSBDSEFOTkVMIENPT1JESU5BVEVTICh1c2VzIHNwYWNlVilcblxuXHRcdGNvbnN0IGNoYW5uZWxDb29yZHMgPSBbXTtcblx0XHRmb3IgKCBjb25zdCBjaGFubmVsIG9mIFswLDFdICkge1xuXHRcdFx0Y29uc3QgY2hhbm5lbFRvcCAgICAgPSBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9WRVJUSUNBTCA/ICggY2hhbm5lbEhlaWdodCArIGNoYW5uZWxHYXAgKSAqIGNoYW5uZWwgOiAwLFxuXHRcdFx0XHQgIGNoYW5uZWxCb3R0b20gID0gY2hhbm5lbFRvcCArIGNoYW5uZWxIZWlnaHQsXG5cdFx0XHRcdCAgYW5hbHl6ZXJCb3R0b20gPSBjaGFubmVsVG9wICsgYW5hbHl6ZXJIZWlnaHQgLSAoICEgaXNMZWRzIHx8IG5vTGVkR2FwID8gMCA6IHNwYWNlViApO1xuXG5cdFx0XHRjaGFubmVsQ29vcmRzLnB1c2goIHsgY2hhbm5lbFRvcCwgY2hhbm5lbEJvdHRvbSwgYW5hbHl6ZXJCb3R0b20gfSApO1xuXHRcdH1cblxuXHRcdC8vIFNBVkUgSU5URVJOQUwgUFJPUEVSVElFU1xuXG5cdFx0dGhpcy5fYXV4ID0geyBhbmFseXplckhlaWdodCwgYW5hbHl6ZXJXaWR0aCwgY2VudGVyWCwgY2VudGVyWSwgY2hhbm5lbENvb3JkcywgY2hhbm5lbEhlaWdodCwgY2hhbm5lbEdhcCwgaW5pdGlhbFgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgc2NhbGVNaW4sIHVuaXRXaWR0aCB9O1xuXHRcdHRoaXMuX2ZsZyA9IHsgaXNBbHBoYSwgaXNCYW5kcywgaXNMZWRzLCBpc0x1bWksIGlzT2N0YXZlcywgaXNPdXRsaW5lLCBpc1JvdW5kLCBub0xlZEdhcCB9O1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdGhlIFgtYXhpcyBhbmQgcmFkaWFsIHNjYWxlc1xuXHRcdHRoaXMuX2NyZWF0ZVNjYWxlcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBYLWF4aXMgYW5kIHJhZGlhbCBzY2FsZXMgaW4gYXV4aWxpYXJ5IGNhbnZhc2VzXG5cdCAqL1xuXHRfY3JlYXRlU2NhbGVzKCkge1xuXHRcdGlmICggISB0aGlzLl9yZWFkeSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjb25zdCB7IGFuYWx5emVyV2lkdGgsIGluaXRpYWxYLCBpbm5lclJhZGl1cywgc2NhbGVNaW4sIHVuaXRXaWR0aCB9ID0gdGhpcy5fYXV4LFxuXHRcdFx0ICB7IGNhbnZhcywgX2ZyZXF1ZW5jeVNjYWxlLCBfbWlycm9yLCBfbm90ZUxhYmVscywgX3JhZGlhbCwgX3NjYWxlWCwgX3NjYWxlUiB9ID0gdGhpcyxcblx0XHRcdCAgY2FudmFzWCAgICAgICAgICA9IF9zY2FsZVguY2FudmFzLFxuXHRcdFx0ICBjYW52YXNSICAgICAgICAgID0gX3NjYWxlUi5jYW52YXMsXG5cdFx0XHQgIGZyZXFMYWJlbHMgICAgICAgPSBbXSxcblx0XHRcdCAgaXNEdWFsSG9yaXpvbnRhbCA9IHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfSE9SSVpPTlRBTCxcblx0XHRcdCAgaXNEdWFsVmVydGljYWwgICA9IHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfVkVSVElDQUwsXG5cdFx0XHQgIG1pbkRpbWVuc2lvbiAgICAgPSBNYXRoLm1pbiggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICksXG5cdFx0XHQgIHNjYWxlICAgICAgICAgICAgPSBbICdDJywsICdEJywsICdFJywgJ0YnLCwgJ0cnLCwgJ0EnLCwgJ0InIF0sIC8vIGZvciBub3RlIGxhYmVscyAobm8gc2hhcnAgbm90ZXMpXG5cdFx0XHQgIHNjYWxlSGVpZ2h0ICAgICAgPSBtaW5EaW1lbnNpb24gLyAzNCB8IDAsIC8vIGNpcmN1bGFyIHNjYWxlIGhlaWdodCAocmFkaWFsIG1vZGUpXG4gIFx0XHRcdCAgZm9udFNpemVYICAgICAgICA9IGNhbnZhc1guaGVpZ2h0ID4+IDEsXG5cdFx0XHQgIGZvbnRTaXplUiAgICAgICAgPSBzY2FsZUhlaWdodCA+PiAxLFxuXHRcdFx0ICBsYWJlbFdpZHRoWCAgICAgID0gZm9udFNpemVYICogKCBfbm90ZUxhYmVscyA/IC43IDogMS41ICksXG5cdFx0XHQgIGxhYmVsV2lkdGhSICAgICAgPSBmb250U2l6ZVIgKiAoIF9ub3RlTGFiZWxzID8gMSA6IDIgKSxcblx0XHQgIFx0ICByb290MTIgICAgICAgICAgID0gMiAqKiAoIDEgLyAxMiApO1xuXG5cdFx0aWYgKCAhIF9ub3RlTGFiZWxzICYmICggdGhpcy5fYW5zaUJhbmRzIHx8IF9mcmVxdWVuY3lTY2FsZSAhPSBTQ0FMRV9MT0cgKSApIHtcblx0XHRcdGZyZXFMYWJlbHMucHVzaCggMTYsIDMxLjUsIDYzLCAxMjUsIDI1MCwgNTAwLCAxZTMsIDJlMywgNGUzICk7XG5cdFx0XHRpZiAoIF9mcmVxdWVuY3lTY2FsZSA9PSBTQ0FMRV9MSU5FQVIgKVxuXHRcdFx0XHRmcmVxTGFiZWxzLnB1c2goIDZlMywgOGUzLCAxMGUzLCAxMmUzLCAxNGUzLCAxNmUzLCAxOGUzLCAyMGUzLCAyMmUzICk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZyZXFMYWJlbHMucHVzaCggOGUzLCAxNmUzICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IGZyZXEgPSBDXzE7XG5cdFx0XHRmb3IgKCBsZXQgb2N0YXZlID0gLTE7IG9jdGF2ZSA8IDExOyBvY3RhdmUrKyApIHtcblx0XHRcdFx0Zm9yICggbGV0IG5vdGUgPSAwOyBub3RlIDwgMTI7IG5vdGUrKyApIHtcblx0XHRcdFx0XHRpZiAoIGZyZXEgPj0gdGhpcy5fbWluRnJlcSAmJiBmcmVxIDw9IHRoaXMuX21heEZyZXEgKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwaXRjaCA9IHNjYWxlWyBub3RlIF0sXG5cdFx0XHRcdFx0XHRcdCAgaXNDICAgPSBwaXRjaCA9PSAnQyc7XG5cdFx0XHRcdFx0XHRpZiAoICggcGl0Y2ggJiYgX25vdGVMYWJlbHMgJiYgISBfbWlycm9yICYmICEgaXNEdWFsSG9yaXpvbnRhbCApIHx8IGlzQyApXG5cdFx0XHRcdFx0XHRcdGZyZXFMYWJlbHMucHVzaCggX25vdGVMYWJlbHMgPyBbIGZyZXEsIHBpdGNoICsgKCBpc0MgPyBvY3RhdmUgOiAnJyApIF0gOiBmcmVxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyZXEgKj0gcm9vdDEyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaW4gcmFkaWFsIGR1YWwtdmVydGljYWwgbGF5b3V0LCB0aGUgc2NhbGUgaXMgcG9zaXRpb25lZCBleGFjdGx5IGJldHdlZW4gYm90aCBjaGFubmVscywgYnkgbWFraW5nIHRoZSBjYW52YXMgYSBiaXQgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIGRpYW1ldGVyXG5cdFx0Y2FudmFzUi53aWR0aCA9IGNhbnZhc1IuaGVpZ2h0ID0gTWF0aC5tYXgoIG1pbkRpbWVuc2lvbiAqIC4xNSwgKCBpbm5lclJhZGl1cyA8PCAxICkgKyAoIGlzRHVhbFZlcnRpY2FsICogc2NhbGVIZWlnaHQgKSApO1xuXG5cdFx0Y29uc3QgY2VudGVyUiA9IGNhbnZhc1Iud2lkdGggPj4gMSxcblx0XHRcdCAgcmFkaWFsWSA9IGNlbnRlclIgLSBzY2FsZUhlaWdodCAqIC43O1x0Ly8gdmVydGljYWwgcG9zaXRpb24gb2YgdGV4dCBsYWJlbHMgaW4gdGhlIGNpcmN1bGFyIHNjYWxlXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25cblx0XHRjb25zdCByYWRpYWxMYWJlbCA9ICggeCwgbGFiZWwgKSA9PiB7XG5cdFx0XHRjb25zdCBhbmdsZSAgPSBUQVUgKiAoIHggLyBjYW52YXMud2lkdGggKSxcblx0XHRcdFx0ICBhZGpBbmcgPSBhbmdsZSAtIEhBTEZfUEksIC8vIHJvdGF0ZSBhbmdsZXMgc28gMCBpcyBhdCB0aGUgdG9wXG5cdFx0XHRcdCAgcG9zWCAgID0gcmFkaWFsWSAqIE1hdGguY29zKCBhZGpBbmcgKSxcblx0XHRcdFx0ICBwb3NZICAgPSByYWRpYWxZICogTWF0aC5zaW4oIGFkakFuZyApO1xuXG5cdFx0XHRfc2NhbGVSLnNhdmUoKTtcblx0XHRcdF9zY2FsZVIudHJhbnNsYXRlKCBjZW50ZXJSICsgcG9zWCwgY2VudGVyUiArIHBvc1kgKTtcblx0XHRcdF9zY2FsZVIucm90YXRlKCBhbmdsZSApO1xuXHRcdFx0X3NjYWxlUi5maWxsVGV4dCggbGFiZWwsIDAsIDAgKTtcblx0XHRcdF9zY2FsZVIucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdC8vIGNsZWFyIHNjYWxlIGNhbnZhc1xuXHRcdGNhbnZhc1gud2lkdGggfD0gMDtcblxuXHRcdF9zY2FsZVguZmlsbFN0eWxlID0gX3NjYWxlUi5zdHJva2VTdHlsZSA9IFNDQUxFWF9CQUNLR1JPVU5EX0NPTE9SO1xuXHRcdF9zY2FsZVguZmlsbFJlY3QoIDAsIDAsIGNhbnZhc1gud2lkdGgsIGNhbnZhc1guaGVpZ2h0ICk7XG5cblx0XHRfc2NhbGVSLmFyYyggY2VudGVyUiwgY2VudGVyUiwgY2VudGVyUiAtIHNjYWxlSGVpZ2h0IC8gMiwgMCwgVEFVICk7XG5cdFx0X3NjYWxlUi5saW5lV2lkdGggPSBzY2FsZUhlaWdodDtcblx0XHRfc2NhbGVSLnN0cm9rZSgpO1xuXG5cdFx0X3NjYWxlWC5maWxsU3R5bGUgPSBfc2NhbGVSLmZpbGxTdHlsZSA9IFNDQUxFWF9MQUJFTF9DT0xPUjtcblx0XHRfc2NhbGVYLmZvbnQgPSBgJHsgZm9udFNpemVYIH1weCAke0ZPTlRfRkFNSUxZfWA7XG5cdFx0X3NjYWxlUi5mb250ID0gYCR7IGZvbnRTaXplUiB9cHggJHtGT05UX0ZBTUlMWX1gO1xuXHRcdF9zY2FsZVgudGV4dEFsaWduID0gX3NjYWxlUi50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuXHRcdGxldCBwcmV2WCA9IC1sYWJlbFdpZHRoWCAvIDQsXG5cdFx0XHRwcmV2UiA9IC1sYWJlbFdpZHRoUjtcblxuXHRcdGZvciAoIGNvbnN0IGl0ZW0gb2YgZnJlcUxhYmVscyApIHtcblx0XHRcdGNvbnN0IFsgZnJlcSwgbGFiZWwgXSA9IEFycmF5LmlzQXJyYXkoIGl0ZW0gKSA/IGl0ZW0gOiBbIGl0ZW0sIGl0ZW0gPCAxZTMgPyBpdGVtIHwgMCA6IGAkeyAoIGl0ZW0gLyAxMDAgfCAwICkgLyAxMCB9a2AgXSxcblx0XHRcdFx0ICB4ICAgID0gdW5pdFdpZHRoICogKCB0aGlzLl9mcmVxU2NhbGluZyggZnJlcSApIC0gc2NhbGVNaW4gKSxcblx0XHRcdFx0ICB5ICAgID0gY2FudmFzWC5oZWlnaHQgKiAuNzUsXG5cdFx0XHRcdCAgaXNDICA9IGxhYmVsWzBdID09ICdDJyxcblx0ICBcdFx0XHQgIG1heFcgPSBmb250U2l6ZVggKiAoIF9ub3RlTGFiZWxzICYmICEgX21pcnJvciAmJiAhIGlzRHVhbEhvcml6b250YWwgPyAoIGlzQyA/IDEuMiA6IC42ICkgOiAzICk7XG5cblx0ICBcdFx0Ly8gc2V0IGxhYmVsIGNvbG9yIC0gbm8gaGlnaGxpZ2h0IHdoZW4gbWlycm9yIGVmZmVjdCBpcyBhY3RpdmUgKG9ubHkgQ3MgZGlzcGxheWVkKVxuXHRcdFx0X3NjYWxlWC5maWxsU3R5bGUgPSBfc2NhbGVSLmZpbGxTdHlsZSA9IGlzQyAmJiAhIF9taXJyb3IgJiYgISBpc0R1YWxIb3Jpem9udGFsID8gU0NBTEVYX0hJR0hMSUdIVF9DT0xPUiA6IFNDQUxFWF9MQUJFTF9DT0xPUjtcblxuXHRcdFx0Ly8gcHJpb3JpdGl6ZXMgd2hpY2ggbm90ZSBsYWJlbHMgYXJlIGRpc3BsYXllZCwgZHVlIHRvIHRoZSByZXN0cmljdGVkIHNwYWNlIG9uIHNvbWUgcmFuZ2VzL3NjYWxlc1xuXHRcdFx0aWYgKCBfbm90ZUxhYmVscyApIHtcblx0XHRcdFx0Y29uc3QgaXNMb2cgPSBfZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTE9HLFxuXHRcdFx0XHRcdCAgaXNMaW5lYXIgPSBfZnJlcXVlbmN5U2NhbGUgPT0gU0NBTEVfTElORUFSO1xuXG5cdFx0XHRcdGxldCBhbGxvd2VkTGFiZWxzID0gWydDJ107XG5cblx0XHRcdFx0aWYgKCBpc0xvZyB8fCBmcmVxID4gMmUzIHx8ICggISBpc0xpbmVhciAmJiBmcmVxID4gMjUwICkgfHxcblx0XHRcdFx0XHQgKCAoICEgX3JhZGlhbCB8fCBpc0R1YWxWZXJ0aWNhbCApICYmICggISBpc0xpbmVhciAmJiBmcmVxID4gMTI1IHx8IGZyZXEgPiAxZTMgKSApIClcblx0XHRcdFx0XHRhbGxvd2VkTGFiZWxzLnB1c2goJ0cnKTtcblx0XHRcdFx0aWYgKCBpc0xvZyB8fCBmcmVxID4gNGUzIHx8ICggISBpc0xpbmVhciAmJiBmcmVxID4gNTAwICkgfHxcblx0XHRcdFx0XHQgKCAoICEgX3JhZGlhbCB8fCBpc0R1YWxWZXJ0aWNhbCApICYmICggISBpc0xpbmVhciAmJiBmcmVxID4gMjUwIHx8IGZyZXEgPiAyZTMgKSApIClcblx0XHRcdFx0XHRhbGxvd2VkTGFiZWxzLnB1c2goJ0UnKTtcblx0XHRcdFx0aWYgKCBpc0xpbmVhciAmJiBmcmVxID4gNGUzIHx8XG5cdFx0XHRcdFx0ICggKCAhIF9yYWRpYWwgfHwgaXNEdWFsVmVydGljYWwgKSAmJiAoIGlzTG9nIHx8IGZyZXEgPiAyZTMgfHwgKCAhIGlzTGluZWFyICYmIGZyZXEgPiA1MDAgKSApICkgKVxuXHRcdFx0XHRcdGFsbG93ZWRMYWJlbHMucHVzaCgnRCcsJ0YnLCdBJywnQicpO1xuXHRcdFx0XHRpZiAoICEgYWxsb3dlZExhYmVscy5pbmNsdWRlcyggbGFiZWxbMF0gKSApXG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNraXAgdGhpcyBsYWJlbFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsaW5lYXIgc2NhbGVcblx0XHRcdGlmICggeCA+PSBwcmV2WCArIGxhYmVsV2lkdGhYIC8gMiAmJiB4IDw9IGFuYWx5emVyV2lkdGggKSB7XG5cdFx0XHRcdF9zY2FsZVguZmlsbFRleHQoIGxhYmVsLCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgPT0gLTEgPyBhbmFseXplcldpZHRoIC0geCA6IGluaXRpYWxYICsgeCwgeSwgbWF4VyApO1xuXHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgfHwgKCBfbWlycm9yICYmICggeCA+IGxhYmVsV2lkdGhYIHx8IF9taXJyb3IgPT0gMSApICkgKVxuXHRcdFx0XHRcdF9zY2FsZVguZmlsbFRleHQoIGxhYmVsLCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgIT0gMSA/IGFuYWx5emVyV2lkdGggKyB4IDogKCBpbml0aWFsWCB8fCBjYW52YXMud2lkdGggKSAtIHgsIHksIG1heFcgKTtcblx0XHRcdFx0cHJldlggPSB4ICsgTWF0aC5taW4oIG1heFcsIF9zY2FsZVgubWVhc3VyZVRleHQoIGxhYmVsICkud2lkdGggKSAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJhZGlhbCBzY2FsZVxuXHRcdFx0aWYgKCB4ID49IHByZXZSICsgbGFiZWxXaWR0aFIgJiYgeCA8IGFuYWx5emVyV2lkdGggLSBsYWJlbFdpZHRoUiApIHsgLy8gYXZvaWQgb3ZlcmxhcHBpbmcgdGhlIGxhc3QgbGFiZWwgb3ZlciB0aGUgZmlyc3Qgb25lXG5cdFx0XHRcdHJhZGlhbExhYmVsKCBpc0R1YWxIb3Jpem9udGFsICYmIF9taXJyb3IgPT0gMSA/IGFuYWx5emVyV2lkdGggLSB4IDogeCwgbGFiZWwgKTtcblx0XHRcdFx0aWYgKCBpc0R1YWxIb3Jpem9udGFsIHx8ICggX21pcnJvciAmJiAoIHggPiBsYWJlbFdpZHRoUiB8fCBfbWlycm9yID09IDEgKSApICkgLy8gYXZvaWQgb3ZlcmxhcHBpbmcgb2YgZmlyc3QgbGFiZWxzIG9uIG1pcnJvciBtb2RlXG5cdFx0XHRcdFx0cmFkaWFsTGFiZWwoIGlzRHVhbEhvcml6b250YWwgJiYgX21pcnJvciAhPSAtMSA/IGFuYWx5emVyV2lkdGggKyB4IDogLXgsIGxhYmVsICk7XG5cdFx0XHRcdHByZXZSID0geDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBjYW52YXNcblx0ICogdGhpcyBpcyBjYWxsZWQgNjAgdGltZXMgcGVyIHNlY29uZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuXHQgKi9cblx0X2RyYXcoIHRpbWVzdGFtcCApIHtcblx0XHQvLyBzY2hlZHVsZSBuZXh0IGNhbnZhcyB1cGRhdGVcblx0XHR0aGlzLl9ydW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGltZXN0YW1wID0+IHRoaXMuX2RyYXcoIHRpbWVzdGFtcCApICk7XG5cblx0XHQvLyBmcmFtZSByYXRlIGNvbnRyb2xcblx0XHRjb25zdCBlbGFwc2VkICAgICAgICA9IHRpbWVzdGFtcCAtIHRoaXMuX3RpbWUsIC8vIHRpbWUgc2luY2UgbGFzdCBGUFMgY29tcHV0YXRpb25cblx0XHRcdCAgZnJhbWVUaW1lICAgICAgPSB0aW1lc3RhbXAgLSB0aGlzLl9sYXN0LCAvLyB0aW1lIHNpbmNlIGxhc3QgcmVuZGVyZWQgZnJhbWVcblx0XHRcdCAgdGFyZ2V0SW50ZXJ2YWwgPSB0aGlzLl9tYXhGUFMgPyA5NzUgLyB0aGlzLl9tYXhGUFMgOiAwOyAvLyBzbWFsbCB0b2xlcmFuY2UgZm9yIGJlc3QgcmVzdWx0c1xuXG5cdFx0aWYgKCBmcmFtZVRpbWUgPCB0YXJnZXRJbnRlcnZhbCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9sYXN0ID0gdGltZXN0YW1wIC0gKCB0YXJnZXRJbnRlcnZhbCA/IGZyYW1lVGltZSAlIHRhcmdldEludGVydmFsIDogMCApOyAvLyB0aGFua3MgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NzcyMjIwLzIzNzAzODVcblx0XHR0aGlzLl9mcmFtZXMrKztcblxuXHRcdGlmICggZWxhcHNlZCA+PSAxMDAwICkgeyAvLyB1cGRhdGUgRlBTIGV2ZXJ5IHNlY29uZFxuXHRcdFx0dGhpcy5fZnBzID0gdGhpcy5fZnJhbWVzIC8gZWxhcHNlZCAqIDEwMDA7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRpbWVzdGFtcDtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGxvY2FsIGNvbnN0YW50c1xuXG5cdFx0Y29uc3QgeyBpc0FscGhhLFxuXHRcdFx0ICAgIGlzQmFuZHMsXG5cdFx0XHQgICAgaXNMZWRzLFxuXHRcdFx0ICAgIGlzTHVtaSxcblx0XHRcdCAgICBpc09jdGF2ZXMsXG5cdFx0XHQgICAgaXNPdXRsaW5lLFxuXHRcdFx0ICAgIGlzUm91bmQsXG5cdFx0XHQgICAgbm9MZWRHYXAgfSAgICAgPSB0aGlzLl9mbGcsXG5cblx0XHRcdCAgeyBhbmFseXplckhlaWdodCxcblx0XHRcdCAgICBjZW50ZXJYLFxuXHRcdFx0ICAgIGNlbnRlclksXG5cdFx0XHQgICAgY2hhbm5lbENvb3Jkcyxcblx0XHRcdCAgICBjaGFubmVsSGVpZ2h0LFxuXHRcdFx0ICAgIGNoYW5uZWxHYXAsXG5cdFx0XHQgICAgaW5pdGlhbFgsXG5cdFx0XHQgICAgaW5uZXJSYWRpdXMsXG5cdFx0XHQgICAgb3V0ZXJSYWRpdXMgfSAgPSB0aGlzLl9hdXgsXG5cblx0XHRcdCAgeyBfYmFycyxcblx0XHRcdCAgICBjYW52YXMsXG5cdFx0XHQgICAgX2NhbnZhc0dyYWRpZW50cyxcblx0XHRcdCAgICBfY2hMYXlvdXQsXG5cdFx0XHQgICAgX2NvbG9yTW9kZSxcblx0XHRcdCAgICBfY3R4LFxuXHRcdFx0ICAgIF9lbmVyZ3ksXG5cdFx0XHQgICAgZmlsbEFscGhhLFxuXHRcdFx0ICAgIF9mcHMsXG5cdFx0XHQgICAgX2xpbmVhckFtcGxpdHVkZSxcblx0XHRcdCAgICBfbGluZVdpZHRoLFxuXHRcdFx0ICAgIG1heERlY2liZWxzLFxuXHRcdFx0ICAgIG1pbkRlY2liZWxzLFxuXHRcdFx0ICAgIF9taXJyb3IsXG5cdFx0XHQgICAgX21vZGUsXG5cdFx0XHQgICAgb3ZlcmxheSxcblx0XHRcdCAgICBfcmFkaWFsLFxuXHRcdFx0ICAgIHNob3dCZ0NvbG9yLFxuXHRcdFx0ICAgIHNob3dQZWFrcyxcblx0XHRcdCAgICB1c2VDYW52YXMsXG5cdFx0XHQgICAgX3dlaWdodGluZ0ZpbHRlciB9ID0gdGhpcyxcblxuXHRcdFx0ICBjYW52YXNYICAgICAgICAgID0gdGhpcy5fc2NhbGVYLmNhbnZhcyxcblx0XHRcdCAgY2FudmFzUiAgICAgICAgICA9IHRoaXMuX3NjYWxlUi5jYW52YXMsXG5cdFx0XHQgIGhvbGRGcmFtZXMgICAgICAgPSBfZnBzID4+IDEsIC8vIG51bWJlciBvZiBmcmFtZXMgaW4gaGFsZiBhIHNlY29uZFxuXHRcdFx0ICBpc0R1YWxDb21iaW5lZCAgID0gX2NoTGF5b3V0ID09IENIQU5ORUxfQ09NQklORUQsXG5cdFx0XHQgIGlzRHVhbEhvcml6b250YWwgPSBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9IT1JJWk9OVEFMLFxuXHRcdFx0ICBpc0R1YWxWZXJ0aWNhbCAgID0gX2NoTGF5b3V0ID09IENIQU5ORUxfVkVSVElDQUwsXG5cdFx0XHQgIGlzU2luZ2xlICAgICAgICAgPSBfY2hMYXlvdXQgPT0gQ0hBTk5FTF9TSU5HTEUsXG5cdFx0XHQgIGlzVHJ1ZUxlZHMgICAgICAgPSBpc0xlZHMgJiYgdGhpcy5fdHJ1ZUxlZHMgJiYgX2NvbG9yTW9kZSA9PSBDT0xPUl9HUkFESUVOVCxcblx0XHRcdCAgYW5hbHl6ZXJXaWR0aCAgICA9IF9yYWRpYWwgPyBjYW52YXMud2lkdGggOiB0aGlzLl9hdXguYW5hbHl6ZXJXaWR0aCxcblx0XHRcdCAgZmluYWxYICAgICAgICAgICA9IGluaXRpYWxYICsgYW5hbHl6ZXJXaWR0aCxcblx0XHRcdCAgc2hvd1BlYWtMaW5lICAgICA9IHNob3dQZWFrcyAmJiB0aGlzLl9wZWFrTGluZSAmJiBfbW9kZSA9PSBNT0RFX0dSQVBILFxuXHRcdFx0ICBtYXhCYXJIZWlnaHQgICAgID0gX3JhZGlhbCA/IG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgOiBhbmFseXplckhlaWdodCxcblx0XHRcdCAgZGJSYW5nZSBcdFx0ICAgPSBtYXhEZWNpYmVscyAtIG1pbkRlY2liZWxzLFxuXHRcdFx0ICBbIGxlZENvdW50LCBsZWRTcGFjZUgsIGxlZFNwYWNlViwgbGVkSGVpZ2h0IF0gPSB0aGlzLl9sZWRzIHx8IFtdO1xuXG5cdFx0aWYgKCBfZW5lcmd5LnZhbCA+IDAgJiYgX2ZwcyA+IDAgKVxuXHRcdFx0dGhpcy5fc3BpbkFuZ2xlICs9IHRoaXMuX3NwaW5TcGVlZCAqIFRBVSAvIDYwIC8gX2ZwczsgLy8gc3BpblNwZWVkICogYW5nbGUgaW5jcmVtZW50IHBlciBmcmFtZSBmb3IgMSBSUE1cblxuXHRcdC8qIEhFTFBFUiBGVU5DVElPTlMgKi9cblxuXHRcdC8vIGNyZWF0ZSBSZWZsZXggZWZmZWN0XG5cdFx0Y29uc3QgZG9SZWZsZXggPSBjaGFubmVsID0+IHtcblx0XHRcdGlmICggdGhpcy5fcmVmbGV4UmF0aW8gPiAwICYmICEgaXNMdW1pICYmICEgX3JhZGlhbCApIHtcblx0XHRcdFx0bGV0IHBvc1ksIGhlaWdodDtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZmxleEZpdCB8fCBpc0R1YWxWZXJ0aWNhbCApIHsgLy8gYWx3YXlzIGZpdCByZWZsZXggaW4gdmVydGljYWwgc3RlcmVvIG1vZGVcblx0XHRcdFx0XHRwb3NZICAgPSBpc0R1YWxWZXJ0aWNhbCAmJiBjaGFubmVsID09IDAgPyBjaGFubmVsSGVpZ2h0ICsgY2hhbm5lbEdhcCA6IDA7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gY2hhbm5lbEhlaWdodCAtIGFuYWx5emVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHBvc1kgICA9IGNhbnZhcy5oZWlnaHQgLSBhbmFseXplckhlaWdodCAqIDI7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gYW5hbHl6ZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfY3R4LnNhdmUoKTtcblxuXHRcdFx0XHQvLyBzZXQgYWxwaGEgYW5kIGJyaWdodG5lc3MgZm9yIHRoZSByZWZsZWN0aW9uXG5cdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnJlZmxleEFscGhhO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmbGV4QnJpZ2h0ICE9IDEgKVxuXHRcdFx0XHRcdF9jdHguZmlsdGVyID0gYGJyaWdodG5lc3MoJHt0aGlzLnJlZmxleEJyaWdodH0pYDtcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIHJlZmxlY3Rpb25cblx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0xLCAwLCBjYW52YXMuaGVpZ2h0ICk7XG5cdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXMsIDAsIGNoYW5uZWxDb29yZHNbIGNoYW5uZWwgXS5jaGFubmVsVG9wLCBjYW52YXMud2lkdGgsIGFuYWx5emVySGVpZ2h0LCAwLCBwb3NZLCBjYW52YXMud2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRcdF9jdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRyYXcgc2NhbGUgb24gWC1heGlzXG5cdFx0Y29uc3QgZHJhd1NjYWxlWCA9ICgpID0+IHtcblx0XHRcdGlmICggdGhpcy5zaG93U2NhbGVYICkge1xuXHRcdFx0XHRpZiAoIF9yYWRpYWwgKSB7XG5cdFx0XHRcdFx0X2N0eC5zYXZlKCk7XG5cdFx0XHRcdFx0X2N0eC50cmFuc2xhdGUoIGNlbnRlclgsIGNlbnRlclkgKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX3NwaW5TcGVlZCApXG5cdFx0XHRcdFx0XHRfY3R4LnJvdGF0ZSggdGhpcy5fc3BpbkFuZ2xlICsgSEFMRl9QSSApO1xuXHRcdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXNSLCAtY2FudmFzUi53aWR0aCA+PiAxLCAtY2FudmFzUi53aWR0aCA+PiAxICk7XG5cdFx0XHRcdFx0X2N0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdF9jdHguZHJhd0ltYWdlKCBjYW52YXNYLCAwLCBjYW52YXMuaGVpZ2h0IC0gY2FudmFzWC5oZWlnaHQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXR1cm5zIHRoZSBnYWluIChpbiBkQikgZm9yIGEgZ2l2ZW4gZnJlcXVlbmN5LCBjb25zaWRlcmluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHdlaWdodGluZyBmaWx0ZXJcblx0XHRjb25zdCB3ZWlnaHRpbmdkQiA9IGZyZXEgPT4ge1xuXHRcdFx0Y29uc3QgZjIgPSBmcmVxICoqIDIsXG5cdFx0XHRcdCAgU1EyMF82ICA9IDQyNC4zNixcblx0XHRcdFx0ICBTUTEwN183ID0gMTE1OTkuMjksXG5cdFx0XHRcdCAgU1ExNThfNSA9IDI1MTIyLjI1LFxuXHRcdFx0XHQgIFNRNzM3XzkgPSA1NDQ0OTYuNDEsXG5cdFx0XHRcdCAgU1ExMjE5NCA9IDE0ODY5MzYzNixcblx0XHRcdFx0ICBsaW5lYXJUb2RCID0gdmFsdWUgPT4gMjAgKiBNYXRoLmxvZzEwKCB2YWx1ZSApO1xuXG5cdFx0XHRzd2l0Y2ggKCBfd2VpZ2h0aW5nRmlsdGVyICkge1xuXHRcdFx0XHRjYXNlIEZJTFRFUl9BIDogLy8gQS13ZWlnaHRpbmcgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQS13ZWlnaHRpbmdcblx0XHRcdFx0XHRjb25zdCByQSA9ICggU1ExMjE5NCAqIGYyICoqIDIgKSAvICggKCBmMiArIFNRMjBfNiApICogTWF0aC5zcXJ0KCAoIGYyICsgU1ExMDdfNyApICogKCBmMiArIFNRNzM3XzkgKSApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAyICsgbGluZWFyVG9kQiggckEgKTtcblxuXHRcdFx0XHRjYXNlIEZJTFRFUl9CIDpcblx0XHRcdFx0XHRjb25zdCByQiA9ICggU1ExMjE5NCAqIGYyICogZnJlcSApIC8gKCAoIGYyICsgU1EyMF82ICkgKiBNYXRoLnNxcnQoIGYyICsgU1ExNThfNSApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAuMTcgKyBsaW5lYXJUb2RCKCByQiApO1xuXG5cdFx0XHRcdGNhc2UgRklMVEVSX0MgOlxuXHRcdFx0XHRcdGNvbnN0IHJDID0gKCBTUTEyMTk0ICogZjIgKSAvICggKCBmMiArIFNRMjBfNiApICogKCBmMiArIFNRMTIxOTQgKSApO1xuXHRcdFx0XHRcdHJldHVybiAuMDYgKyBsaW5lYXJUb2RCKCByQyApO1xuXG5cdFx0XHRcdGNhc2UgRklMVEVSX0QgOlxuXHRcdFx0XHRcdGNvbnN0IGggPSAoICggMTAzNzkxOC40OCAtIGYyICkgKiogMiArIDEwODA3NjguMTYgKiBmMiApIC8gKCAoIDk4MzczMjggLSBmMiApICoqIDIgKyAxMTcyMzc3NiAqIGYyICksXG5cdFx0XHRcdFx0XHQgIHJEID0gKCBmcmVxIC8gNi44OTY2ODg4NDk2NDc2ZS01ICkgKiBNYXRoLnNxcnQoIGggLyAoICggZjIgKyA3OTkxOS4yOSApICogKCBmMiArIDEzNDU2MDAgKSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmVhclRvZEIoIHJEICk7XG5cblx0XHRcdFx0Y2FzZSBGSUxURVJfNDY4IDogLy8gSVRVLVIgNDY4IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lUVS1SXzQ2OF9ub2lzZV93ZWlnaHRpbmdcblx0XHRcdFx0XHRjb25zdCBoMSA9IC00LjczNzMzODk4MTM3ODM4NGUtMjQgKiBmcmVxICoqIDYgKyAyLjA0MzgyODMzMzYwNjEyNWUtMTUgKiBmcmVxICoqIDQgLSAxLjM2Mzg5NDc5NTQ2MzYzOGUtNyAqIGYyICsgMSxcblx0XHRcdFx0XHRcdCAgaDIgPSAxLjMwNjYxMjI1NzQxMjgyNGUtMTkgKiBmcmVxICoqIDUgLSAyLjExODE1MDg4NzUxODY1NmUtMTEgKiBmcmVxICoqIDMgKyA1LjU1OTQ4ODAyMzQ5ODY0MmUtNCAqIGZyZXEsXG5cdFx0XHRcdFx0XHQgIHJJID0gMS4yNDYzMzI2Mzc1MzIxNDNlLTQgKiBmcmVxIC8gTWF0aC5oeXBvdCggaDEsIGgyICk7XG5cdFx0XHRcdFx0cmV0dXJuIDE4LjIgKyBsaW5lYXJUb2RCKCBySSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDsgLy8gdW5rbm93biBmaWx0ZXJcblx0XHR9XG5cblx0XHQvLyBkcmF3cyAoc3Ryb2tlKSBhIGJhciBmcm9tIHgseTEgdG8geCx5MlxuXHRcdGNvbnN0IHN0cm9rZUJhciA9ICggeCwgeTEsIHkyICkgPT4ge1xuXHRcdFx0X2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdF9jdHgubW92ZVRvKCB4LCB5MSApO1xuXHRcdFx0X2N0eC5saW5lVG8oIHgsIHkyICk7XG5cdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdC8vIGNvbmRpdGlvbmFsbHkgc3Ryb2tlcyBjdXJyZW50IHBhdGggb24gY2FudmFzXG5cdFx0Y29uc3Qgc3Ryb2tlSWYgPSBmbGFnID0+IHtcblx0XHRcdGlmICggZmxhZyAmJiBfbGluZVdpZHRoICkge1xuXHRcdFx0XHRjb25zdCBhbHBoYSA9IF9jdHguZ2xvYmFsQWxwaGE7XG5cdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydHMgYSB2YWx1ZSBpbiBbMDsxXSByYW5nZSB0byBhIGhlaWdodCBpbiBwaXhlbHMgdGhhdCBmaXRzIGludG8gdGhlIGN1cnJlbnQgTEVEIGVsZW1lbnRzXG5cdFx0Y29uc3QgbGVkUG9zWSA9IHZhbHVlID0+IE1hdGgubWF4KCAwLCAoIHZhbHVlICogbGVkQ291bnQgfCAwICkgKiAoIGxlZEhlaWdodCArIGxlZFNwYWNlViApIC0gbGVkU3BhY2VWICk7XG5cblx0XHQvLyB1cGRhdGUgZW5lcmd5IGluZm9ybWF0aW9uXG5cdFx0Y29uc3QgdXBkYXRlRW5lcmd5ID0gbmV3VmFsID0+IHtcblx0XHRcdF9lbmVyZ3kudmFsID0gbmV3VmFsO1xuXHRcdFx0aWYgKCBfZW5lcmd5LnBlYWsgPiAwICkge1xuXHRcdFx0XHRfZW5lcmd5LmhvbGQtLTtcblx0XHRcdFx0aWYgKCBfZW5lcmd5LmhvbGQgPCAwIClcblx0XHRcdFx0XHRfZW5lcmd5LnBlYWsgKz0gX2VuZXJneS5ob2xkIC8gKCBob2xkRnJhbWVzICogaG9sZEZyYW1lcyAvIDIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbmV3VmFsID49IF9lbmVyZ3kucGVhayApIHtcblx0XHRcdFx0X2VuZXJneS5wZWFrID0gbmV3VmFsO1xuXHRcdFx0XHRfZW5lcmd5LmhvbGQgPSBob2xkRnJhbWVzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIE1BSU4gRlVOQ1RJT04gKi9cblxuXHRcdGlmICggb3ZlcmxheSApXG5cdFx0XHRfY3R4LmNsZWFyUmVjdCggMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cblx0XHRsZXQgY3VycmVudEVuZXJneSA9IDA7XG5cblx0XHRjb25zdCBuQmFycyAgICAgPSBfYmFycy5sZW5ndGgsXG5cdFx0XHQgIG5DaGFubmVscyA9IGlzU2luZ2xlID8gMSA6IDI7XG5cblx0XHRmb3IgKCBsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBuQ2hhbm5lbHM7IGNoYW5uZWwrKyApIHtcblxuXHRcdFx0Y29uc3QgeyBjaGFubmVsVG9wLCBjaGFubmVsQm90dG9tLCBhbmFseXplckJvdHRvbSB9ID0gY2hhbm5lbENvb3Jkc1sgY2hhbm5lbCBdLFxuXHRcdFx0XHQgIGNoYW5uZWxHcmFkaWVudCAgPSB0aGlzLl9ncmFkaWVudHNbIHRoaXMuX3NlbGVjdGVkR3JhZHNbIGNoYW5uZWwgXSBdLFxuXHRcdFx0XHQgIGNvbG9yU3RvcHMgICAgICAgPSBjaGFubmVsR3JhZGllbnQuY29sb3JTdG9wcyxcblx0XHRcdFx0ICBjb2xvckNvdW50ICAgICAgID0gY29sb3JTdG9wcy5sZW5ndGgsXG5cdFx0XHRcdCAgYmdDb2xvciAgICAgICAgICA9ICggISBzaG93QmdDb2xvciB8fCBpc0xlZHMgJiYgISBvdmVybGF5ICkgPyAnIzAwMCcgOiBjaGFubmVsR3JhZGllbnQuYmdDb2xvcixcblx0XHRcdFx0ICByYWRpYWxEaXJlY3Rpb24gID0gaXNEdWFsVmVydGljYWwgJiYgX3JhZGlhbCAmJiBjaGFubmVsID8gLTEgOiAxLCAvLyAxID0gb3V0d2FyZHMsIC0xID0gaW53YXJkc1xuXHRcdFx0XHQgIGludmVydGVkQ2hhbm5lbCAgPSAoICEgY2hhbm5lbCAmJiBfbWlycm9yID09IC0xICkgfHwgKCBjaGFubmVsICYmIF9taXJyb3IgPT0gMSApLFxuXHRcdFx0XHQgIHJhZGlhbE9mZnNldFggICAgPSAhIGlzRHVhbEhvcml6b250YWwgfHwgKCBjaGFubmVsICYmIF9taXJyb3IgIT0gMSApID8gMCA6IGFuYWx5emVyV2lkdGggPj4gKCBjaGFubmVsIHx8ICEgaW52ZXJ0ZWRDaGFubmVsICksXG5cdFx0XHRcdCAgYW5ndWxhckRpcmVjdGlvbiA9IGlzRHVhbEhvcml6b250YWwgJiYgaW52ZXJ0ZWRDaGFubmVsID8gLTEgOiAxOyAgLy8gMSA9IGNsb2Nrd2lzZSwgLTEgPSBjb3VudGVyY2xvY2t3aXNlXG4vKlxuXHRcdFx0RXhwYW5kZWQgbG9naWMgZm9yIHJhZGlhbE9mZnNldFggYW5kIGFuZ3VsYXJEaXJlY3Rpb246XG5cblx0XHRcdGxldCByYWRpYWxPZmZzZXRYID0gMCxcblx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IDE7XG5cblx0XHRcdGlmICggaXNEdWFsSG9yaXpvbnRhbCApIHtcblx0XHRcdFx0aWYgKCBjaGFubmVsID09IDAgKSB7IC8vIExFRlQgY2hhbm5lbFxuXHRcdFx0XHRcdGlmICggX21pcnJvciA9PSAtMSApIHtcblx0XHRcdFx0XHRcdHJhZGlhbE9mZnNldFggPSBhbmFseXplcldpZHRoO1xuXHRcdFx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyYWRpYWxPZmZzZXRYID0gYW5hbHl6ZXJXaWR0aCA+PiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAgICAgICAgICAgICAgICAvLyBSSUdIVCBjaGFubmVsXG5cdFx0XHRcdFx0aWYgKCBfbWlycm9yID09IDEgKSB7XG5cdFx0XHRcdFx0XHRyYWRpYWxPZmZzZXRYID0gYW5hbHl6ZXJXaWR0aCA+PiAxO1xuXHRcdFx0XHRcdFx0YW5ndWxhckRpcmVjdGlvbiA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuKi9cblx0XHRcdC8vIGRyYXcgc2NhbGUgb24gWS1heGlzICh1c2VzOiBjaGFubmVsLCBjaGFubmVsVG9wKVxuXHRcdFx0Y29uc3QgZHJhd1NjYWxlWSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2NhbGVXaWR0aCA9IGNhbnZhc1guaGVpZ2h0LFxuXHRcdFx0XHRcdCAgZm9udFNpemUgICA9IHNjYWxlV2lkdGggPj4gMSxcblx0XHRcdFx0XHQgIG1heCAgICAgICAgPSBfbGluZWFyQW1wbGl0dWRlID8gMTAwIDogbWF4RGVjaWJlbHMsXG5cdFx0XHRcdFx0ICBtaW4gICAgICAgID0gX2xpbmVhckFtcGxpdHVkZSA/IDAgOiBtaW5EZWNpYmVscyxcblx0XHRcdFx0XHQgIGluY3IgICAgICAgPSBfbGluZWFyQW1wbGl0dWRlID8gMjAgOiA1LFxuXHRcdFx0XHRcdCAgaW50ZXJ2YWwgICA9IGFuYWx5emVySGVpZ2h0IC8gKCBtYXggLSBtaW4gKSxcblx0XHRcdFx0XHQgIGF0U3RhcnQgICAgPSBfbWlycm9yICE9IC0xICYmICggISBpc0R1YWxIb3Jpem9udGFsIHx8IGNoYW5uZWwgPT0gMCB8fCBfbWlycm9yID09IDEgKSxcblx0XHRcdFx0XHQgIGF0RW5kICAgICAgPSBfbWlycm9yICE9IDEgJiYgKCAhIGlzRHVhbEhvcml6b250YWwgfHwgY2hhbm5lbCAhPSBfbWlycm9yICk7XG5cblx0XHRcdFx0X2N0eC5zYXZlKCk7XG5cdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gU0NBTEVZX0xBQkVMX0NPTE9SO1xuXHRcdFx0XHRfY3R4LmZvbnQgPSBgJHtmb250U2l6ZX1weCAke0ZPTlRfRkFNSUxZfWA7XG5cdFx0XHRcdF9jdHgudGV4dEFsaWduID0gJ3JpZ2h0Jztcblx0XHRcdFx0X2N0eC5saW5lV2lkdGggPSAxO1xuXG5cdFx0XHRcdGZvciAoIGxldCB2YWwgPSBtYXg7IHZhbCA+IG1pbjsgdmFsIC09IGluY3IgKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zWSA9IGNoYW5uZWxUb3AgKyAoIG1heCAtIHZhbCApICogaW50ZXJ2YWwsXG5cdFx0XHRcdFx0XHQgIGV2ZW4gPSAoIHZhbCAlIDIgPT0gMCApIHwgMDtcblxuXHRcdFx0XHRcdGlmICggZXZlbiApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhYmVsWSA9IHBvc1kgKyBmb250U2l6ZSAqICggcG9zWSA9PSBjaGFubmVsVG9wID8gLjggOiAuMzUgKTtcblx0XHRcdFx0XHRcdGlmICggYXRTdGFydCApXG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbFRleHQoIHZhbCwgc2NhbGVXaWR0aCAqIC44NSwgbGFiZWxZICk7XG5cdFx0XHRcdFx0XHRpZiAoIGF0RW5kIClcblx0XHRcdFx0XHRcdFx0X2N0eC5maWxsVGV4dCggdmFsLCAoIGlzRHVhbEhvcml6b250YWwgPyBhbmFseXplcldpZHRoIDogY2FudmFzLndpZHRoICkgLSBzY2FsZVdpZHRoICogLjEsIGxhYmVsWSApO1xuXHRcdFx0XHRcdFx0X2N0eC5zdHJva2VTdHlsZSA9IFNDQUxFWV9MQUJFTF9DT0xPUjtcblx0XHRcdFx0XHRcdF9jdHguc2V0TGluZURhc2goWzIsNF0pO1xuXHRcdFx0XHRcdFx0X2N0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X2N0eC5zdHJva2VTdHlsZSA9IFNDQUxFWV9NSURMSU5FX0NPTE9SO1xuXHRcdFx0XHRcdFx0X2N0eC5zZXRMaW5lRGFzaChbMiw4XSk7XG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdF9jdHgubW92ZVRvKCBpbml0aWFsWCArIHNjYWxlV2lkdGggKiBldmVuICogYXRTdGFydCwgfn5wb3NZICsgLjUgKTsgLy8gZm9yIHNoYXJwIDFweCBsaW5lIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM4Nzk0MDIvMjM3MDM4NSlcblx0XHRcdFx0XHRfY3R4LmxpbmVUbyggZmluYWxYIC0gc2NhbGVXaWR0aCAqIGV2ZW4gKiBhdEVuZCwgfn5wb3NZICsgLjUgKTtcblx0XHRcdFx0XHRfY3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRlQgYmluIGRhdGEgaW50ZXJwb2xhdGlvbiAodXNlcyBmZnREYXRhKVxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhdGUgPSAoIGJpbiwgcmF0aW8gKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmZ0RGF0YVsgYmluIF0gKyAoIGJpbiA8IGZmdERhdGEubGVuZ3RoIC0gMSA/ICggZmZ0RGF0YVsgYmluICsgMSBdIC0gZmZ0RGF0YVsgYmluIF0gKSAqIHJhdGlvIDogMCApO1xuXHRcdFx0XHRyZXR1cm4gaXNOYU4oIHZhbHVlICkgPyAtSW5maW5pdHkgOiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29udmVydHMgYSBnaXZlbiBYLWNvb3JkaW5hdGUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYW5nbGUgaW4gcmFkaWFsIG1vZGUgKHVzZXMgYW5ndWxhckRpcmVjdGlvbilcblx0XHRcdGNvbnN0IGdldEFuZ2xlID0gKCB4LCBkaXIgPSBhbmd1bGFyRGlyZWN0aW9uICkgPT4gZGlyICogVEFVICogKCAoIHggKyByYWRpYWxPZmZzZXRYICkgLyBjYW52YXMud2lkdGggKSArIHRoaXMuX3NwaW5BbmdsZTtcblxuXHRcdFx0Ly8gY29udmVydHMgcGxhbmFyIFgsWSBjb29yZGluYXRlcyB0byByYWRpYWwgY29vcmRpbmF0ZXMgKHVzZXM6IGdldEFuZ2xlKCksIHJhZGlhbERpcmVjdGlvbilcblx0XHRcdGNvbnN0IHJhZGlhbFhZID0gKCB4LCB5LCBkaXIgKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGhlaWdodCA9IGlubmVyUmFkaXVzICsgeSAqIHJhZGlhbERpcmVjdGlvbixcblx0XHRcdFx0XHQgIGFuZ2xlICA9IGdldEFuZ2xlKCB4LCBkaXIgKTtcblx0XHRcdFx0cmV0dXJuIFsgY2VudGVyWCArIGhlaWdodCAqIE1hdGguY29zKCBhbmdsZSApLCBjZW50ZXJZICsgaGVpZ2h0ICogTWF0aC5zaW4oIGFuZ2xlICkgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZHJhd3MgYSBwb2x5Z29uIG9mIHdpZHRoIGB3YCBhbmQgaGVpZ2h0IGBoYCBhdCAoeCx5KSBpbiByYWRpYWwgbW9kZSAodXNlczogYW5ndWxhckRpcmVjdGlvbiwgcmFkaWFsRGlyZWN0aW9uKVxuXHRcdFx0Y29uc3QgcmFkaWFsUG9seSA9ICggeCwgeSwgdywgaCwgc3Ryb2tlICkgPT4ge1xuXHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKCBjb25zdCBkaXIgb2YgKCBfbWlycm9yICYmICEgaXNEdWFsSG9yaXpvbnRhbCA/IFsxLC0xXSA6IFsgYW5ndWxhckRpcmVjdGlvbiBdICkgKSB7XG5cdFx0XHRcdFx0Y29uc3QgWyBzdGFydEFuZ2xlLCBlbmRBbmdsZSBdID0gaXNSb3VuZCA/IFsgZ2V0QW5nbGUoIHgsIGRpciApLCBnZXRBbmdsZSggeCArIHcsIGRpciApIF0gOiBbXTtcblx0XHRcdFx0XHRfY3R4Lm1vdmVUbyggLi4ucmFkaWFsWFkoIHgsIHksIGRpciApICk7XG5cdFx0XHRcdFx0X2N0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCB4LCB5ICsgaCwgZGlyICkgKTtcblx0XHRcdFx0XHRpZiAoIGlzUm91bmQgKVxuXHRcdFx0XHRcdFx0X2N0eC5hcmMoIGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzICsgKCB5ICsgaCApICogcmFkaWFsRGlyZWN0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlyICE9IDEgKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIHggKyB3LCB5ICsgaCwgZGlyICkgKTtcblx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIHggKyB3LCB5LCBkaXIgKSApO1xuXHRcdFx0XHRcdGlmICggaXNSb3VuZCAmJiAhIHN0cm9rZSApIC8vIGNsb3NlIHRoZSBib3R0b20gbGluZSBvbmx5IHdoZW4gbm90IGluIG91dGxpbmUgbW9kZVxuXHRcdFx0XHRcdFx0X2N0eC5hcmMoIGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzICsgeSAqIHJhZGlhbERpcmVjdGlvbiwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGRpciA9PSAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Ryb2tlSWYoIHN0cm9rZSApO1xuXHRcdFx0XHRfY3R4LmZpbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IGZpbGxTdHlsZSBhbmQgc3Ryb2tlU3R5bGUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgY29sb3JNb2RlICh1c2VzOiBjaGFubmVsLCBjb2xvclN0b3BzLCBjb2xvckNvdW50KVxuXHRcdFx0Y29uc3Qgc2V0QmFyQ29sb3IgPSAoIHZhbHVlID0gMCwgYmFySW5kZXggPSAwICkgPT4ge1xuXHRcdFx0XHRsZXQgY29sb3I7XG5cdFx0XHRcdC8vIGZvciBncmFwaCBtb2RlLCBhbHdheXMgdXNlIHRoZSBjaGFubmVsIGdyYWRpZW50IChpZ25vcmUgY29sb3JNb2RlKVxuXHRcdFx0XHRpZiAoICggX2NvbG9yTW9kZSA9PSBDT0xPUl9HUkFESUVOVCAmJiAhIGlzVHJ1ZUxlZHMgKSB8fCBfbW9kZSA9PSBNT0RFX0dSQVBIIClcblx0XHRcdFx0XHRjb2xvciA9IF9jYW52YXNHcmFkaWVudHNbIGNoYW5uZWwgXTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJbmRleCA9IF9jb2xvck1vZGUgPT0gQ09MT1JfQkFSX0lOREVYID8gYmFySW5kZXggJSBjb2xvckNvdW50IDogY29sb3JTdG9wcy5maW5kTGFzdEluZGV4KCBpdGVtID0+IGlzTGVkcyA/IGxlZFBvc1koIHZhbHVlICkgPD0gbGVkUG9zWSggaXRlbS5sZXZlbCApIDogdmFsdWUgPD0gaXRlbS5sZXZlbCApO1xuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JTdG9wc1sgc2VsZWN0ZWRJbmRleCBdLmNvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gX2N0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDSEFOTkVMIFNUQVJUXG5cblx0XHRcdGlmICggdXNlQ2FudmFzICkge1xuXHRcdFx0XHQvLyBzZXQgdHJhbnNmb3JtIChob3Jpem9udGFsIGZsaXAgYW5kIHRyYW5zbGF0aW9uKSBmb3IgZHVhbC1ob3Jpem9udGFsIGxheW91dFxuXHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgJiYgISBfcmFkaWFsICkge1xuXHRcdFx0XHQgIFx0Y29uc3QgdHJhbnNsYXRlWCA9IGFuYWx5emVyV2lkdGggKiAoIGNoYW5uZWwgKyBpbnZlcnRlZENoYW5uZWwgKSxcblx0XHRcdFx0ICBcdFx0ICBmbGlwWCAgICAgID0gaW52ZXJ0ZWRDaGFubmVsID8gLTEgOiAxO1xuXG5cdFx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIGZsaXBYLCAwLCAwLCAxLCB0cmFuc2xhdGVYLCAwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaWxsIHRoZSBhbmFseXplciBiYWNrZ3JvdW5kIGlmIG5lZWRlZCAobm90IG92ZXJsYXkgb3Igb3ZlcmxheSArIHNob3dCZ0NvbG9yKVxuXHRcdFx0XHRpZiAoICEgb3ZlcmxheSB8fCBzaG93QmdDb2xvciApIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJsYXkgKVxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IHRoaXMuYmdBbHBoYTtcblxuXHRcdFx0XHRcdF9jdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcblxuXHRcdFx0XHRcdC8vIGV4Y2x1ZGUgdGhlIHJlZmxlY3Rpb24gYXJlYSB3aGVuIG92ZXJsYXkgaXMgdHJ1ZSBhbmQgcmVmbGV4QWxwaGEgPT0gMSAoYXZvaWRzIGFscGhhIG92ZXIgYWxwaGEgZGlmZmVyZW5jZSwgaW4gY2FzZSBiZ0FscGhhIDwgMSlcblx0XHRcdFx0XHRpZiAoIGNoYW5uZWwgPT0gMCB8fCAoICEgX3JhZGlhbCAmJiAhIGlzRHVhbENvbWJpbmVkICkgKVxuXHRcdFx0XHRcdFx0X2N0eC5maWxsUmVjdCggaW5pdGlhbFgsIGNoYW5uZWxUb3AgLSBjaGFubmVsR2FwLCBhbmFseXplcldpZHRoLCAoIG92ZXJsYXkgJiYgdGhpcy5yZWZsZXhBbHBoYSA9PSAxID8gYW5hbHl6ZXJIZWlnaHQgOiBjaGFubmVsSGVpZ2h0ICkgKyBjaGFubmVsR2FwICk7XG5cblx0XHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRyYXcgZEIgc2NhbGUgKFktYXhpcykgLSBhdm9pZCBkcmF3aW5nIGl0IHR3aWNlIG9uICdkdWFsLWNvbWJpbmVkJyBjaGFubmVsIGxheW91dFxuXHRcdFx0XHRpZiAoIHRoaXMuc2hvd1NjYWxlWSAmJiAhIGlzTHVtaSAmJiAhIF9yYWRpYWwgJiYgKCBjaGFubmVsID09IDAgfHwgISBpc0R1YWxDb21iaW5lZCApIClcblx0XHRcdFx0XHRkcmF3U2NhbGVZKCk7XG5cblx0XHRcdFx0Ly8gc2V0IGxpbmUgd2lkdGggYW5kIGRhc2ggZm9yIExFRHMgZWZmZWN0XG5cdFx0XHRcdGlmICggaXNMZWRzICkge1xuXHRcdFx0XHRcdF9jdHguc2V0TGluZURhc2goIFsgbGVkSGVpZ2h0LCBsZWRTcGFjZVYgXSApO1xuXHRcdFx0XHRcdF9jdHgubGluZVdpZHRoID0gX2JhcnNbMF0ud2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSAvLyBmb3Igb3V0bGluZSBlZmZlY3QgZW5zdXJlIGxpbmV3aWR0aCBpcyBub3QgZ3JlYXRlciB0aGFuIGhhbGYgdGhlIGJhciB3aWR0aFxuXHRcdFx0XHRcdF9jdHgubGluZVdpZHRoID0gaXNPdXRsaW5lID8gTWF0aC5taW4oIF9saW5lV2lkdGgsIF9iYXJzWzBdLndpZHRoIC8gMiApIDogX2xpbmVXaWR0aDtcblxuXHRcdFx0XHQvLyBzZXQgY2xpcHBpbmcgcmVnaW9uXG5cdFx0XHRcdF9jdHguc2F2ZSgpO1xuXHRcdFx0XHRpZiAoICEgX3JhZGlhbCApIHtcblx0XHRcdFx0XHRjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG5cdFx0XHRcdFx0cmVnaW9uLnJlY3QoIDAsIGNoYW5uZWxUb3AsIGNhbnZhcy53aWR0aCwgYW5hbHl6ZXJIZWlnaHQgKTtcblx0XHRcdFx0XHRfY3R4LmNsaXAoIHJlZ2lvbiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gaWYgKCB1c2VDYW52YXMgKVxuXG5cdFx0XHQvLyBnZXQgYSBuZXcgYXJyYXkgb2YgZGF0YSBmcm9tIHRoZSBGRlRcblx0XHRcdGxldCBmZnREYXRhID0gdGhpcy5fZmZ0RGF0YVsgY2hhbm5lbCBdO1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGNoYW5uZWwgXS5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoIGZmdERhdGEgKTtcblxuXHRcdFx0Ly8gYXBwbHkgd2VpZ2h0aW5nXG5cdFx0XHRpZiAoIF93ZWlnaHRpbmdGaWx0ZXIgKVxuXHRcdFx0XHRmZnREYXRhID0gZmZ0RGF0YS5tYXAoICggdmFsLCBpZHggKSA9PiB2YWwgKyB3ZWlnaHRpbmdkQiggdGhpcy5fYmluVG9GcmVxKCBpZHggKSApICk7XG5cblx0XHRcdC8vIHN0YXJ0IGRyYXdpbmcgcGF0aCAoZm9yIGdyYXBoIG1vZGUpXG5cdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHQvLyBzdG9yZSBsaW5lIGdyYXBoIHBvaW50cyB0byBjcmVhdGUgbWlycm9yIGVmZmVjdCBpbiByYWRpYWwgbW9kZVxuXHRcdFx0bGV0IHBvaW50cyA9IFtdO1xuXG5cdFx0XHQvLyBkcmF3IGJhcnMgLyBsaW5lc1xuXG5cdFx0XHRmb3IgKCBsZXQgYmFySW5kZXggPSAwOyBiYXJJbmRleCA8IG5CYXJzOyBiYXJJbmRleCsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGJhciA9IF9iYXJzWyBiYXJJbmRleCBdLFxuXHRcdFx0XHRcdCAgeyBwb3NYLCBiYXJDZW50ZXIsIHdpZHRoLCBmcmVxLCBiaW5MbywgYmluSGksIHJhdGlvTG8sIHJhdGlvSGkgfSA9IGJhcjtcblxuXHRcdFx0XHRsZXQgYmFyVmFsdWUgPSBNYXRoLm1heCggaW50ZXJwb2xhdGUoIGJpbkxvLCByYXRpb0xvICksIGludGVycG9sYXRlKCBiaW5IaSwgcmF0aW9IaSApICk7XG5cblx0XHRcdFx0Ly8gY2hlY2sgYWRkaXRpb25hbCBiaW5zIChpZiBhbnkpIGZvciB0aGlzIGJhciBhbmQga2VlcCB0aGUgaGlnaGVzdCB2YWx1ZVxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IGJpbkxvICsgMTsgaiA8IGJpbkhpOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBmZnREYXRhWyBqIF0gPiBiYXJWYWx1ZSApXG5cdFx0XHRcdFx0XHRiYXJWYWx1ZSA9IGZmdERhdGFbIGogXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSBiYXIgYW1wbGl0dWRlIGluIFswOzFdIHJhbmdlXG5cdFx0XHRcdGJhclZhbHVlID0gdGhpcy5fbm9ybWFsaXplZEIoIGJhclZhbHVlICk7XG5cblx0XHRcdFx0YmFyLnZhbHVlWyBjaGFubmVsIF0gPSBiYXJWYWx1ZTtcblx0XHRcdFx0Y3VycmVudEVuZXJneSArPSBiYXJWYWx1ZTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgYmFyIHBlYWtcblx0XHRcdFx0aWYgKCBiYXIucGVha1sgY2hhbm5lbCBdID4gMCApIHtcblx0XHRcdFx0XHRiYXIuaG9sZFsgY2hhbm5lbCBdLS07XG5cdFx0XHRcdFx0Ly8gaWYgaG9sZCBpcyBuZWdhdGl2ZSwgaXQgYmVjb21lcyB0aGUgXCJhY2NlbGVyYXRpb25cIiBmb3IgcGVhayBkcm9wXG5cdFx0XHRcdFx0aWYgKCBiYXIuaG9sZFsgY2hhbm5lbCBdIDwgMCApXG5cdFx0XHRcdFx0XHRiYXIucGVha1sgY2hhbm5lbCBdICs9IGJhci5ob2xkWyBjaGFubmVsIF0gLyAoIGhvbGRGcmFtZXMgKiBob2xkRnJhbWVzIC8gMiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgaXQncyBhIG5ldyBwZWFrIGZvciB0aGlzIGJhclxuXHRcdFx0XHRpZiAoIGJhclZhbHVlID49IGJhci5wZWFrWyBjaGFubmVsIF0gKSB7XG5cdFx0XHRcdFx0YmFyLnBlYWtbIGNoYW5uZWwgXSA9IGJhclZhbHVlO1xuXHRcdFx0XHRcdGJhci5ob2xkWyBjaGFubmVsIF0gPSBob2xkRnJhbWVzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm90IHVzaW5nIHRoZSBjYW52YXMsIG1vdmUgZWFybGllciB0byB0aGUgbmV4dCBiYXJcblx0XHRcdFx0aWYgKCAhIHVzZUNhbnZhcyApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0Ly8gc2V0IG9wYWNpdHkgZm9yIGJhciBlZmZlY3RzXG5cdFx0XHRcdGlmICggaXNMdW1pIHx8IGlzQWxwaGEgKVxuXHRcdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSBiYXJWYWx1ZTtcblx0XHRcdFx0ZWxzZSBpZiAoIGlzT3V0bGluZSApXG5cdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IGZpbGxBbHBoYTtcblxuXHRcdFx0XHQvLyBzZXQgZmlsbFN0eWxlIGFuZCBzdHJva2VTdHlsZSBmb3IgdGhlIGN1cnJlbnQgYmFyXG5cdFx0XHRcdHNldEJhckNvbG9yKCBiYXJWYWx1ZSwgYmFySW5kZXggKTtcblxuXHRcdFx0XHQvLyBjb21wdXRlIGFjdHVhbCBiYXIgaGVpZ2h0IG9uIHNjcmVlblxuXHRcdFx0XHRjb25zdCBiYXJIZWlnaHQgPSBpc0x1bWkgPyBtYXhCYXJIZWlnaHQgOiBpc0xlZHMgPyBsZWRQb3NZKCBiYXJWYWx1ZSApIDogYmFyVmFsdWUgKiBtYXhCYXJIZWlnaHQgfCAwO1xuXG5cdFx0XHRcdC8vIERyYXcgY3VycmVudCBiYXIgb3IgbGluZSBzZWdtZW50XG5cblx0XHRcdFx0aWYgKCBfbW9kZSA9PSBNT0RFX0dSQVBIICkge1xuXHRcdFx0XHRcdC8vIGNvbXB1dGUgdGhlIGF2ZXJhZ2UgYmV0d2VlbiB0aGUgaW5pdGlhbCBiYXIgKGJhckluZGV4PT0wKSBhbmQgdGhlIG5leHQgb25lXG5cdFx0XHRcdFx0Ly8gdXNlZCB0byBzbW9vdGggdGhlIGN1cnZlIHdoZW4gdGhlIGluaXRpYWwgcG9zWCBpcyBvZmYgdGhlIHNjcmVlbiwgaW4gbWlycm9yIGFuZCByYWRpYWwgbW9kZXNcblx0XHRcdFx0XHRjb25zdCBuZXh0QmFyQXZnID0gYmFySW5kZXggPyAwIDogKCB0aGlzLl9ub3JtYWxpemVkQiggZmZ0RGF0YVsgX2JhcnNbMV0uYmluTG8gXSApICogbWF4QmFySGVpZ2h0ICsgYmFySGVpZ2h0ICkgLyAyO1xuXG5cdFx0XHRcdFx0aWYgKCBfcmFkaWFsICkge1xuXHRcdFx0XHRcdFx0aWYgKCBiYXJJbmRleCA9PSAwICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgKVxuXHRcdFx0XHRcdFx0XHRcdF9jdHgubW92ZVRvKCAuLi5yYWRpYWxYWSggMCwgMCApICk7XG5cdFx0XHRcdFx0XHRcdF9jdHgubGluZVRvKCAuLi5yYWRpYWxYWSggMCwgKCBwb3NYIDwgMCA/IG5leHRCYXJBdmcgOiBiYXJIZWlnaHQgKSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBkcmF3IGxpbmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQsIGF2b2lkaW5nIG92ZXJsYXBwaW5nIHdyYXAtYXJvdW5kIGZyZXF1ZW5jaWVzXG5cdFx0XHRcdFx0XHRpZiAoIHBvc1ggPj0gMCApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBbIHBvc1gsIGJhckhlaWdodCBdO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIC4uLnBvaW50ICkgKTtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2goIHBvaW50ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyAvLyBMaW5lYXJcblx0XHRcdFx0XHRcdGlmICggYmFySW5kZXggPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc3RhcnQgdGhlIGxpbmUgb2ZmLXNjcmVlbiB1c2luZyB0aGUgcHJldmlvdXMgRkZUIGJpbiB2YWx1ZSBhcyB0aGUgaW5pdGlhbCBhbXBsaXR1ZGVcblx0XHRcdFx0XHRcdFx0aWYgKCBfbWlycm9yID09IC0xICYmICEgaXNEdWFsSG9yaXpvbnRhbCApXG5cdFx0XHRcdFx0XHRcdFx0X2N0eC5tb3ZlVG8oIGluaXRpYWxYLCBhbmFseXplckJvdHRvbSAtICggcG9zWCA8IGluaXRpYWxYID8gbmV4dEJhckF2ZyA6IGJhckhlaWdodCApICk7XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHByZXZGRlREYXRhID0gYmluTG8gPyB0aGlzLl9ub3JtYWxpemVkQiggZmZ0RGF0YVsgYmluTG8gLSAxIF0gKSAqIG1heEJhckhlaWdodCA6IGJhckhlaWdodDsgLy8gdXNlIHByZXZpb3VzIEZGVCBiaW4gdmFsdWUsIHdoZW4gYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdFx0X2N0eC5tb3ZlVG8oIGluaXRpYWxYIC0gX2xpbmVXaWR0aCwgYW5hbHl6ZXJCb3R0b20gLSBwcmV2RkZURGF0YSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBkcmF3IGxpbmUgdG8gdGhlIGN1cnJlbnQgcG9pbnRcblx0XHRcdFx0XHRcdC8vIGF2b2lkIFggdmFsdWVzIGxvd2VyIHRoYW4gdGhlIG9yaWdpbiB3aGVuIG1pcnJvcmluZyBsZWZ0LCBvdGhlcndpc2UgZHJhdyB0aGVtIGZvciBiZXN0IGdyYXBoIGFjY3VyYWN5XG5cdFx0XHRcdFx0XHRpZiAoIGlzRHVhbEhvcml6b250YWwgfHwgX21pcnJvciAhPSAtMSB8fCBwb3NYID49IGluaXRpYWxYIClcblx0XHRcdFx0XHRcdFx0X2N0eC5saW5lVG8oIHBvc1gsIGFuYWx5emVyQm90dG9tIC0gYmFySGVpZ2h0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICggaXNMZWRzICkge1xuXHRcdFx0XHRcdFx0Ly8gZHJhdyBcInVubGl0XCIgbGVkcyAtIGF2b2lkIGRyYXdpbmcgaXQgdHdpY2Ugb24gJ2R1YWwtY29tYmluZWQnIGNoYW5uZWwgbGF5b3V0XG5cdFx0XHRcdFx0XHRpZiAoIHNob3dCZ0NvbG9yICYmICEgb3ZlcmxheSAmJiAoIGNoYW5uZWwgPT0gMCB8fCAhIGlzRHVhbENvbWJpbmVkICkgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFscGhhID0gX2N0eC5nbG9iYWxBbHBoYTtcblx0XHRcdFx0XHRcdFx0X2N0eC5zdHJva2VTdHlsZSA9IExFRFNfVU5MSVRfQ09MT1I7XG5cdFx0XHRcdFx0XHRcdF9jdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRcdFx0XHRzdHJva2VCYXIoIGJhckNlbnRlciwgY2hhbm5lbFRvcCwgYW5hbHl6ZXJCb3R0b20gKTtcblx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0XHRcdF9jdHguc3Ryb2tlU3R5bGUgPSBfY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpc1RydWVMZWRzICkge1xuXHRcdFx0XHRcdFx0XHQvLyBsZWRQb3NZKCkgaXMgdXNlZCBiZWxvdyB0byBmaXQgb25lIGVudGlyZSBsZWQgaGVpZ2h0IGludG8gdGhlIHNlbGVjdGVkIHJhbmdlXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNvbG9ySW5kZXggPSBpc0x1bWkgPyAwIDogY29sb3JTdG9wcy5maW5kTGFzdEluZGV4KCBpdGVtID0+IGxlZFBvc1koIGJhclZhbHVlICkgPD0gbGVkUG9zWSggaXRlbS5sZXZlbCApICk7XG5cdFx0XHRcdFx0XHRcdGxldCBsYXN0ID0gYW5hbHl6ZXJCb3R0b207XG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gY29sb3JDb3VudCAtIDE7IGkgPj0gY29sb3JJbmRleDsgaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdF9jdHguc3Ryb2tlU3R5bGUgPSBjb2xvclN0b3BzWyBpIF0uY29sb3I7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHkgPSBhbmFseXplckJvdHRvbSAtICggaSA9PSBjb2xvckluZGV4ID8gYmFySGVpZ2h0IDogbGVkUG9zWSggY29sb3JTdG9wc1sgaSBdLmxldmVsICkgKTtcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VCYXIoIGJhckNlbnRlciwgbGFzdCwgeSApO1xuXHRcdFx0XHRcdFx0XHRcdGxhc3QgPSB5IC0gbGVkU3BhY2VWO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHN0cm9rZUJhciggYmFyQ2VudGVyLCBhbmFseXplckJvdHRvbSwgYW5hbHl6ZXJCb3R0b20gLSBiYXJIZWlnaHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHBvc1ggPj0gaW5pdGlhbFggKSB7XG5cdFx0XHRcdFx0XHRpZiAoIF9yYWRpYWwgKVxuXHRcdFx0XHRcdFx0XHRyYWRpYWxQb2x5KCBwb3NYLCAwLCB3aWR0aCwgYmFySGVpZ2h0LCBpc091dGxpbmUgKTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBpc1JvdW5kICkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAvIDIsXG5cdFx0XHRcdFx0XHRcdFx0ICB5ID0gYW5hbHl6ZXJCb3R0b20gKyBoYWxmV2lkdGg7IC8vIHJvdW5kIGNhcHMgaGF2ZSBhbiBhZGRpdGlvbmFsIGhlaWdodCBvZiBoYWxmIGJhciB3aWR0aFxuXG5cdFx0XHRcdFx0XHRcdF9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRcdF9jdHgubW92ZVRvKCBwb3NYLCB5ICk7XG5cdFx0XHRcdFx0XHRcdF9jdHgubGluZVRvKCBwb3NYLCB5IC0gYmFySGVpZ2h0ICk7XG5cdFx0XHRcdFx0XHRcdF9jdHguYXJjKCBiYXJDZW50ZXIsIHkgLSBiYXJIZWlnaHQsIGhhbGZXaWR0aCwgUEksIFRBVSApO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggcG9zWCArIHdpZHRoLCB5ICk7XG5cdFx0XHRcdFx0XHRcdHN0cm9rZUlmKCBpc091dGxpbmUgKTtcblx0XHRcdFx0XHRcdFx0X2N0eC5maWxsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gaXNPdXRsaW5lID8gX2N0eC5saW5lV2lkdGggOiAwO1xuXHRcdFx0XHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRfY3R4LnJlY3QoIHBvc1gsIGFuYWx5emVyQm90dG9tICsgb2Zmc2V0LCB3aWR0aCwgLWJhckhlaWdodCAtIG9mZnNldCApO1xuXHRcdFx0XHRcdFx0XHRzdHJva2VJZiggaXNPdXRsaW5lICk7XG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERyYXcgcGVha1xuXHRcdFx0XHRjb25zdCBwZWFrID0gYmFyLnBlYWtbIGNoYW5uZWwgXTtcblx0XHRcdFx0aWYgKCBwZWFrID4gMCAmJiBzaG93UGVha3MgJiYgISBzaG93UGVha0xpbmUgJiYgISBpc0x1bWkgJiYgcG9zWCA+PSBpbml0aWFsWCAmJiBwb3NYIDwgZmluYWxYICkge1xuXHRcdFx0XHRcdC8vIHNldCBvcGFjaXR5XG5cdFx0XHRcdFx0aWYgKCBpc091dGxpbmUgJiYgX2xpbmVXaWR0aCA+IDAgKVxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGlzQWxwaGEgKVxuXHRcdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IHBlYWs7XG5cblx0XHRcdFx0XHQvLyBzZWxlY3QgdGhlIHBlYWsgY29sb3IgZm9yICdiYXItbGV2ZWwnIGNvbG9yTW9kZSBvciAndHJ1ZUxlZHMnXG5cdFx0XHRcdFx0aWYgKCBfY29sb3JNb2RlID09IENPTE9SX0JBUl9MRVZFTCB8fCBpc1RydWVMZWRzIClcblx0XHRcdFx0XHRcdHNldEJhckNvbG9yKCBwZWFrICk7XG5cblx0XHRcdFx0XHQvLyByZW5kZXIgcGVhayBhY2NvcmRpbmcgdG8gY3VycmVudCBtb2RlIC8gZWZmZWN0XG5cdFx0XHRcdFx0aWYgKCBpc0xlZHMgKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsZWRQZWFrID0gbGVkUG9zWSggcGVhayApO1xuXHRcdFx0XHRcdFx0aWYgKCBsZWRQZWFrID49IGxlZFNwYWNlViApIC8vIGF2b2lkIHBlYWsgYmVsb3cgZmlyc3QgbGVkXG5cdFx0XHRcdFx0XHRcdF9jdHguZmlsbFJlY3QoIHBvc1gsIGFuYWx5emVyQm90dG9tIC0gbGVkUGVhaywgd2lkdGgsIGxlZEhlaWdodCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggISBfcmFkaWFsIClcblx0XHRcdFx0XHRcdF9jdHguZmlsbFJlY3QoIHBvc1gsIGFuYWx5emVyQm90dG9tIC0gcGVhayAqIG1heEJhckhlaWdodCwgd2lkdGgsIDIgKTtcblx0XHRcdFx0XHRlbHNlIGlmICggX21vZGUgIT0gTU9ERV9HUkFQSCApIHsgLy8gcmFkaWFsIChwZWFrcyBmb3IgZ3JhcGggbW9kZSBhcmUgZG9uZSBieSB0aGUgcGVha0xpbmUgY29kZSlcblx0XHRcdFx0XHRcdGNvbnN0IHkgPSBwZWFrICogbWF4QmFySGVpZ2h0O1xuXHRcdFx0XHRcdFx0cmFkaWFsUG9seSggcG9zWCwgeSwgd2lkdGgsICEgdGhpcy5fcmFkaWFsSW52ZXJ0IHx8IGlzRHVhbFZlcnRpY2FsIHx8IHkgKyBpbm5lclJhZGl1cyA+PSAyID8gLTIgOiAyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gZm9yICggbGV0IGJhckluZGV4ID0gMDsgYmFySW5kZXggPCBuQmFyczsgYmFySW5kZXgrKyApXG5cblx0XHRcdC8vIGlmIG5vdCB1c2luZyB0aGUgY2FudmFzLCBtb3ZlIGVhcmxpZXIgdG8gdGhlIG5leHQgY2hhbm5lbFxuXHRcdFx0aWYgKCAhIHVzZUNhbnZhcyApXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvLyByZXN0b3JlIGdsb2JhbCBhbHBoYVxuXHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IDE7XG5cblx0XHRcdC8vIEZpbGwvc3Ryb2tlIGRyYXdpbmcgcGF0aCBmb3IgZ3JhcGggbW9kZVxuXHRcdFx0aWYgKCBfbW9kZSA9PSBNT0RFX0dSQVBIICkge1xuXHRcdFx0XHRzZXRCYXJDb2xvcigpOyAvLyBzZWxlY3QgY2hhbm5lbCBncmFkaWVudFxuXG5cdFx0XHRcdGlmICggX3JhZGlhbCAmJiAhIGlzRHVhbEhvcml6b250YWwgKSB7XG5cdFx0XHRcdFx0aWYgKCBfbWlycm9yICkge1xuXHRcdFx0XHRcdFx0bGV0IHA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIHAgPSBwb2ludHMucG9wKCkgKVxuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIC4uLnAsIC0xICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2N0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggX2xpbmVXaWR0aCA+IDAgKVxuXHRcdFx0XHRcdF9jdHguc3Ryb2tlKCk7XG5cblx0XHRcdFx0aWYgKCBmaWxsQWxwaGEgPiAwICkge1xuXHRcdFx0XHRcdGlmICggX3JhZGlhbCApIHtcblx0XHRcdFx0XHRcdC8vIGV4Y2x1ZGUgdGhlIGNlbnRlciBjaXJjbGUgZnJvbSB0aGUgZmlsbCBhcmVhXG5cdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IGlzRHVhbEhvcml6b250YWwgPyBnZXRBbmdsZSggYW5hbHl6ZXJXaWR0aCA+PiAxICkgOiAwLFxuXHRcdFx0XHRcdFx0XHQgIGVuZCAgID0gaXNEdWFsSG9yaXpvbnRhbCA/IGdldEFuZ2xlKCBhbmFseXplcldpZHRoICkgOiBUQVU7XG5cdFx0XHRcdFx0XHRfY3R4Lm1vdmVUbyggLi4ucmFkaWFsWFkoIGlzRHVhbEhvcml6b250YWwgPyBhbmFseXplcldpZHRoID4+IDEgOiAwLCAwICkgKTtcblx0XHRcdFx0XHRcdF9jdHguYXJjKCBjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgc3RhcnQsIGVuZCwgaXNEdWFsSG9yaXpvbnRhbCA/ICEgaW52ZXJ0ZWRDaGFubmVsIDogdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNsb3NlIHRoZSBmaWxsIGFyZWFcblx0XHRcdFx0XHRcdF9jdHgubGluZVRvKCBmaW5hbFgsIGFuYWx5emVyQm90dG9tICk7XG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggaW5pdGlhbFgsIGFuYWx5emVyQm90dG9tICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2N0eC5nbG9iYWxBbHBoYSA9IGZpbGxBbHBoYTtcblx0XHRcdFx0XHRfY3R4LmZpbGwoKTtcblx0XHRcdFx0XHRfY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRyYXcgcGVhayBsaW5lIChhbmQgc3RhbmRhcmQgcGVha3Mgb24gcmFkaWFsKVxuXHRcdFx0XHRpZiAoIHNob3dQZWFrTGluZSB8fCAoIF9yYWRpYWwgJiYgc2hvd1BlYWtzICkgKSB7XG5cdFx0XHRcdFx0cG9pbnRzID0gW107IC8vIGZvciBtaXJyb3IgbGluZSBvbiByYWRpYWxcblx0XHRcdFx0XHRfY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdF9iYXJzLmZvckVhY2goICggYiwgaSApID0+IHtcblx0XHRcdFx0XHRcdGxldCB4ID0gYi5wb3NYLFxuXHRcdFx0XHRcdFx0XHRoID0gYi5wZWFrWyBjaGFubmVsIF0sXG5cdFx0XHRcdFx0XHRcdG0gPSBpID8gJ2xpbmVUbycgOiAnbW92ZVRvJztcblx0XHRcdFx0XHRcdGlmICggX3JhZGlhbCAmJiB4IDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV4dEJhciA9IF9iYXJzWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRoID0gZmluZFkoIHgsIGgsIG5leHRCYXIucG9zWCwgbmV4dEJhci5wZWFrWyBjaGFubmVsIF0sIDAgKTtcblx0XHRcdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoICo9IG1heEJhckhlaWdodDtcblx0XHRcdFx0XHRcdGlmICggc2hvd1BlYWtMaW5lICkge1xuXHRcdFx0XHRcdFx0XHRfY3R4WyBtIF0oIC4uLiggX3JhZGlhbCA/IHJhZGlhbFhZKCB4LCBoICkgOiBbIHgsIGFuYWx5emVyQm90dG9tIC0gaCBdICkgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBfcmFkaWFsICYmIF9taXJyb3IgJiYgISBpc0R1YWxIb3Jpem9udGFsIClcblx0XHRcdFx0XHRcdFx0XHRwb2ludHMucHVzaCggWyB4LCBoIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBoID4gMCApXG5cdFx0XHRcdFx0XHRcdHJhZGlhbFBvbHkoIHgsIGgsIDEsIC0yICk7IC8vIHN0YW5kYXJkIHBlYWtzIChhbHNvIGRvZXMgbWlycm9yKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmICggc2hvd1BlYWtMaW5lICkge1xuXHRcdFx0XHRcdFx0bGV0IHA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIHAgPSBwb2ludHMucG9wKCkgKVxuXHRcdFx0XHRcdFx0XHRfY3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIC4uLnAsIC0xICkgKTsgLy8gbWlycm9yIGxpbmUgcG9pbnRzXG5cdFx0XHRcdFx0XHRfY3R4LmxpbmVXaWR0aCA9IDE7XG5cdFx0XHRcdFx0XHRfY3R4LnN0cm9rZSgpOyAvLyBzdHJva2UgcGVhayBsaW5lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jdHgucmVzdG9yZSgpOyAvLyByZXN0b3JlIGNsaXAgcmVnaW9uXG5cblx0XHRcdGlmICggaXNEdWFsSG9yaXpvbnRhbCAmJiAhIF9yYWRpYWwgKVxuXHRcdFx0XHRfY3R4LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuXG5cdFx0XHQvLyBjcmVhdGUgUmVmbGV4IGVmZmVjdCAtIGZvciBkdWFsLWNvbWJpbmVkIGFuZCBkdWFsLWhvcml6b250YWwgZG8gaXQgb25seSBvbmNlLCBhZnRlciBjaGFubmVsIDFcblx0XHRcdGlmICggKCAhIGlzRHVhbEhvcml6b250YWwgJiYgISBpc0R1YWxDb21iaW5lZCApIHx8IGNoYW5uZWwgKVxuXHRcdFx0XHRkb1JlZmxleCggY2hhbm5lbCApO1xuXG5cdFx0fSAvLyBmb3IgKCBsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBuQ2hhbm5lbHM7IGNoYW5uZWwrKyApIHtcblxuXHRcdHVwZGF0ZUVuZXJneSggY3VycmVudEVuZXJneSAvICggbkJhcnMgPDwgKCBuQ2hhbm5lbHMgLSAxICkgKSApO1xuXG5cdFx0aWYgKCB1c2VDYW52YXMgKSB7XG5cdFx0XHQvLyBNaXJyb3IgZWZmZWN0XG5cdFx0XHRpZiAoIF9taXJyb3IgJiYgISBfcmFkaWFsICYmICEgaXNEdWFsSG9yaXpvbnRhbCApIHtcblx0XHRcdFx0X2N0eC5zZXRUcmFuc2Zvcm0oIC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGggLSBpbml0aWFsWCwgMCApO1xuXHRcdFx0XHRfY3R4LmRyYXdJbWFnZSggY2FudmFzLCBpbml0aWFsWCwgMCwgY2VudGVyWCwgY2FudmFzLmhlaWdodCwgMCwgMCwgY2VudGVyWCwgY2FudmFzLmhlaWdodCApO1xuXHRcdFx0XHRfY3R4LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXN0b3JlIHNvbGlkIGxpbmVzXG5cdFx0XHRfY3R4LnNldExpbmVEYXNoKFtdKTtcblxuXHRcdFx0Ly8gZHJhdyBmcmVxdWVuY3kgc2NhbGUgKFgtYXhpcylcblx0XHRcdGRyYXdTY2FsZVgoKTtcblx0XHR9XG5cblx0XHQvLyBkaXNwbGF5IGN1cnJlbnQgZnJhbWUgcmF0ZVxuXHRcdGlmICggdGhpcy5zaG93RlBTICkge1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IGNhbnZhc1guaGVpZ2h0O1xuXHRcdFx0X2N0eC5mb250ID0gYGJvbGQgJHtzaXplfXB4ICR7Rk9OVF9GQU1JTFl9YDtcblx0XHRcdF9jdHguZmlsbFN0eWxlID0gRlBTX0NPTE9SO1xuXHRcdFx0X2N0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuXHRcdFx0X2N0eC5maWxsVGV4dCggTWF0aC5yb3VuZCggX2ZwcyApLCBjYW52YXMud2lkdGggLSBzaXplLCBzaXplICogMiApO1xuXHRcdH1cblxuXHRcdC8vIGNhbGwgY2FsbGJhY2sgZnVuY3Rpb24sIGlmIGRlZmluZWRcblx0XHRpZiAoIHRoaXMub25DYW52YXNEcmF3ICkge1xuXHRcdFx0X2N0eC5zYXZlKCk7XG5cdFx0XHRfY3R4LmZpbGxTdHlsZSA9IF9jdHguc3Ryb2tlU3R5bGUgPSBfY2FudmFzR3JhZGllbnRzWzBdO1xuXHRcdFx0dGhpcy5vbkNhbnZhc0RyYXcoIHRoaXMsIHsgdGltZXN0YW1wLCBjYW52YXNHcmFkaWVudHM6IF9jYW52YXNHcmFkaWVudHMgfSApO1xuXHRcdFx0X2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBzY2FsZWQgZnJlcXVlbmN5IGFjY29yZGluZyB0byB0aGUgc2VsZWN0ZWQgc2NhbGVcblx0ICovXG5cdF9mcmVxU2NhbGluZyggZnJlcSApIHtcblx0XHRzd2l0Y2ggKCB0aGlzLl9mcmVxdWVuY3lTY2FsZSApIHtcblx0XHRcdGNhc2UgU0NBTEVfTE9HIDpcblx0XHRcdFx0cmV0dXJuIE1hdGgubG9nMiggZnJlcSApO1xuXHRcdFx0Y2FzZSBTQ0FMRV9CQVJLIDpcblx0XHRcdFx0cmV0dXJuICggMjYuODEgKiBmcmVxICkgLyAoIDE5NjAgKyBmcmVxICkgLSAuNTM7XG5cdFx0XHRjYXNlIFNDQUxFX01FTCA6XG5cdFx0XHRcdHJldHVybiBNYXRoLmxvZzIoIDEgKyBmcmVxIC8gNzAwICk7XG5cdFx0XHRjYXNlIFNDQUxFX0xJTkVBUiA6XG5cdFx0XHRcdHJldHVybiBmcmVxO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIEZGVCBkYXRhIGJpbiAoYXJyYXkgaW5kZXgpIHdoaWNoIHJlcHJlc2VudHMgYSBnaXZlbiBmcmVxdWVuY3lcblx0ICovXG5cdF9mcmVxVG9CaW4oIGZyZXEsIG1ldGhvZCA9ICdyb3VuZCcgKSB7XG5cdFx0Y29uc3QgbWF4ID0gdGhpcy5fYW5hbHl6ZXJbMF0uZnJlcXVlbmN5QmluQ291bnQgLSAxLFxuXHRcdFx0ICBiaW4gPSBNYXRoWyBtZXRob2QgXSggZnJlcSAqIHRoaXMuZmZ0U2l6ZSAvIHRoaXMuYXVkaW9DdHguc2FtcGxlUmF0ZSApO1xuXG5cdFx0cmV0dXJuIGJpbiA8IG1heCA/IGJpbiA6IG1heDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBjdXJyZW50bHkgc2VsZWN0ZWQgZ3JhZGllbnRcblx0ICovXG5cdF9tYWtlR3JhZCgpIHtcblx0XHRpZiAoICEgdGhpcy5fcmVhZHkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y29uc3QgeyBjYW52YXMsIF9jdHgsIF9yYWRpYWwsIF9yZWZsZXhSYXRpbyB9ID0gdGhpcyxcblx0XHRcdCAgeyBhbmFseXplcldpZHRoLCBjZW50ZXJYLCBjZW50ZXJZLCBpbml0aWFsWCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLl9hdXgsXG5cdFx0XHQgIHsgaXNMdW1pIH0gICAgID0gdGhpcy5fZmxnLFxuXHRcdFx0ICBpc0R1YWxWZXJ0aWNhbCA9IHRoaXMuX2NoTGF5b3V0ID09IENIQU5ORUxfVkVSVElDQUwsXG5cdFx0XHQgIGFuYWx5emVyUmF0aW8gID0gMSAtIF9yZWZsZXhSYXRpbyxcblx0XHRcdCAgZ3JhZGllbnRIZWlnaHQgPSBpc0x1bWkgPyBjYW52YXMuaGVpZ2h0IDogY2FudmFzLmhlaWdodCAqICggMSAtIF9yZWZsZXhSYXRpbyAqICggISBpc0R1YWxWZXJ0aWNhbCApICkgfCAwO1xuXHRcdFx0ICBcdFx0XHRcdCAgIC8vIGZvciB2ZXJ0aWNhbCBzdGVyZW8gd2Uga2VlcCB0aGUgZnVsbCBjYW52YXMgaGVpZ2h0IGFuZCBoYW5kbGUgdGhlIHJlZmxleCBhcmVhcyB3aGlsZSBnZW5lcmF0aW5nIHRoZSBjb2xvciBzdG9wc1xuXG5cdFx0Zm9yICggY29uc3QgY2hhbm5lbCBvZiBbMCwxXSApIHtcblx0XHRcdGNvbnN0IGN1cnJHcmFkaWVudCA9IHRoaXMuX2dyYWRpZW50c1sgdGhpcy5fc2VsZWN0ZWRHcmFkc1sgY2hhbm5lbCBdIF0sXG5cdFx0XHRcdCAgY29sb3JTdG9wcyAgID0gY3VyckdyYWRpZW50LmNvbG9yU3RvcHMsXG5cdFx0XHRcdCAgaXNIb3Jpem9udGFsID0gY3VyckdyYWRpZW50LmRpciA9PSAnaCc7XG5cblx0XHRcdGxldCBncmFkO1xuXG5cdFx0XHRpZiAoIF9yYWRpYWwgKVxuXHRcdFx0XHRncmFkID0gX2N0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCggY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzIC0gKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgKiBpc0R1YWxWZXJ0aWNhbCApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRncmFkID0gX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCggLi4uKCBpc0hvcml6b250YWwgPyBbIGluaXRpYWxYLCAwLCBpbml0aWFsWCArIGFuYWx5emVyV2lkdGgsIDAgXSA6IFsgMCwgMCwgMCwgZ3JhZGllbnRIZWlnaHQgXSApICk7XG5cblx0XHRcdGlmICggY29sb3JTdG9wcyApIHtcblx0XHRcdFx0Y29uc3QgZHVhbCA9IGlzRHVhbFZlcnRpY2FsICYmICEgdGhpcy5fc3BsaXRHcmFkaWVudCAmJiAoICEgaXNIb3Jpem9udGFsIHx8IF9yYWRpYWwgKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgY2hhbm5lbEFyZWEgPSAwOyBjaGFubmVsQXJlYSA8IDEgKyBkdWFsOyBjaGFubmVsQXJlYSsrICkge1xuXHRcdFx0XHRcdGNvbnN0IG1heEluZGV4ID0gY29sb3JTdG9wcy5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdFx0Y29sb3JTdG9wcy5mb3JFYWNoKCAoIGNvbG9yU3RvcCwgaW5kZXggKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgb2Zmc2V0ID0gY29sb3JTdG9wLnBvcztcblxuXHRcdFx0XHRcdFx0Ly8gaW4gZHVhbCBtb2RlIChub3Qgc3BsaXQpLCB1c2UgaGFsZiB0aGUgb3JpZ2luYWwgb2Zmc2V0IGZvciBlYWNoIGNoYW5uZWxcblx0XHRcdFx0XHRcdGlmICggZHVhbCApXG5cdFx0XHRcdFx0XHRcdG9mZnNldCAvPSAyO1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zdHJhaW4gdGhlIG9mZnNldCB3aXRoaW4gdGhlIHVzZWZ1bCBhbmFseXplciBhcmVhcyAoYXZvaWQgcmVmbGV4IGFyZWFzKVxuXHRcdFx0XHRcdFx0aWYgKCBpc0R1YWxWZXJ0aWNhbCAmJiAhIGlzTHVtaSAmJiAhIF9yYWRpYWwgJiYgISBpc0hvcml6b250YWwgKSB7XG5cdFx0XHRcdFx0XHRcdG9mZnNldCAqPSBhbmFseXplclJhdGlvO1xuXHRcdFx0XHRcdFx0XHQvLyBza2lwIHRoZSBmaXJzdCByZWZsZXggYXJlYSBpbiBzcGxpdCBtb2RlXG5cdFx0XHRcdFx0XHRcdGlmICggISBkdWFsICYmIG9mZnNldCA+IC41ICogYW5hbHl6ZXJSYXRpbyApXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IC41ICogX3JlZmxleFJhdGlvO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBvbmx5IGZvciBkdWFsLXZlcnRpY2FsIG5vbi1zcGxpdCBncmFkaWVudCAoY3JlYXRlcyBmdWxsIGdyYWRpZW50IG9uIGJvdGggaGFsdmVzIG9mIHRoZSBjYW52YXMpXG5cdFx0XHRcdFx0XHRpZiAoIGNoYW5uZWxBcmVhID09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFkZCBjb2xvcnMgaW4gcmV2ZXJzZSBvcmRlciBpZiByYWRpYWwgb3IgbHVtaSBhcmUgYWN0aXZlXG5cdFx0XHRcdFx0XHRcdGlmICggX3JhZGlhbCB8fCBpc0x1bWkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmV2SW5kZXggPSBtYXhJbmRleCAtIGluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdGNvbG9yU3RvcCA9IGNvbG9yU3RvcHNbIHJldkluZGV4IF07XG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gMSAtIGNvbG9yU3RvcC5wb3MgLyAyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBmaXJzdCBvZmZzZXQgaXMgbm90IDAsIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbG9yIHN0b3AgdG8gcHJldmVudCBibGVlZGluZyBmcm9tIHRoZSBmaXJzdCBjaGFubmVsXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PSAwICYmIG9mZnNldCA+IDAgKVxuXHRcdFx0XHRcdFx0XHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoIC41LCBjb2xvclN0b3AuY29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBidW1wIHRoZSBvZmZzZXQgdG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAuNTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBhZGQgZ3JhZGllbnQgY29sb3Igc3RvcFxuXHRcdFx0XHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoIG9mZnNldCwgY29sb3JTdG9wLmNvbG9yICk7XG5cblx0XHRcdFx0XHRcdC8vIGNyZWF0ZSBhZGRpdGlvbmFsIGNvbG9yIHN0b3AgYXQgdGhlIGVuZCBvZiBmaXJzdCBjaGFubmVsIHRvIHByZXZlbnQgYmxlZWRpbmdcblx0XHRcdFx0XHRcdGlmICggaXNEdWFsVmVydGljYWwgJiYgaW5kZXggPT0gbWF4SW5kZXggJiYgb2Zmc2V0IDwgLjUgKVxuXHRcdFx0XHRcdFx0XHRncmFkLmFkZENvbG9yU3RvcCggLjUsIGNvbG9yU3RvcC5jb2xvciApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IC8vIGZvciAoIGxldCBjaGFubmVsQXJlYSA9IDA7IGNoYW5uZWxBcmVhIDwgMSArIGR1YWw7IGNoYW5uZWxBcmVhKysgKVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jYW52YXNHcmFkaWVudHNbIGNoYW5uZWwgXSA9IGdyYWQ7XG5cdFx0fSAvLyBmb3IgKCBjb25zdCBjaGFubmVsIG9mIFswLDFdIClcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemUgYSBkQiB2YWx1ZSBpbiB0aGUgWzA7MV0gcmFuZ2Vcblx0ICovXG5cdF9ub3JtYWxpemVkQiggdmFsdWUgKSB7XG5cdFx0Y29uc3QgaXNMaW5lYXIgICA9IHRoaXMuX2xpbmVhckFtcGxpdHVkZSxcblx0XHRcdCAgYm9vc3QgICAgICA9IGlzTGluZWFyID8gMSAvIHRoaXMuX2xpbmVhckJvb3N0IDogMSxcblx0XHRcdCAgY2xhbXAgICAgICA9ICggdmFsLCBtaW4sIG1heCApID0+IHZhbCA8PSBtaW4gPyBtaW4gOiB2YWwgPj0gbWF4ID8gbWF4IDogdmFsLFxuXHRcdFx0ICBkQlRvTGluZWFyID0gdmFsID0+IDEwICoqICggdmFsIC8gMjAgKTtcblxuXHRcdGxldCBtYXhWYWx1ZSA9IHRoaXMubWF4RGVjaWJlbHMsXG5cdFx0XHRtaW5WYWx1ZSA9IHRoaXMubWluRGVjaWJlbHM7XG5cblx0XHRpZiAoIGlzTGluZWFyICkge1xuXHRcdFx0bWF4VmFsdWUgPSBkQlRvTGluZWFyKCBtYXhWYWx1ZSApO1xuXHRcdFx0bWluVmFsdWUgPSBkQlRvTGluZWFyKCBtaW5WYWx1ZSApO1xuXHRcdFx0dmFsdWUgPSBkQlRvTGluZWFyKCB2YWx1ZSApICoqIGJvb3N0O1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGFtcCggKCB2YWx1ZSAtIG1pblZhbHVlICkgLyAoIG1heFZhbHVlIC0gbWluVmFsdWUgKSAqKiBib29zdCwgMCwgMSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNoYW5nZSBjYW52YXMgZGltZW5zaW9ucyBvbiBkZW1hbmRcblx0ICovXG5cdF9zZXRDYW52YXMoIHJlYXNvbiApIHtcblx0XHRpZiAoICEgdGhpcy5fcmVhZHkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y29uc3QgeyBjYW52YXMsIF9jdHggfSA9IHRoaXMsXG5cdFx0XHQgIGNhbnZhc1ggICAgPSB0aGlzLl9zY2FsZVguY2FudmFzLFxuXHRcdFx0ICBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gLyAoIHRoaXMuX2xvUmVzICsgMSApO1xuXG5cdFx0bGV0IHNjcmVlbldpZHRoICA9IHdpbmRvdy5zY3JlZW4ud2lkdGggICogcGl4ZWxSYXRpbyxcblx0XHRcdHNjcmVlbkhlaWdodCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuXHRcdC8vIEZpeCBmb3IgaU9TIFNhZmFyaSAtIHN3YXAgd2lkdGggYW5kIGhlaWdodCB3aGVuIGluIGxhbmRzY2FwZVxuXHRcdGlmICggTWF0aC5hYnMoIHdpbmRvdy5vcmllbnRhdGlvbiApID09IDkwICYmIHNjcmVlbldpZHRoIDwgc2NyZWVuSGVpZ2h0IClcblx0XHRcdFsgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCBdID0gWyBzY3JlZW5IZWlnaHQsIHNjcmVlbldpZHRoIF07XG5cblx0XHRjb25zdCBpc0Z1bGxzY3JlZW4gPSB0aGlzLmlzRnVsbHNjcmVlbixcblx0XHRcdCAgaXNDYW52YXNGcyAgID0gaXNGdWxsc2NyZWVuICYmIHRoaXMuX2ZzRWwgPT0gY2FudmFzLFxuXHRcdFx0ICBuZXdXaWR0aCAgICAgPSBpc0NhbnZhc0ZzID8gc2NyZWVuV2lkdGggIDogKCB0aGlzLl93aWR0aCAgfHwgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoICB8fCB0aGlzLl9kZWZhdWx0V2lkdGggICkgKiBwaXhlbFJhdGlvIHwgMCxcblx0XHRcdCAgbmV3SGVpZ2h0ICAgID0gaXNDYW52YXNGcyA/IHNjcmVlbkhlaWdodCA6ICggdGhpcy5faGVpZ2h0IHx8IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgdGhpcy5fZGVmYXVsdEhlaWdodCApICogcGl4ZWxSYXRpbyB8IDA7XG5cblx0XHQvLyBzZXQvdXBkYXRlIG9iamVjdCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cdFx0dGhpcy5fZnNXaWR0aCAgICA9IHNjcmVlbldpZHRoO1xuXHRcdHRoaXMuX2ZzSGVpZ2h0ICAgPSBzY3JlZW5IZWlnaHQ7XG5cblx0XHQvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY29uc3RydWN0b3IgY2FsbCBhbmQgY2FudmFzIGRpbWVuc2lvbnMgaGF2ZW4ndCBjaGFuZ2VkLCBxdWl0XG5cdFx0aWYgKCByZWFzb24gIT0gUkVBU09OX0NSRUFURSAmJiBjYW52YXMud2lkdGggPT0gbmV3V2lkdGggJiYgY2FudmFzLmhlaWdodCA9PSBuZXdIZWlnaHQgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gYXBwbHkgbmV3IGRpbWVuc2lvbnNcblx0XHRjYW52YXMud2lkdGggID0gbmV3V2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcblxuXHRcdC8vIGlmIG5vdCBpbiBvdmVybGF5IG1vZGUsIHBhaW50IHRoZSBjYW52YXMgYmxhY2tcblx0XHRpZiAoICEgdGhpcy5vdmVybGF5ICkge1xuXHRcdFx0X2N0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0XHRfY3R4LmZpbGxSZWN0KCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IGxpbmVKb2luIHByb3BlcnR5IGZvciBhcmVhIGZpbGwgbW9kZSAodGhpcyBpcyByZXNldCB3aGVuZXZlciB0aGUgY2FudmFzIHNpemUgY2hhbmdlcylcblx0XHRfY3R4LmxpbmVKb2luID0gJ2JldmVsJztcblxuXHRcdC8vIHVwZGF0ZSBkaW1lbnNpb25zIG9mIHRoZSBzY2FsZSBjYW52YXNcblx0XHRjYW52YXNYLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0Y2FudmFzWC5oZWlnaHQgPSBNYXRoLm1heCggMjAgKiBwaXhlbFJhdGlvLCBNYXRoLm1pbiggbmV3V2lkdGgsIG5ld0hlaWdodCApIC8gMzIgfCAwICk7XG5cblx0XHQvLyBjYWxjdWxhdGUgYmFyIHBvc2l0aW9ucyBhbmQgbGVkIG9wdGlvbnNcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXG5cdFx0Ly8gKHJlKWdlbmVyYXRlIGdyYWRpZW50XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblxuXHRcdC8vIGRldGVjdCBmdWxsc2NyZWVuIGNoYW5nZXMgKGZvciBTYWZhcmkpXG5cdFx0aWYgKCB0aGlzLl9mc1N0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZzU3RhdHVzICE9PSBpc0Z1bGxzY3JlZW4gKVxuXHRcdFx0cmVhc29uID0gUkVBU09OX0ZTQ0hBTkdFO1xuXHRcdHRoaXMuX2ZzU3RhdHVzID0gaXNGdWxsc2NyZWVuO1xuXG5cdFx0Ly8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIGlmIGRlZmluZWRcblx0XHRpZiAoIHRoaXMub25DYW52YXNSZXNpemUgKVxuXHRcdFx0dGhpcy5vbkNhbnZhc1Jlc2l6ZSggcmVhc29uLCB0aGlzICk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0IGEgZ3JhZGllbnQgZm9yIG9uZSBvciBib3RoIGNoYW5uZWxzXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGdyYWRpZW50IG5hbWVcblx0ICogQHBhcmFtIFt7bnVtYmVyfV0gZGVzaXJlZCBjaGFubmVsICgwIG9yIDEpIC0gaWYgZW1wdHkgb3IgaW52YWxpZCwgc2V0cyBib3RoIGNoYW5uZWxzXG5cdCAqL1xuXHRfc2V0R3JhZGllbnQoIG5hbWUsIGNoYW5uZWwgKSB7XG5cdFx0aWYgKCAhIHRoaXMuX2dyYWRpZW50cy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCBFUlJfVU5LTk9XTl9HUkFESUVOVCwgbmFtZSApO1xuXG5cdFx0aWYgKCAhIFswLDFdLmluY2x1ZGVzKCBjaGFubmVsICkgKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZEdyYWRzWzFdID0gbmFtZTtcblx0XHRcdGNoYW5uZWwgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NlbGVjdGVkR3JhZHNbIGNoYW5uZWwgXSA9IG5hbWU7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgb2JqZWN0IHByb3BlcnRpZXNcblx0ICovXG5cdF9zZXRQcm9wcyggb3B0aW9ucywgdXNlRGVmYXVsdHMgKSB7XG5cdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb25zIHByb3BlcnRpZXNcblx0XHRjb25zdCBjYWxsYmFja3MgPSBbICdvbkNhbnZhc0RyYXcnLCAnb25DYW52YXNSZXNpemUnIF07XG5cblx0XHQvLyBwcm9wZXJ0aWVzIG5vdCBpbiB0aGUgZGVmYXVsdHMgKGBzdGVyZW9gIGlzIGRlcHJlY2F0ZWQpXG5cdFx0Y29uc3QgZXh0cmFQcm9wcyA9IFsgJ2dyYWRpZW50TGVmdCcsICdncmFkaWVudFJpZ2h0JywgJ3N0ZXJlbycgXTtcblxuXHRcdC8vIGJ1aWxkIGFuIGFycmF5IG9mIHZhbGlkIHByb3BlcnRpZXM7IGBzdGFydGAgaXMgbm90IGFuIGFjdHVhbCBwcm9wZXJ0eSBhbmQgaXMgaGFuZGxlZCBhZnRlciBzZXR0aW5nIGV2ZXJ5dGhpbmcgZWxzZVxuXHRcdGNvbnN0IHZhbGlkUHJvcHMgPSBPYmplY3Qua2V5cyggREVGQVVMVF9TRVRUSU5HUyApLmZpbHRlciggZSA9PiBlICE9ICdzdGFydCcgKS5jb25jYXQoIGNhbGxiYWNrcywgZXh0cmFQcm9wcyApO1xuXG5cdFx0aWYgKCB1c2VEZWZhdWx0cyB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgKVxuXHRcdFx0b3B0aW9ucyA9IHsgLi4uREVGQVVMVF9TRVRUSU5HUywgLi4ub3B0aW9ucyB9OyAvLyBtZXJnZSBvcHRpb25zIHdpdGggZGVmYXVsdHNcblxuXHRcdGZvciAoIGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoIG9wdGlvbnMgKSApIHtcblx0XHRcdGlmICggY2FsbGJhY2tzLmluY2x1ZGVzKCBwcm9wICkgJiYgdHlwZW9mIG9wdGlvbnNbIHByb3AgXSAhPT0gJ2Z1bmN0aW9uJyApIC8vIGNoZWNrIGludmFsaWQgY2FsbGJhY2tcblx0XHRcdFx0dGhpc1sgcHJvcCBdID0gdW5kZWZpbmVkO1xuXHRcdFx0ZWxzZSBpZiAoIHZhbGlkUHJvcHMuaW5jbHVkZXMoIHByb3AgKSApIC8vIHNldCBvbmx5IHZhbGlkIHByb3BlcnRpZXNcblx0XHRcdFx0dGhpc1sgcHJvcCBdID0gb3B0aW9uc1sgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIGRlcHJlY2F0ZWQgLSBtb3ZlIHRoaXMgdG8gdGhlIGNvbnN0cnVjdG9yIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UgKGBzdGFydGAgc2hvdWxkIGJlIGNvbnN0cnVjdG9yLXNwZWNpZmljKVxuXHRcdGlmICggb3B0aW9ucy5zdGFydCAhPT0gdW5kZWZpbmVkIClcblx0XHRcdHRoaXMudG9nZ2xlQW5hbHl6ZXIoIG9wdGlvbnMuc3RhcnQgKTtcblx0fVxuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;